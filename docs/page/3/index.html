<!DOCTYPE html><html n-head=""n-head-ssr><meta n-head="true"charset="utf-8"><meta n-head="true"content="width=device-width,initial-scale=1"name="viewport"><meta n-head="true"content="ffe blog"name="description"hid="description"><title n-head="true">Archive list</title><link href="/favicon.ico"rel="icon"n-head="true"type="image/x-icon"><link href="http://cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"rel="stylesheet"n-head="true"><base href="/nuxt-blog/"><link href="/nuxt-blog/_nuxt/style.css"rel="stylesheet"><body n-head=""><div id="__nuxt"server-rendered="true"><div class="progress"data-v-04b1682c style="width:0;height:2px;background-color:#000;opacity:0"></div><div class="wrapper"><nav class="main-menu navbar navbar-default"><div class="container"><div class="logo"><a href="/nuxt-blog/"><h2>ffe</h2></a></div><div class="nav-item"><ul class="nav navbar-nav navbar-right"><li><a href="/nuxt-blog/">Home</a><li><a href="/nuxt-blog/page/1">Posts</a><li><a href="/nuxt-blog/asks/1?currentPage=1">Ask</a><li><a href="/nuxt-blog/about">About</a></ul></div></div></nav><section class="container page-wrapper"data-v-11d9cd28><div class="pageWrap"data-v-11d9cd28><ul data-v-11d9cd28><li data-v-11d9cd28><a href="/nuxt-blog/posts/2"data-v-11d9cd28>jQuery is not must for us</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/3"data-v-11d9cd28>jQuery is not must for us——异步请求</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/4"data-v-11d9cd28>那些被忽视的字体细节</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/5"data-v-11d9cd28>简单cssHack了解，让ie支持H5、css3</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/6"data-v-11d9cd28>静态服务器搭建</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/7"data-v-11d9cd28>图片延迟加载简单实现</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/8"data-v-11d9cd28>前端开发环境搭建</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/9"data-v-11d9cd28>前端代码规范</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/10"data-v-11d9cd28>使用inline-block与浮动前需要了解这些</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/11"data-v-11d9cd28>what's is yeoman</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/12"data-v-11d9cd28>The Little Schemer——read again</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/13"data-v-11d9cd28>css特殊图形绘制</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/14"data-v-11d9cd28>css居中那些事</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/15"data-v-11d9cd28>css3简易魔方绘制</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/16"data-v-11d9cd28>Coding form zero</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/17"data-v-11d9cd28>jQuery is not must for us——DOM操作</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/18"data-v-11d9cd28>jQuery is not must for us——异步请求</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/19"data-v-11d9cd28>再谈对闭包的理解</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/20"data-v-11d9cd28>jQuery is not must for us——事件</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/21"data-v-11d9cd28>jQuery is not must for us——DOM操作</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/22"data-v-11d9cd28>ES6 new features</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/23"data-v-11d9cd28>轮播图，So easy</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/24"data-v-11d9cd28>jQuery is not must for us——事件</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/25"data-v-11d9cd28>javascript 闭包、this</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/26"data-v-11d9cd28>简单的dom库和轻量级mvvm框架的尝试</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/27"data-v-11d9cd28>基于NodeJS实现的一个css预处理器</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/28"data-v-11d9cd28>jQuery is not must for us--元素选取</a><li data-v-11d9cd28><a href="/nuxt-blog/posts/29"data-v-11d9cd28>jQuery is not must for us--元素选取</a></ul></div></section><footer class="footer">Visit our website for more documentation : <a href="https://nuxtjs.org"target="_blank">nuxtjs.org</a></footer></div></div><script defer>window.__NUXT__={data:[{posts:{data:[{meta:{title:"jQuery is not must for us",date:"2015-11-24T11:40:32.000Z",tags:"jquery",archives:"pl",id:"2",createTime:"2015-11-24",url:"2015-11-24-jQuery is not must for us",strTag:"jquery"},content:'<hr>\n<p class="text-center"><a href="https://brendaneich.com/2015/06/from-asm-js-to-webassembly/"><img src="/img/compents/jquery/yunhbc.png" alt="yu no have byte code"></a></p>\n\n<h2 id="javascript-https-brendaneich-com-">javascript之父:<a href="https://brendaneich.com/">https://brendaneich.com/</a></h2>\n<p class="text-center"><a href="https://en.wikipedia.org/wiki/Brendan_Eich"><img src="/img/compents/jquery/Brendan.jpg" alt="javascript之父"></a></p>\n\n<p>许多刚开始学习js的开发者将jquery当做javascript本身，这其实是一个很大的误解。</p>\n<p>在我们学习javascript的时候应该区分开这三者的区别：</p>\n<ul>\n<li>javascript</li>\n<li>Web API</li>\n<li>jQuery(或者是其它的框架)</li>\n</ul>\n<p>注意jQuery只是一个库，它并不是javascript本身。这里我们从下面几个方面来对比web API与jquery在使用上的差别。</p>\n<h2 id="-">目录</h2>\n<ul>\n<li><a href="/2015/11/28/jquery-is-not-must/DOM-selector/">选择器</a></li>\n<li><a href="/2015/11/24/jquery-is-not-must/DOM-manipulation/">DOM操作</a></li>\n<li><a href="/2015/11/24/jquery-is-not-must/ajax-request/">Ajax调用</a></li>\n<li><a href="/2015/11/25/jquery-is-not-must/DOM-Event/">事件</a></li>\n<li>辅助函数</li>\n</ul>\n',summary:'<hr>\n<p class="text-center"><a href="https://brendaneich.com/2015/06/from-asm-js-to-webassembly/"><img src="/img/compents/jquery/yunhbc.png" alt="yu no have byte code"></a></p>\n\n<h2 id="javascript-https-brendaneich-com-">javascript之父:<a href="https://brendaneich.com/">https://brendaneich.com/</a></h2>\n<p><p class="text-center">&lt;a href</p>\n'},{meta:{title:"jQuery is not must for us——异步请求",date:"2015-11-24T12:40:32.000Z",tags:"jquery",archives:"pl",id:"3",createTime:"2015-11-24",url:"2015-11-24-jQuery is not must for us——异步请求",strTag:"jquery"},content:'<hr>\n<p>jQuery对象只是对XMLHttpRequest对象进行了封装，真正的异步请求还是由浏览器发起的。</p>\n<ul>\n<li>GET</li>\n<li>POST</li>\n<li>URL Encode</li>\n<li>JSON</li>\n<li>Uploading</li>\n<li>CORS</li>\n<li>JSONP</li>\n</ul>\n<h2 id="get-">GET请求</h2>\n<p>在这里我们向服务器发起一个请求，给服务器传一个id参数然后希望服务器传回该id的用户名。</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">/*常用的jquery get请求方式*/\n$.ajax(&#39;myservice/username&#39;, {\n    data: {\n    id: &#39;unique_id&#39;\n    }\n})\n.then(\nfunction success(name){\n    alert(&quot;用户名是：&quot; + name);\n},\nfunction fail(data, status){\n    alert(&quot;请求失败. Return status of &quot; + status);\n})\n</code></pre>\n<h3 id="-xmlhttprequest-">原生XMLHttpRequest对象实现</h3>\n<pre><code class="lang-javascript">var xhr = new XMLHttpRequest();\nxhr.open(&#39;GET&#39;, encodeURL(&#39;myservice/username?id=unique_id&#39;));\nxhr.onload = function(){\n    if(xhr.status === 200){\n    alert(&quot;用户名是：&quot; + xhr.responseText);\n}\nelse{\n    alert(&#39;Request failed. Return status of &#39; + xhr.status);\n}\n};\nxhr.send();\n</code></pre>\n<h2 id="post">POST</h2>\n<p>post用来向服务器传送数据，这里我们传入一个用户id和新用户名，希望服务器完成对该用户的修改同时会返回修改的内容。</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">var newName = &#39;yangxiaofu&#39;;\n$.ajax(&#39;myservice/username?&#39; + $.param({id: &#39;unique_id&#39;}),\n{    method: &#39;POST&#39;,\n    data: {\n        name: newName\n    }\n})\n.then(\n    function sucess(name){\n    if(name !== newName){\n        alert(&quot;something wrong. Name is now &quot; + name);\n    }\n},\nfunction fail(data, status){\n    alert(&#39;Request failed. Returned status of &#39; + status);\n}\n);\n</code></pre>\n<h3 id="-xmlhttprequest-">原生XMLHttpRequest对象实现</h3>\n<pre><code class="lang-javascript">var newName = &quot;yangxiaofu&quot;,\n    xhr = new XMLHttpRequest();\n\nxhr.open(&quot;POST&quot;,\n    encodeURI(&#39;myservice/username?id=unique_id&#39;));\n    xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencode&#39;);\n    xhr.onload = function(){\n        if(xhr.status === 200 &amp;&amp; xhr.responseText !== newName){\n        alert(&#39;Something went wrong.  Name is now &#39; + xhr.responseText);\n    } else if (xhr.status !== 200) {\n        alert(&#39;Request failed.  Returned status of &#39; + xhr.status);\n    }\n};\nxhr.send(encodeURI(&#39;name=&#39; + newName));\n</code></pre>\n<h3 id="url-encoding">URL Encoding</h3>\n<p>将一个对象转换成URL编码的字符串</p>\n<pre><code class="lang-javascript">$.param({\n    key1: &quot;value1&quot;,\n    &#39;key2&#39;: &quot;value2&quot;\n});\n</code></pre>\n<p>我们可以用encodeURL和encodeURLComponent来实现同样的功能,如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。</p>\n<pre><code class="lang-javascript">function param(obj){\n    var encodedString = &#39;&#39;;\n    for(var prop in object){\n        if(object.hasOwnProperty(prop)){\n            if(encodedString.length &gt; 0){\n                encodedString += &#39;&amp;&#39;;\n            }\n            encodedString += encodeURL(prop + &#39;=&#39; + object[prop]);\n        }\n    }\n    return encodedString;\n}\n</code></pre>\n<h2 id="-">文件上传</h2>\n<p>首先我们应该明确，IE9及之前的版本如果要上传文件的话只能通过form表单，即如下的形式</p>\n<pre><code class="lang-html">&lt;input type=&quot;file&quot;&gt;\n</code></pre>\n<p>通过浏览器提供的文件API ,我们可以通过两种方式上传文件：</p>\n<ul>\n<li>使用multipart/form-data形式的表单</li>\n<li>将文件数据存放在请求体中</li>\n</ul>\n<p>通过下面的表单提交文件</p>\n<pre><code class="lang-html">&lt;input type=&quot;file&quot; id=&quot;test-input&quot;&gt;\n</code></pre>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">var file = $(&#39;#test-input&#39;)[0].files[0],\n    formData = new FormData();\n\nformData.append(&#39;file&#39;, file);\n\n$.ajax(&#39;myserver/uploads&#39;,{\n    method: &#39;POST&#39;,\n    contentType: false,\n    processData: false,\n    data: formData\n});\n\n/*直接提交文件数据*/\n$.ajax(&#39;myserver/uploads&#39;,{\n    method: &#39;POST&#39;,\n    contentType: file.type,\n    processData: false,    /*避免jquery使用URL encode的形式对文件数据进行编码*/\n    data: file\n})\n</code></pre>\n<h3 id="xmlhttprequest">XMLHttpRequest</h3>\n<pre><code class="lang-javascript">/*multipart编码形式*/\nvar formData = new FormData(),\n    file = document.getElementById(&#39;test-input&#39;).files[0],\n    xhr = new XMLHttpRequest();\n\nformData.append(&#39;file&#39;, file);\nxhr.open(&#39;POST&#39;, &#39;myserver/uploads&#39;);\nxhr.send(formData);\n\n/*将文件数据以request body的形式提交*/\nvar file = document.getElementById(&#39;test-input&#39;).files[0],\n    xhr = new XMLHttpRequest();\n\n    xhr.open(&#39;POST&#39;, &#39;myserver/uploads&#39;);\n    xhr.setRequestHeader(&#39;Content-Type&#39;, file.type);\n    xhr.send(file);\n</code></pre>\n',summary:"<hr>\n<p>jQuery对象只是对XMLHttpRequest对象进行了封装，真正的异步请求还是由浏览器发起的。</p>\n<ul>\n<li>GET</li>\n<li>POST</li>\n<li>URL Encode</li>\n<li>JSON</li>\n<li>Uploading</li>\n<li>CORS</li>\n<li>JSONP</li>\n</ul>\n"},{meta:{title:"那些被忽视的字体细节",date:"2015-11-19T10:51:07.000Z",archives:"pl",tags:"css",id:"4",createTime:"2015-11-19",url:"2015-11-19-那些被忽视的字体细节",strTag:"css"},content:'<hr>\n<h2 id="font-">font属性</h2>\n<p>简写形式</p>\n<pre><code class="lang-css">font: font-style font-variant font-weight font-size/line-height font-family|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit;\n</code></pre>\n<p>我们并不需要设置全部的参数，没有设置的浏览器会使用默认的样式(默认样式与浏览器相关)</p>\n<ul>\n<li>font-style</li>\n<li>font-variant</li>\n<li>font-weight</li>\n<li>font-size/line-height</li>\n<li>font-family</li>\n</ul>\n<h3 id="font-style-">font-style: 设置或检索对象中的字体样式</h3>\n<p>normal：\n指定文本字体样式为正常的字体\nitalic：\n指定文本字体样式为斜体。对于没有斜体变量的特殊字体，将应用oblique\noblique：\n指定文本字体样式为倾斜的字体</p>\n<pre><code class="lang-css">font-style：normal | italic | oblique\n</code></pre>\n<pre><code class="lang-html">&lt;b&gt;Hello Xiaofu&lt;/b&gt; \n&lt;b style=&quot;font-style:italic;&quot;&gt;Hello Xiaofu&lt;/b&gt; \n&lt;b style=&quot;font-style:oblique;&quot;&gt;Hello Xiaofu&lt;/b&gt;\n</code></pre>\n<p><b>Hello Xiaofu</b> <b style="font-style:italic;">Hello Xiaofu</b> <b style="font-style:oblique;">Hello Xiaofu</b></p>\n<hr>\n\n<h3 id="font-variant-">font-variant: 设置或检索对象中的文本是否为小型的大写字母</h3>\n<pre><code class="lang-css">font-variant：normal | small-caps\n</code></pre>\n<pre><code class="lang-html">&lt;b style=&quot;font-variant:normal;&quot;&gt;Hello Xiaofu&lt;/b&gt; \n&lt;b style=&quot;font-variant:small-caps;&quot;&gt;Hello Xiaofu&lt;/b&gt; \n&lt;b style=&quot;font-variant:small-caps;&quot;&gt;hello xiaofu&lt;/b&gt;\n</code></pre>\n<p><b style="font-variant:normal;">Hello Xiaofu</b> <b style="font-variant:small-caps;">Hello Xiaofu</b> <b style="font-variant:small-caps;">hello xiaofu</b></p>\n<p>从上面可以看到small-caps属性会将小写字符转换为小型的大写字符，即大写形式，但大小和小写的大小一样.</p>\n<hr>\n\n<h3 id="font-weight-">font-weight: 设置文本的粗细</h3>\n<pre><code class="lang-css">font-weight：normal | bold | bolder | lighter | &lt;integer&gt;\n/*integer的取值范围：100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900*/\n</code></pre>\n<p><span style="font-weight:normal;">hello xiaofu[400]</span> \n<span style="font-weight:bold;">hello xiaofu[700]</span> \n<span style="font-weight:bolder;">hello xiaofu</span> \n<span style="font-weight:lighter;">hello xiaofu</span></p>\n<hr>\n\n<h3 id="font-size-line-height-">font-size/line-height: 设置文本字体大小</h3>\n<pre><code class="lang-css">font-size：&lt;absolute-size&gt; | &lt;relative-size&gt; | &lt;length&gt; | &lt;percentage&gt;\n</code></pre>\n<p>absolute-size：\n根据对象字体进行调节。可选参数值：xx-small | x-small | small | medium | large | x-large | xx-large\nrelative-size：\n相对于父对像中字体尺寸进行相对调节。使用成比例的em单位计算。可选参数值：smaller | larger\nlength：\n用长度值指定文字大小。不允许负值。\npercentage：\n用百分比指定文字大小。其百分比取值是基于父对象中字体的尺寸。不允许负值。</p>\n<p>line-height: 行高，设置行间距离，不可设置负值</p>\n<p>当给块级元素设置行高时，它定义的是元素中基线之间的最小距离而不是最大距离。</p>\n<h3 id="font-family">font-family</h3>\n<p>font-family 规定元素的字体系列\nfont-family 可以指定一系列的字体，如果浏览器不支持第一个字体，则会尝试下一个。也就是说，font-family 属性的值是用于某个元素的字体族名称或一个字体优先级表，浏览器会使用它可识别的第一个值。</p>\n<p>有两种类型的字体系列名称：</p>\n<ul>\n<li>指定的系列名称：具体字体的名称，比如：&quot;times&quot;、&quot;courier&quot;、&quot;arial&quot;。</li>\n<li>通常字体系列名称：比如：&quot;serif&quot;、&quot;sans-serif&quot;、&quot;cursive&quot;、&quot;fantasy&quot;、&quot;monospace&quot;</li>\n</ul>\n<p>这里为什么需要通用字体系列名称，这里是css帮助我们解决字体命名混乱的问题而增加的，因为相似的字体命名可能会不一样，所以我们可以设置通用字体系列，如当我们设置 &quot;serif&quot;字体系列时，浏览器找到Times、Georgia 和 New Century Schoolbook时就会使用其中的一种字体来渲染，因为他们都属于&quot;serif&quot;字体。</p>\n<pre><code class="lang-css">font-family: Georgia, &quot;Times New Roman&quot;, \n             &quot;Microsoft YaHei&quot;, &quot;微软雅黑&quot;, \n             STXihei, &quot;华文细黑&quot;, \n             serif;\n</code></pre>\n<p>字体设置技巧</p>\n<ul>\n<li>1.先设置英文字体，再设置中文字体(英文在中文字体下显示不好，避免中文字体包含的英文字符采用中文字体显示)</li>\n<li>2.中文字体中文名称和英文名称一起指定（避免出现识别不了的情况）</li>\n<li>3.设置一个通用字体结尾，这样当前面指定的特定字体用户计算机上都没装有的情况下，字体可以按照我们期望的字体风格显示.</li>\n</ul>\n',summary:'<hr>\n<h2 id="font-">font属性</h2>\n<p>简写形式</p>\n<pre><code class="lang-css">font: font-style font-variant font-weight font-size/line-height font-family|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit;\n</code></pre>\n<p>我们并不需要设置全部的参数，没有设置的浏览器会使用默认的样式(默认样式与浏览器相关)</p>\n'},{meta:{title:"简单cssHack了解，让ie支持H5、css3",date:"2015-11-13T15:08:09.000Z",archives:"pl",tags:"css",id:"5",createTime:"2015-11-13",url:"2015-11-13-简单cssHack了解，让ie支持H5、css3",strTag:"css"},content:'<hr>\n<h2 id="-css-hack-">为什么需要css Hack?</h2>\n<p>由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，由此带来的的结果是同样的页面在不同的浏览器中显示效果不一样，甚至会出现布局错乱的情况，为了保证各浏览器呈现的效果一致，有时会需要对各个浏览器做单独的处理。（Hack只是进行修补工作，不要当做一个主要的功能。个人觉得参照优雅降级的方式做兼容会比较好，先兼容主流的、版本高的浏览器。然后针对低版本不能兼容的点做相应的处理。)</p>\n<p>[&quot;优雅降级&quot;, &quot;渐进增强&quot;]</p>\n<p>PS: 个人觉得给css3属性增加前缀也是hack的一种</p>\n<p>常用的hack方式</p>\n<ul>\n<li>条件注释方式</li>\n<li>属性前缀方式</li>\n</ul>\n<h2 id="ie-hack-">ie Hack解决方案</h2>\n<h3 id="1-">1.条件注释法</h3>\n<p>类型于编程语言里的条件语句</p>\n<pre><code class="lang-javascript">if(条件满足){\n    显示相应的内容\n}\n</code></pre>\n<pre><code>只在IE下生效\n</code></pre><pre><code class="lang-html">    &lt;!--[if IE]&gt;\n    这段文字只在IE浏览器显示\n    &lt;![endif]--&gt;\n</code></pre>\n<pre><code>只在IE6下生效\n</code></pre><pre><code class="lang-html">    &lt;!--[if IE 6]&gt;\n    这段文字只在IE6浏览器显示\n    &lt;![endif]--&gt;\n</code></pre>\n<pre><code>只在IE6以上版本生效\n</code></pre><pre><code class="lang-html">    &lt;!--[if gte IE 6]&gt;\n    这段文字只在IE6以上(包括)版本IE浏览器显示\n    &lt;![endif]--&gt;\n</code></pre>\n<pre><code>只在IE8上不生效\n</code></pre><pre><code class="lang-html">    &lt;!--[if ! IE 8]&gt;\n    这段文字在非IE8浏览器显示\n    &lt;![endif]--&gt;\n</code></pre>\n<pre><code>非IE浏览器生效\n</code></pre><pre><code class="lang-html">    &lt;!--[if !IE]&gt;\n    这段文字只在非IE浏览器显示\n    &lt;![endif]--&gt;\n</code></pre>\n<h3 id="2-hack-">2.属性前缀法(以下hack在标准模式下使用)</h3>\n<p>ie6-hack</p>\n<p>&quot;_&quot;: 只有ie6能够识别的前缀</p>\n<pre><code class="lang-css">height: 100px;\nwidth: 100px;\n_height: 150px;/*在ie6下得到的宽高为150px，其余浏览器为100px*/\n_width: 150px;\n</code></pre>\n<p>ie7-hack</p>\n<p>&quot;+&quot;: 只有ie7能够识别的前缀</p>\n<pre><code class="lang-css">height: 100px;\nwidth: 100px;\n+height: 150px;/*在ie7下得到的宽高为150px，其余浏览器为100px*/\n+width: 150px;\n</code></pre>\n<p>ie6、7-hack</p>\n<p>&quot;*&quot;: 只有ie6、7能够识别的前缀</p>\n<pre><code class="lang-css">height: 100px;\nwidth: 100px;\n*height: 150px;/*在ie6/7下得到的宽高为150px，其余浏览器为100px*/\n*width: 150px;\n</code></pre>\n<h3 id="-">属性后加数字声明的方式</h3>\n<p>“\\9″     IE6/IE7/IE8/IE9/IE10都生效\n“\\0″     IE8/IE9/IE10都生效，是IE8/9/10的hack\n“\\9\\0″     只对IE9/IE10生效，是IE9/10的hack</p>\n<p>在处理ie的hack时，一般会需要对ie6/7/8做单独的处理，6/7有单独的前缀，8并没有。下面说明如何对8做单独的处理</p>\n<pre><code class="lang-css">height: 100px;\nwidth: 100px;\nheight: 150px\\0;    /*在ie8/9/10可以识别*/\nwidth: 100px\\9\\0;    /*在ie9/10可以识别*/\n</code></pre>\n<p>按如上的设置方式，就对ie8做了单独的处理。</p>\n<h2 id="-ie-h5-ie6-">如何让ie支持H5(包括ie6)</h2>\n<p>下载地址1：<a href="https://github.com/afarkas/html5shiv">https://github.com/afarkas/html5shiv</a>\n下载地址2：<a href="/js/html5shiv.min.js">html5shiv.min.js</a>\n使用方式，在页面头部添加如下代码：</p>\n<pre><code class="lang-html">&lt;!–[if IE]&gt;  \n&lt;script src=”[html5.js]”&gt;&lt;/script&gt;  \n&lt;![endif]–&gt;\n</code></pre>\n<p>这里的src引入的是我们下载的htmlshiv.js文件。</p>\n<h2 id="-ie-css3-">如何让ie支持CSS3属性</h2>\n<p>借助于ie-css3.htc,<a href="/css/ie-css3.htc">点我下载</a></p>\n<p>语法：</p>\n<pre><code class="lang-css">/*给body添加后，body下的子元素都可以使用*/\nbody{\n    behavior: url(ie-css3.htc);\n}\n</code></pre>\n',summary:'<hr>\n<h2 id="-css-hack-">为什么需要css Hack?</h2>\n<p>由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，由此带来的的结果是同样的页面在不同的浏览器中显示效果不一样，甚至会出现布局错乱的情况，为了保证各浏览器呈现的效果一致，有时会需要对各个浏览器做单独的处理。（Hack只是进行修补工作，不要当做一个主要的功能。个人觉得参照优雅降级的方式做兼容会比较好，先兼容主流的、版本高的浏览器。然后针对低版本不能兼容的点做相应的处理。)</p>\n<p>[&quot;优雅降级&quot;, &quot;渐进增强&quot;]</p>\n<p>PS: 个人觉得给css3属性增加前缀也是hack的一种</p>\n<p>常用的hack方式</p>\n<ul>\n<li>条件注释方式</li>\n<li>属性前缀方式</li>\n</ul>\n'},{meta:{title:"静态服务器搭建",date:"2015-11-17T14:01:16.000Z",tags:["php","tool"],archives:"pl",id:"6",createTime:"2015-11-17",url:"2015-11-17-静态服务器搭建",strTag:"php、tool"},content:'<hr>\n<style>\n    img{\n        width: 50%;\n    }\n</style>\n\n<ol>\n<li><a href="#1-xampp搭建静态服务器">1.xampp搭建静态服务器</a></li>\n<li><a href="#2-SublimeServer">2.sublime插件-SublimeServer</a></li>\n</ol>\n<h2 id="1-xampp-">1.xampp搭建静态服务器</h2>\n<p>XAMPP是完全免费且易于安装的Apache发行版，其中包含MariaDB、PHP和Perl。我们可以使用它来作为一个简单的静态服务器。</p>\n<p>官网地址：<a href="https://www.apachefriends.org/zh_cn/index.html">https://www.apachefriends.org/zh_cn/index.html</a></p>\n<p>到官网下载对应的版本安装即可</p>\n<p>使用方式：</p>\n<p>1.启动界面</p>\n<p><img src="/img/xampp/xampp01.png" alt="启动界面"></p>\n<p>2.启动服务器</p>\n<p><img src="/img/xampp/xampp02.png" alt="启动服务器"></p>\n<p>3.启动状态</p>\n<p><img src="/img/xampp/xampp03.png" alt="已启动服务器"></p>\n<p>4.静态文件目录</p>\n<p><img src="/img/xampp/xampp04.png" alt="静态文件目录"></p>\n<p><img src="/img/xampp/xampp05.png" alt="静态文件目录"></p>\n<p>将我们写好的静态页面放到htdocs文件夹下就可以通过如下的方式打开我们的页面</p>\n<p>格式：</p>\n<p><a href="http://localhost/">http://localhost/</a> + 静态文件路径(路径以htdocs为根目录，如htdocs下有一个jikexueyuan.html文件，那么可以通过<a href="http://localhost/jikexueyuan.html访问">http://localhost/jikexueyuan.html访问</a>)\n<a href="http://localhost/applications.html">http://localhost/applications.html</a></p>\n<p>如果上述方式无法打开，可通过ip访问</p>\n<p>mac: 在命令行输入 ifconfig\nwindow: 在命令行输入 ipconfig</p>\n<p><img src="/img/xampp/xampp06.png" alt="ip"></p>\n<p><a href="http://你的ip地址/">http://你的ip地址/</a> + 静态文件路径\nhttp:192.168.1.103/jike/jikexueyuan.html</p>\n<h2 id="2-sublimeserver">2.SublimeServer</h2>\n<p>----<a href="http://learningcn.com/SublimeServer/">官网地址</a></p>\n<ul>\n<li>package control安装</li>\n<li>手动安装，将SublimeServer文件下到sublime package文件夹即可</li>\n</ul>\n<p>如何使用：</p>\n<ul>\n<li>安装插件</li>\n<li>Tools-&gt;SublimeServer-&gt;Start SublimeServer</li>\n<li><a href="http://localhost:8080/+文件路径(在sublime">http://localhost:8080/+文件路径(在sublime</a> folder中打开的项目，8080为默认端口，如有改动则更改为相应的端口)</li>\n</ul>\n<p>补充说明：</p>\n<p>Hbuilder、webstorm自带有服务器设置</p>\n',summary:'<hr>\n<style>\n    img{\n        width: 50%;\n    }\n</style>\n\n<ol>\n<li><a href="#1-xampp搭建静态服务器">1.xampp搭建静态服务器</a></li>\n<li><a href="#2-SublimeServer">2.sublime插件-SublimeServer</a></li>\n</ol>\n<h2 id="1-xampp-">1.xampp搭建静态服务器</h2>\n<p>XAMPP是完全免费且易于安装的Apache发行版，其中包含MariaDB、PHP和Perl。我们可以使用它来作为一个简单的静态服务器。</p>\n<p>官网地址：<a href="https://www.apachefriends.org/zh_cn/index.html">https://www.apachefriends.org/zh_cn/index.html</a></p>\n<p>到官网下载对应的版本安装即可</p>\n<p>使用方式：</p>\n<p>1.启动界面</p>\n<p><img src="/img/xampp/xampp01.png" alt="启动界面"></p>\n'},{meta:{title:"图片延迟加载简单实现",date:"2015-11-20T16:21:55.000Z",tags:"js",archives:"pl",id:"7",createTime:"2015-11-21",url:"2015-11-21-图片延迟加载简单实现",strTag:"js"},content:'<hr>\n<style>img {opacity: 1;transition: opacity 0.2s;max-width: 100%;}img[data-src] {opacity: 0;}</style>\n\n<p>图片往往是造成网页加载缓慢的原因，通过延迟图片的加载可以提高用户体验，优先加载重要的内容。</p>\n<p><img data-src="/img/tree.png" alt="tree"></p>\n<p><img data-src="/img/christina.jpg" alt="christina"></p>\n<h2 id="1-data-src-img-src-">1.使用data-src属性代替img的src属性</h2>\n<pre><code class="lang-html">&lt;div class=&quot;wrapper&quot;&gt;\n        &lt;img data-src=&quot;./img/lazy.jpg&quot; alt=&quot;lazy.jpg&quot;&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-css">/*先将待加载图片隐藏，加载完成后显示*/\nimg {\n        opacity: 1;\n        transition: opacity 0.2s;\n    }\n\n    img[data-src] {\n        opacity: 0;\n    }\n</code></pre>\n<p>说明：img标签并不会将图片嵌入到网页中，而是提供一个占位符即给图片提供一个显示的空间。图片的显示需要浏览器根据src属性来加载。所以上述方式并不会加载图片。</p>\n<h2 id="2-html-js-img-data-src-src-">2.当html文档加载完成后通过js将img的data-src属性转换为src,从而加载图片</h2>\n<pre><code class="lang-javascript">/*原生js实现*/\n[].forEach.call(document.querySelectorAll(&#39;img[data-src]&#39;), function(img) {\n        img.setAttribute(&#39;src&#39;, img.getAttribute(&#39;data-src&#39;));\n        img.onload = function() {\n            /*图片加载完成后data-src属性就可以去掉了*/\n            img.removeAttribute(&#39;data-src&#39;);\n        };\n    });\n/*jQuery实现*/\n$(&#39;img[data-src]&#39;).each(function(){\n    var $img = $(this);\n    $img.attr(&#39;src&#39;, $img.attr(&#39;data-src&#39;));\n    $img.load(function(){\n        $img.removeAttr(&#39;data-src&#39;);\n    })\n});\n</code></pre>\n<p>说明：遍历所有包含data-src属性的img元素然后将data-src属性转换为src属性</p>\n<script>\n    [].forEach.call(document.querySelectorAll(\'img[data-src]\'), function(img) {\n        img.setAttribute(\'src\', img.getAttribute(\'data-src\'));\n        img.onload = function() {\n            /*图片加载完成后data-src属性就可以去掉了*/\n            img.removeAttribute(\'data-src\');\n        };\n    });\n<\/script>\n',summary:'<hr>\n<style>img {opacity: 1;transition: opacity 0.2s;max-width: 100%;}img[data-src] {opacity: 0;}</style>\n\n<p>图片往往是造成网页加载缓慢的原因，通过延迟图片的加载可以提高用户体验，优先加载重要的内容。</p>\n<p><img data-src="/img/tree.png" alt="tree"></p>\n'},{meta:{title:"前端开发环境搭建",date:"2015-11-02T17:27:13.000Z",archives:"pl",tags:["web","tool"],id:"8",createTime:"2015-11-03",url:"2015-11-03-前端开发环境搭建",strTag:"web、tool"},content:'<hr>\n<h2 id="sublime-text-">sublime text安装（神级代码编辑器）</h2>\n<h3 id="-http-www-sublimetext-com-"><a href="http://www.sublimetext.com/">官网地址</a></h3>\n<p><img src="/img/sublime-bg.jpg"></p>\n<p>选择与系统对应的版本下载即可，推荐安装sublime text3.</p>\n<h3 id="-sublime-text-3-">以下是sublime text 3下载地址:</h3>\n<ul>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083.dmg">Mac-OS X (10.7 or later is required)</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083%20Setup.exe">Windows</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083%20x64%20Setup.exe">Windows 64 bit</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/sublime-text_build-3083_amd64.deb">Ubuntu 64 bit</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/sublime-text_build-3083_i386.deb">Ubuntu 32 bit</a></li>\n</ul>\n<h2 id="sublime-text-">sublime text插件安装</h2>\n<h3 id="package-control">Package Control</h3>\n<p>通过Package Control ，我们可以管理和安装sublime text其它相应的插件。</p>\n<h3 id="-">安装方式</h3>\n<p>通过 ctrl+` 或是通过 View -&gt; show console的方式打开sublime text编辑器的控制台，然后再控制台中输入对应的python代码，代码如下所示（若出现运行出错的情况请注意标点符号是否为英文的标点符号）。</p>\n<p class="text-important">安装完package control后请重启sublime</p>\n\n<h4 id="1-sublime-text3">1.sublime text3</h4>\n<p style="background:#272822;color:#ffffff;padding:10px;">import urllib.request,os,hashlib; h = &#39;2915d1851351e5ee549c20394736b442&#39; + &#39;8bc59f460fa1548d1514676163dafc88&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;<a href="http://packagecontrol.io/">http://packagecontrol.io/</a>&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</p>\n\n<p class="text-important">如出现报错，可到package control官网拷贝对应安装代码：<a href="https://packagecontrol.io/installation#st3">https://packagecontrol.io/installation#st3</a></p>\n\n<h4 id="2-sublime-text2">2.sublime text2</h4>\n<p style="background:#272822;color:#ffffff;padding:10px;">import urllib2,os,hashlib; h = &#39;2915d1851351e5ee549c20394736b442&#39; + &#39;8bc59f460fa1548d1514676163dafc88&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &#39;<a href="http://packagecontrol.io/">http://packagecontrol.io/</a>&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#39;wb&#39; ).write(by) if dh == h else None; print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h) if dh != h else &#39;Please restart Sublime Text to finish installation&#39;)</p>\n\n<h2 id="-">手动安装</h2>\n<ul>\n<li>1.点击Preferences &gt; Browse Packages</li>\n<li>2.上面的步骤会打开一个文件夹，在其中我们找到Installed Packages文件夹（如果没有，则在父级目录中查找）</li>\n<li>3.下载Control.sublime-package（<a href="https://packagecontrol.io/Package%20Control.sublime-package">下载地址</a>）包然后拷贝到 Installed Packages文件夹</li>\n</ul>\n<p>通过上述方式安装好package control插件好重启sublime package control就可以使用了。</p>\n<h3 id="emment-">Emment安装</h3>\n<p>Emment的功能包括代码补全、代码初始化以及快速编码等功能。</p>\n<ul>\n<li>使用快捷键ctrl + shift + p(mac:command + shift + p)</li>\n<li><a href="http://jingyan.baidu.com/article/ca00d56c76d0fae99eebcfdf.html">安装教程：sb2/sb3一样</a></li>\n</ul>\n<p>测试安装是否成功：</p>\n<p>新建一个html文件，输入 html:5,然后按下tab键，这是我们就会得到如下的html结构：</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;·\n&lt;body&gt;\n\n&lt;/body&gt;    \n&lt;/html&gt;\n</code></pre>\n<p class="text-important">如果不成功查看一下文件是否保存，如未保存请先保存。(注：如我新建一个jikexueyuan的html文件，那么应该保存为: jikexueyuan.html文件)</p>\n\n<p>检查插件是否已安装</p>\n<p><img src="/img/package-control.png" alt="package control安装列表">\n最后一级菜单中显示的即已安装的插件列表。(如果没有说明安装不成功，比如我这里第一行是Emment,说明我的Emment插件安装好了，如果你的没有说明没装好)</p>\n<p>这样就代表插件安装成功了,开启极客之旅吧。</p>\n<p>想体验更多插件可到<a href="https://packagecontrol.io/寻找">https://packagecontrol.io/寻找</a></p>\n<h2 id="sublime-">sublime 破解序列号</h2>\n<p>----- BEGIN LICENSE ----- \nAndrew Weber \nSingle User License \nEA7E-855605 \n813A03DD 5E4AD9E6 6C0EEB94 BC99798F \n942194A6 02396E98 E62C9979 4BB979FE \n91424C9D A45400BF F6747D88 2FB88078 \n90F5CC94 1CDC92DC 8457107A F151657B \n1D22E383 A997F016 42397640 33F41CFC \nE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D \n5CDB7036 E56DE1C0 EFCC0840 650CD3A6 \nB98FC99C 8FAC73EE D2B95564 DF450523 \n------ END LICENSE ------ </p>\n<h2 id="node-">node安装</h2>\n<p>官网下载地址：</p>\n<p>英文：<a href="https://nodejs.org/">https://nodejs.org/</a>\n中文：<a href="http://nodejs.cn/">http://nodejs.cn/</a></p>\n<p>建议安装v4.2.2版本</p>\n<h2 id="sublime-node-html-css-js-prettify-">Sublime美化插件需node支持(html/css/js prettify)</h2>\n<p>1 .打开node_path设置路径(set node path)</p>\n<p><img src="/img/xampp/node_path.jpg" alt="node_path设置路径"></p>\n<p>2 .node安装路径(以你自己的安装路径为准，这里我的安装路径是E:\\Nodejs\\,注意斜杠的方向)</p>\n<p><img src="/img/xampp/node_path02.png" alt="node安装路径"></p>\n<p>3 .路径替换(如果是其它版本的系统请更改相应的路径)</p>\n<p>默认路径\n<img src="/img/xampp/node_path01.jpg" alt="路径替换"></p>\n<p>替换为(windows版)\n<img src="/img/xampp/node_03.jpg" alt="路径替换"></p>\n<p>这样的话美化插件就可以用了,鼠标右键html/css/js prettify——&gt;prettify code或者使用快捷键Ctrl+h即触发美化功能。</p>\n',summary:'<hr>\n<h2 id="sublime-text-">sublime text安装（神级代码编辑器）</h2>\n<h3 id="-http-www-sublimetext-com-"><a href="http://www.sublimetext.com/">官网地址</a></h3>\n<p><img src="/img/sublime-bg.jpg"></p>\n<p>选择与系统对应的版本下载即可，推荐安装sublime text3.</p>\n<h3 id="-sublime-text-3-">以下是sublime text 3下载地址:</h3>\n<ul>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083.dmg">Mac-OS X (10.7 or later is required)</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083%20Setup.exe">Windows</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083%20x64%20Setup.exe">Windows 64 bit</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/sublime-text_build-3083_amd64.deb">Ubuntu 64 bit</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/sublime-text_build-3083_i386.deb">Ubuntu 32 bit</a></li>\n</ul>\n'},{meta:{title:"前端代码规范",date:"2015-11-03T09:58:55.000Z",archives:"pl",tags:["web","tool"],id:"9",createTime:"2015-11-03",url:"2015-11-03-前端代码规范",strTag:"web、tool"},content:'<hr>\n<h1 id="-">目录</h1>\n<ul>\n<li><a href="#HTML编码规范">HTML编码规范</a></li>\n<li><a href="#CSS编码规范">CSS编码规范</a></li>\n<li><a href="#javascript编码规范">javascript编码规范</a></li>\n</ul>\n<hr />\n\n<h1 id="html-">HTML编码规范</h1>\n<h2 id="-">语法</h2>\n<ul>\n<li>用4个空格来代替制表符（tab）</li>\n<li>嵌套元素应当缩进一次（即4个空格）。</li>\n<li>对于属性的定义，确保全部使用双引号，不要使用单引号。</li>\n<li>H5页面不需要在自闭合（self-closing）元素的尾部添加斜线(注：xhtml 1.0所有标签尾部都要添加斜线)。</li>\n<li>不要省略可选的结束标签（closing tag）</li>\n</ul>\n<pre><code>/*自闭合标签*/\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n        &lt;head&gt;\n        &lt;title&gt;Page title&lt;/title&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n        &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot;&gt;\n        &lt;!-- xhtml:1.0 img标签尾部需添加斜线\n        &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot;/&gt;\n        --&gt;\n        &lt;h1 class=&quot;hello-world&quot;&gt;Hello, world!&lt;/h1&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n</code></pre><pre><code class="lang-html">/*可选闭合标签,这里的&lt;/li&gt;省略了*/\n&lt;ul&gt;\n    &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;\n    &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;\n&lt;/ul&gt;\n/*完整的代码*/\n&lt;ul&gt;\n    &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h2 id="-">文档类型声明</h2>\n<p>&lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。声明之后可以确保浏览器正确的解析我们编写额web页面。</p>\n<p>HTML5只需要按如下的方式声明文档类型</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html&gt;\n</code></pre>\n<p>HTML 4.01有三种dtd</p>\n<p>HTML 4.01 Strict\n该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;\n</code></pre>\n<p>HTML 4.01 Transitional\n该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; \n&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\n</code></pre>\n<p>HTML 4.01 Frameset\n该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; \n&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;\n</code></pre>\n<p>XHTML 1.0 Strict\n该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; \n&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;\n</code></pre>\n<p>XHTML 1.0 Transitional\n该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n</code></pre>\n<p>XHTML 1.0 Frameset\n该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; \n&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;\n</code></pre>\n<p>从上可以看到H5只有一种声明类型，html 4.01和xhtml 1.0都有三种什么类型，一般情况下我们只需要什么H5 doctype头部即可，如果需要考虑兼容低版本浏览器（ie6/7/8)可使用过渡类型的头部。</p>\n<p><a href="http://www.w3school.com.cn/tags/html_ref_dtd.asp">过渡类型、严格模式、框架集的差别</a></p>\n<pre><code class="lang-html">&lt;!--HTML5--&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<pre><code class="lang-html">&lt;!--过渡类型--&gt;\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id="-">字符编码</h2>\n<p>通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。这样做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与文档编码一致（一般采用 UTF-8 编码）。</p>\n<pre><code class="lang-html">&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;/head&gt;\n</code></pre>\n<h2 id="-">使用正确的标签，避免标签冗余</h2>\n<ul>\n<li>尽量遵循 HTML 标准和语义，但是不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度。（尤其勿滥用div标签）</li>\n<li>避免标签冗余</li>\n</ul>\n<pre><code class="lang-html">    &lt;!-- 不规范的写法 --&gt;\n    &lt;span class=&quot;avatar&quot;&gt;\n            &lt;img src=&quot;...&quot;&gt;\n    &lt;/span&gt;\n    &lt;!-- 规范的写法 --&gt;\n    &lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt;\n</code></pre>\n<h2 id="-">标签属性书写顺序</h2>\n<p>HTML 属性应当按照以下给出的顺序依次排列，确保代码的易读性。</p>\n<ul>\n<li>class</li>\n<li>id, name</li>\n<li>data-*</li>\n<li>src, for, type, href</li>\n<li>title, alt</li>\n<li>aria-*, role</li>\n</ul>\n<p>class 用于标识高度可复用组件，因此应该排在首位。id 用于标识具体组件，一般提供给JS使用。        </p>\n<hr />        \n\n<h1 id="css-">CSS编码规范</h1>\n<h2 id="-">语法</h2>\n<ul>\n<li>用四个空格来代替制表符（tab）</li>\n<li>为选择器分组时，将单独的选择器单独放在一行。</li>\n<li>为了代码的易读性，在每个声明块的左花括号前添加一个空格。</li>\n<li>声明块的右花括号应当单独成行。</li>\n<li>每条声明语句的 : 后应该插入一个空格。</li>\n<li>每条声明都应该独占一行。</li>\n<li>所有声明语句都应当以分号结尾。</li>\n<li>空格的使用<ul>\n<li>选择器与 { 之前要有空格</li>\n<li>属性名的 : 后要有空格</li>\n<li>属性名的 : 前不加空格 </li>\n</ul>\n</li>\n<li>十六进制值应该全部小写，例如，#fff。在扫描文档时，小写字符易于分辨，因为他们的形式更易于区分。</li>\n<li>尽量使用简写形式的十六进制值，例如，用 #fff 代替 #ffffff。</li>\n<li>为选择器中的属性添加双引号，例如，input[type=&quot;text&quot;]。只有在某些情况下是可选的，但是，为了代码的一致性，建议都加上双引号。</li>\n<li>避免为 0 值指定单位，例如，用 margin: 0; 代替 margin: 0px;。</li>\n</ul>\n<pre><code class="lang-css">/* 不规范 CSS */\n.selector, .selector-second, .selector[type=text] {\n    padding:15px;\n    margin:0px 0px 15px;\n    background-color:rgba(0, 0, 0, 0.5);\n    box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF;\n}\n\n/* 规范 CSS */\n.selector,\n.selector-second,\n.selector[type=&quot;text&quot;] {\n    padding: 15px;\n    margin-bottom: 15px;\n    background-color: rgba(0, 0, 0, 0.5);\n    box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;\n}\n</code></pre>\n<h2 id="-">属性书写顺序</h2>\n<ul>\n<li>Position</li>\n<li>Box model</li>\n<li>Typographic</li>\n<li>Visual</li>\n</ul>\n<pre><code class="lang-css">.declaration-order {\n    /* 定位相关 */\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 100;\n\n    /* 盒模型相关 */\n    display: block;\n    width: 100px;\n    height: 100px;\n\n    /* 文本属性、排版相关 */\n    font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;\n    line-height: 1.5;\n    color: #333;\n    text-align: center;\n\n    /* Visual */\n    background-color: #f5f5f5;\n    border: 1px solid #e5e5e5;\n    border-radius: 3px;\n}\n</code></pre>\n<h2 id="class-id-">class和id的命名</h2>\n<ul>\n<li>class名称中只能出现小写字符和破折号（不是下划线，也不是驼峰命名法）。破折号应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。</li>\n<li>id的命名使用驼峰命名法（例如：#newUserName）</li>\n<li>避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。</li>\n<li>class和id的名称应当尽可能短，并且意义明确。</li>\n<li>使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（例如左右等位置信息，left-bar、right-bar）的名称。</li>\n<li>基于最近的父class或基本class作为新class的前缀。</li>\n</ul>\n<pre><code class="lang-css">    /* 不规范的写法 */\n    .m { ... }\n    .red { ... }\n    .header { ... }\n\n    /* 规范的写法 */\n    .menu { ... }\n    .important { ... }\n    .menu-header { ... }\n</code></pre>\n<h2 id="-">选择器</h2>\n<ul>\n<li>对于通用元素使用class这样利于渲染性能的优化。</li>\n<li>对于经常出现的组件，避免使用属性选择器（例如，[class^=&quot;...&quot;]）。浏览器的性能会受到这些因素的影响。</li>\n<li>选择器层级建议不多余3层。</li>\n<li>只有在必要的时候才将class限制在最近的父元素内（也就是后代选择器）（例如，不使用带前缀的class时 -- 前缀类似于命名空间）。</li>\n</ul>\n<h2 id="icon">icon</h2>\n<ul>\n<li>使用雪碧图</li>\n<li>使用自定义字体</li>\n</ul>\n<h1 id="-">编辑器配置</h1>\n<ul>\n<li>用四个空格代替制表符（soft-tab 即用空格代表 tab 符）。</li>\n<li>设置文件编码为 UTF-8。</li>\n</ul>\n<hr />\n\n<h1 id="javascript-">javascript编码规范</h1>\n<h2 id="-">命名规范</h2>\n<h3 id="-">变量命名</h3>\n<p>变量命名使用有意义的单词和驼峰式命名。\n临时变量简写：str,num,bol,fun,arr。\n循环变量简写：i , j , k。</p>\n<h3 id="-">全局变量及常量规范</h3>\n<p>全局变量使用g作为前缀，如gUserName , gLoginTime。\n常量全部字母都大写，如： PI , COPYRIGHT。注:常量可存在于函数中，也可存在于全局。</p>\n<h3 id="-">函数命名规范</h3>\n<ol>\n<li>统一使用动词或动词加名词的形式。如getVersion() , submitForm()。</li>\n<li>涉及返回逻辑值的函数可以使用is , has 等表示逻辑的词语代替动词。 内部函数前加上 ‘_‘前缀。</li>\n<li>可选参数以 ‘opt’ 开头.</li>\n</ol>\n<h3 id="-">类的命名</h3>\n<ul>\n<li>类名首字母大写。</li>\n<li>属性名为具有一定意义的名词。私有属性加 “_“。</li>\n<li>方法名为有意义的动词[+名词]，首字母小写。私有方法加 ‘_”.</li>\n</ul>\n<h3 id="-">其它</h3>\n<ul>\n<li>命名无特殊情况，请使用英语表示。切勿用汉语拼音。</li>\n<li>变量名应该明确必要，避免容易混淆的缩写。</li>\n<li>应该避免双重否定意义的变量，例如：bIsNotError, bIsNotFound，不可取。</li>\n<li>变量的生命周期保持可用范围最小。</li>\n<li>循环变量在循环中定义。</li>\n<li>避免在条件中执行语句。</li>\n<li>重复使用的具有相同意义的数字，用变量代替。</li>\n</ul>\n<p>注：window对象中只可以定义全局变量，常量，类。</p>\n<h2 id="-">命名空间</h2>\n<p>为避免全局命名的冲突,在全局作用域上使用一个与项目或文件相关的名字来划分作用域空间.</p>\n<pre><code class="lang-javascript">    var calcultor = {};\n    calcultor.add = function() {\n    ...\n    };\n    calcultor.sub = function() {\n    ...\n    };\n</code></pre>\n<h2 id="-">类型</h2>\n<ul>\n<li>原始值：按值传递 string/number/boolean/null/undefined 注:null和undefine是不同的.</li>\n<li>复杂类型：按引用传递 object/array/function</li>\n</ul>\n<h2 id="-">对象</h2>\n<p>使用字面值创建对象</p>\n<pre><code class="lang-javascript">/*bad*/\nvar item = new Object();\n/*good*/\nvar item = {};\n</code></pre>\n<p>不要使用保留字作为键</p>\n<pre><code class="lang-javascript">    /*bad*/\n    var superman = {\n        class:&#39;superhero&#39;,\n        default:{ clark:&#39;kent&#39; },\n        private: true\n    }\n    /*good*/\n    var superman = {\n        klass: &#39;superhero&#39;,\n        defaults:{ clark: &#39;kent&#39; },\n        hidden: true\n    };\n</code></pre>\n<h2 id="-">数组</h2>\n<p>使用字面量创建数组</p>\n<pre><code class="lang-javascript">    /*bad*/\n    var items = new Array();\n    /*good*/\n    var items = [];\n</code></pre>\n<p>数组长度不知时，使用push添加元素</p>\n<pre><code class="lang-javascript">    var someStack = [];\n    /*bad*/\n    someStack[someStack.length] = &#39;abcdefg&#39;;\n    /*good*/\n    someStack.push(&#39;abcdefg&#39;);\n    /*使用slice拷贝数组*/\n    var len = items.length,\n      itemsCopy = [],\n      i;\n    /*bad*/\n    for(i = 0; i &lt; len; i++){\n        itemsCopy[i] = items[i];\n    }\n    /*good*/\n    itemsCopy = items.slice();\n</code></pre>\n<h2 id="-">函数</h2>\n<p>不要在一个非函数块里面声明一个函数，应该把那个函数赋给一个变 量。浏览器让你这么做，但是解析的情况是不同的。</p>\n<pre><code class="lang-javascript">    /*bad*/\n    if(currentUser){\n        function test(){\n            console.log(&#39;Nope.&#39;);\n        }\n    }\n    /*good*/\n    if(currentUser){\n        var test = function test(){\n            console.log(&#39;Yup.&#39;);\n        };\n    }\n</code></pre>\n<p>请勿把参数命名为 arguments,这会对函数内的 arguments对象产生影响。</p>\n<pre><code class="lang-javascript">    /*bad*/\n    function nope(name, options, arguments){\n\n    }\n    /*good*/\n    function yup(name, options, args){\n\n    }\n</code></pre>\n<h2 id="-">属性</h2>\n<p>当使用变量访问属性时使用中括号。</p>\n<pre><code class="lang-javascript">    var luke = {\n        jedi: true,\n        age: 28\n    };\n    function getProp(prop){\n        return luke[prop];\n    }\n    var isJedi = getProp(&#39;jedi&#39;);\n</code></pre>\n<h2 id="-">条件表达式和等号</h2>\n<p>适当使用===和！==以及==和！=。</p>\n<p>条件表达式的强类型转换规则：</p>\n<ul>\n<li>对象被计算为true</li>\n<li>Undefined被计算为false</li>\n<li>Null被计算为false</li>\n<li>布尔值被计算为布尔的值</li>\n<li>数字如果是+0, -0,NaN被计算为false</li>\n<li>字符如果是空字符串，则被计算为false，否则为true</li>\n<li>字符串如果是空字符串，则被计算为false，否则为true</li>\n</ul>\n<h2 id="-">事件</h2>\n<p>当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据 里而不用找出并更新那个事件的事件处理器。</p>\n<pre><code class="lang-javascript">    /*bad*/\n    $(this).trigger(&#39;listingUpdated&#39;, listing.id);\n    $(this).on(&#39;listingUpdated&#39;, function(e,listingId){\n        /*do something with listingId*/\n    });\n    /*good*/\n    $(this).trigger(&#39;listingUpdated&#39;, {listingId: listing.id});\n    $(this).on(&#39;listingUpdated&#39;, function(e, data){\n    /*do something with data.listingId*/\n    });\n</code></pre>\n',
summary:'<hr>\n<h1 id="-">目录</h1>\n<ul>\n<li><a href="#HTML编码规范">HTML编码规范</a></li>\n<li><a href="#CSS编码规范">CSS编码规范</a></li>\n<li><a href="#javascript编码规范">javascript编码规范</a></li>\n</ul>\n<hr />\n\n<h1 id="html-">HTML编码规范</h1>\n<h2 id="-">语法</h2>\n<ul>\n<li>用4个空格来代替制表符（tab）</li>\n<li>嵌套元素应当缩进一次（即4个空格）。</li>\n<li>对于属性的定义，确保全部使用双引号，不要使用单引号。</li>\n<li>H5页面不需要在自闭合（self-closing）元素的尾部添加斜线(注：xhtml 1.0所有标签尾部都要添加斜线)。</li>\n<li>不要省略可选的结束标签（closing tag）</li>\n</ul>\n'},{meta:{title:"使用inline-block与浮动前需要了解这些",date:"2015-11-06T15:06:36.000Z",archives:"pl",tags:"css",id:"10",createTime:"2015-11-06",url:"2015-11-06-使用inline-block与浮动前需要了解这些",strTag:"css"},content:'<hr>\n<p>HTML标签分为块级元素和行内元素，块级元素会独占一行。</p>\n<p>常见的块级元素：</p>\n<pre><code class="lang-css">h1,h2,h3,h4,h5,\ndiv,p,form,hr,menu,ul,dl,ol,pre,table,address,blockquote\n</code></pre>\n<p>常见的内联元素</p>\n<pre><code class="lang-css">a,abbr,acronym,br,cite,code,em,i,\nimg,input,label,select,small,span,sub,sup,textarea\n</code></pre>\n<p>块级元素：块级元素独占一行，可以设定元素的宽（width）、高（height）和内外边距，块级元素一般是其他元素的容器，可容纳块级元素和行内元素。常见的块级元素有div, p ,h1~h6等。</p>\n<p>行内元素：行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的高度一般由元素内部的字体大小决定，宽度由内容的长度控制。常见的行内元素有a, em ,strong等。（img标签虽然是行内元素，但自带宽高属性，即可以设置宽高)</p>\n<p>给行内元素和块级元素加上display:inline-block;后会将元素转换为行内块元素，即不独占一行而且可以按盒子模型进行布局。</p>\n<h2 id="-inline-">行内元素（inline)</h2>\n<div class="margin-auto">\n    <span style="background:red;">行内元素</span>  <span style="background:green;">行内元素</span>  <span style="background:blue;">行内元素</span>\n    <hr>\n</div>\n\n<h2 id="-inline-block-">行内块元素（inline-block)</h2>\n<div class="margin-auto">\n    <span style="background:red;display:inline-block;">行内元素</span>  <span style="background:green;display:inline-block;">行内元素</span>  <span style="background:blue;display:inline-block;">行内元素</span>\n    <hr>\n</div>\n\n<p>从上面可以看到内联元素之间都会产生空格，该空格的大小受设置字体大小的影响(注：当html标签间有空格或换行的情况,如果没有则不会产生空格的)</p>\n<h2 id="-inline-block-">行内块元素（inline-block)并排空格解决方式</h2>\n<ul>\n<li>margin负值</li>\n<li>font-size: 0;</li>\n<li>浮动替代方式</li>\n</ul>\n<pre><code class="lang-css">margin-left: -5px;\n</code></pre>\n<div class="margin-auto">\n    <span style="background:red;display:inline-block;">行内元素</span>  <span style="background:green;display:inline-block;margin-left:-5px;">行内元素</span>  <span style="background:blue;display:inline-block;margin-left:-5px;">行内元素</span>\n    <hr>\n</div>\n\n<pre><code class="lang-css">/*这里给父容器设置字体大小为0，有的浏览器不兼容,此时可以给子元素单独设字体大小*/\nfont-size: 0;\n</code></pre>\n<div class="margin-auto" style="font-size: 0;">\n    <span style="background:red;display:inline-block;font-size:14px;">行内元素</span>  <span style="background:green;display:inline-block;font-size:14px;">行内元素</span>  <span style="background:blue;display:inline-block;font-size:14px;">行内元素</span>\n    <hr style="font-size: 14px;">\n</div>\n\n<pre><code class="lang-css">float: left;\n</code></pre>\n<div class="margin-auto" style="float: left;"><div><span style="background:red;display:inline-block;font-size:14px;float: left;">行内元素</span>  <span style="background:green;display:inline-block;font-size:14px;float: left;">行内元素</span>  <span style="background:blue;display:inline-block;font-size:14px;float: left;">行内元素</span></div>\n    <hr>\n</div>\n\n\n<h2 id="-">清除浮动</h2>\n<pre><code class="lang-css">float: left;/*设置浮动*/\nclear: both;/*清除浮动*/\n</code></pre>\n<p>浮动会导致父层塌陷，所以需要清除浮动来将父层撑开。</p>\n<ul>\n<li>父级设置浮动</li>\n<li>带clear属性的空元素</li>\n<li>父级设置overflow: hidden;或overflow: auto;在IE6中还需要触发hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。</li>\n<li>使用css的:after伪元素。给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</li>\n</ul>\n<pre><code class="lang-css">.clearfix:after{\n  content: &quot;&quot;; \n  display: block; \n  height: 0; \n  clear: both; \n  visibility: hidden;  \n  }\n\n.clearfix {\n  /* 触发 hasLayout ie6/7*/ \n  zoom: 1; \n  }\n</code></pre>\n<p>示例：</p>\n<pre><code class="lang-html">&lt;div class=&quot;content&quot;&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>清除方式一：</p>\n<pre><code class="lang-html">&lt;div class=&quot;content&quot; style=&quot;float:left;&quot;&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>该种方式父容器自身会浮动，所以需要注意父容器浮动所带来的影响</p>\n<p>清除方式二：</p>\n<pre><code class="lang-html">&lt;div class=&quot;content&quot;&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>清除方式三：</p>\n<pre><code class="lang-html">&lt;div class=&quot;content&quot; style=&quot;overflow:hidden;zoom:1;&quot;&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>清除方式四：</p>\n<pre><code class="lang-html">&lt;div class=&quot;content clearfix&quot;&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n',summary:'<hr>\n<p>HTML标签分为块级元素和行内元素，块级元素会独占一行。</p>\n<p>常见的块级元素：</p>\n<pre><code class="lang-css">h1,h2,h3,h4,h5,\ndiv,p,form,hr,menu,ul,dl,ol,pre,table,address,blockquote\n</code></pre>\n<p>常见的内联元素</p>\n<pre><code class="lang-css">a,abbr,acronym,br,cite,code,em,i,\nimg,input,label,select,small,span,sub,sup,textarea\n</code></pre>\n<p>块级元素：块级元素独占一行，可以设定元素的宽（width）、高（height）和内外边距，块级元素一般是其他元素的容器，可容纳块级元素和行内元素。常见的块级元素有div, p ,h1~h6等。</p>\n'},{meta:{title:"what's is yeoman",date:"2014-12-25T11:10:44.000Z",tags:"tool",id:"11",createTime:"2014-12-25",url:"2014-12-25-what's is yeoman",strTag:"tool"},content:'<hr>\n<h2 id="yeoman-">Yeoman-前端工程化</h2>\n<p>yeoman——现代webapp构建工具，适合于复杂的web应用，yeoman又包括三个组成部分。在我们选择它或者使用它之前我们一定要知道它能做什么？适合做什么？</p>\n<ul>\n<li>Yo</li>\n<li>Grunt/gulp</li>\n<li>Bower/npm</li>\n</ul>\n<h3 id="yo">Yo</h3>\n<p>Yo提供了许多的生成器帮助我们快速的开始一个项目。因为在大多数时候我们的工作是重复的，比如要建立好目录文件结构，下载jquery/bootstrap等这些，然后将它们引入到页面中。Yo的作用就是将这些部分抽取出来并提供给我们，让我们无需从零开始，加快开发的进度。</p>\n<h3 id="grunt-gulp">Grunt/gulp</h3>\n<p>自动化流程构建，文件压缩、编译、项目预览、测试等。</p>\n<h3 id="bower-npm">Bower/npm</h3>\n<p>包管理工具，同时解决包的依赖关系。举个栗子，如果我们的项目中需要bootstrap，那么我们可能会需要去bootstrao的官网下载源码，同时bootstrap又回依赖于jquery，所以我们又去jquery的官网下载jquery,但是使用包管理工具，我们就可以使用一条命令就解决了。</p>\n<pre><code class="lang-node">bower install boostrap\n</code></pre>\n<h2 id="yeoman-">yeoman安装使用</h2>\n<ul>\n<li>安装</li>\n</ul>\n<pre><code class="lang-node">npm install -g yo bower grunt-cli gulp\n</code></pre>\n<p>这里将以全局的方式安装yo/bower/grunt-cli/gulp。\n说明：grunt和gulp我们可以任选其一，bower和npm也可以任选其一，因为他们做的事是一样的。</p>\n<ul>\n<li>Yo生成器</li>\n</ul>\n<p>Yo提供了webapp这样的生成器，提供了一个默认的模板项目，包括HTML5 Boilerplate/jQuery/Modernizr/Bootstrap这些，即我们使用&#39;yo webapp&#39;的形式就会帮助我们构建一个webapp项目，这个项目包括了上述的这些东西，当然在安装时我们可以选择性的选择是否需要。</p>\n<p>在使用之前先安装一个app generator</p>\n<pre><code class="lang-node">npm install -g webapp\n</code></pre>\n<p>之后就可以通过</p>\n<pre><code class="lang-node">yo webapp\n</code></pre>\n<p>来使用一个生成器。</p>\n<ul>\n<li>bower配合yo使用</li>\n</ul>\n<pre><code class="lang-node">grunt bower\ngrunt wiredep\n</code></pre>\n<p>将bower下载的包加载到项目文件中</p>\n<ul>\n<li>Grunt/gulp</li>\n</ul>\n<p>gulp流程：</p>\n<pre><code class="lang-node">yo webapp\ngulp serve\ngulp test\ngulp\n</code></pre>\n<p>grunt流程：</p>\n<pre><code>yo webapp\ngrunt serve\ngrunt test\ngrunt\n</code></pre><h2 id="gruntfile-js">Gruntfile.js</h2>\n<p>Gruntfile.js由以下几部分组成：</p>\n<ul>\n<li>&quot;wrapper&quot;函数</li>\n<li>项目与任务配置</li>\n<li>加载grunt插件和任务</li>\n<li>自定义任务</li>\n</ul>\n<p>示例：</p>\n<pre><code class="lang-node">/*wrapper函数*/\nmodule.exports = function(grunt) {\n\n  // 项目配置\n  grunt.initConfig({\n    pkg: grunt.file.readJSON(&#39;package.json&#39;),\n    uglify: {\n      /*指定了一个banner选项(用于在文件顶部生成一个注释)*/\n      options: {\n        banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&#39;\n      },\n      build: {\n        src: &#39;src/&lt;%= pkg.name %&gt;.js&#39;,\n        dest: &#39;build/&lt;%= pkg.name %&gt;.min.js&#39;\n      }\n    }\n  });\n\n  // 加载包含 &quot;uglify&quot; 任务的插件。\n  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);\n\n  // 默认被执行的任务列表。\n  grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);\n\n};\n</code></pre>\n<p>常用插件：</p>\n<ul>\n<li>contrib-jshint: js代码规范性验证</li>\n<li>contrib-watch: 文件变化监视</li>\n<li>contrib-clean: 目录清空</li>\n<li>contrib-uglify: js压缩</li>\n<li>contrib-copy: 文件合并</li>\n<li>contrib-connect: 开启connect服务器</li>\n<li>contrib-cssmin: css压缩</li>\n<li>contrib-less: less编译成css</li>\n<li>contrib-sass: sass编译成css</li>\n<li>autoprefixer: css前缀添加</li>\n<li>contrib-imagemin: 图片压缩</li>\n<li>usemin: 静态资源路径更换</li>\n<li>contrib-hmtlmin: html压缩</li>\n<li>bower: copy bower组件到生成目录</li>\n<li>wiredep: 将bower组件引入到html文件中</li>\n</ul>\n',summary:'<hr>\n<h2 id="yeoman-">Yeoman-前端工程化</h2>\n<p>yeoman——现代webapp构建工具，适合于复杂的web应用，yeoman又包括三个组成部分。在我们选择它或者使用它之前我们一定要知道它能做什么？适合做什么？</p>\n<ul>\n<li>Yo</li>\n<li>Grunt/gulp</li>\n<li>Bower/npm</li>\n</ul>\n<h3 id="yo">Yo</h3>\n<p>Yo提供了许多的生成器帮助我们快速的开始一个项目。因为在大多数时候我们的工作是重复的，比如要建立好目录文件结构，下载jquery/bootstrap等这些，然后将它们引入到页面中。Yo的作用就是将这些部分抽取出</p>\n'},{meta:{title:"The Little Schemer——read again",date:"2015-11-18T22:51:15.000Z",tags:["lisp","pl"],archives:"pl",id:"12",createTime:"2015-11-19",url:"2015-11-19-The Little Schemer——read again",strTag:"lisp、pl"},content:'<hr>\n<style>img{max-width:100%;}</style>\n\n<p><a class="text-center" href="http://www.ccs.neu.edu/home/matthias/BTLS/"><img data-src="/img/the-lillte-scheme.jpg" alt="the-little-scheme"></a>\nthe little scheme 是一本小人书，却很精妙。阅读它可以让你对编程语言有更好的认识，也能增加你对算法的理解(你真的会用递归了吗？)。\n说明：该书籍使用scheme来作为讲解的语言，scheme是lisp的一门方言，语法上比较特别的是S表达式。看到S表达式是不是感觉和语法树一般，一开始估计不是很习惯S表达式，但静下心来就会发现其实是一种很好理解也很简洁的语法。Good Luck!</p>\n<p><img class="text-center" data-src="/img/learn-programm.png" alt="oh,man.I just want to learn programm video game!">\noh,man.I just want to learn programm video game!</p>\n<h2 id="the-law-of-car">The Law of Car</h2>\n<blockquote>\n<p>The primitive car is defined only for non-empty lists.</p>\n</blockquote>\n<pre><code class="lang-scheme">Q:\nWhat is the car of l\nwhere\n    l is (((hotdogs))(and)(pickle) relish)\n\nA:\n((hotdogs)),\n    read as:\n    &quot;The list of the list of hotdogs.&quot;\n    ((hotdogs)) is the first S-expression of l.\n</code></pre>\n<p>[&quot;S表达式&quot;, &quot;列表&quot;]</p>\n<p><hr></p>\n<pre><code class="lang-scheme">Q:\nWhat is (car l)\nwhere\n    l is (((hotdogs)) (and) (pickle) relish)\n\nA:\n((hotdogs)),\nbecause (car l) is another way to ask for &quot;the car of the \nlist l.&quot;\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is (car (car l))\nwhere\n    l is (((hotdogs)) (and))\nA:\n(hotdogs).\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is the cdr of l\nwhere\n    l is (a b c)\nA:\n(b c)\n    because (b c) is the list l without (car l).\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is the cdr of l\nwhere\n    l is ((a b c) x y z)\nA:\n(x y z)\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is the cdr of l\nwhere\n    l is (hamburger)\nA:\n()\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is (cdr a)\nwhere \na is hotdogs\nA:\nNo answer\n    You cannot ask for the cdr of an atom.\n</code></pre>\n<h2 id="the-law-of-cdr">The Law of Cdr</h2>\n<blockquote>\n<p>The primitive cdr is defined only for non-empty lists.\nThe cdr of any non-empty list is always another list.</p>\n<hr>\n\n</blockquote>\n<pre><code class="lang-scheme">Q:\nwhat is (car (cdr l))\nwhere\nl is ((b)(x y)((c)))\nA:\n(x y),\nbecause((x y)((c))) is (cdr l), and (x y) is the car of\n(cdr l).\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is (cdr (cdr l))\nwhere\n    l is ((b)(x y)((c)))\nA:\n(((c))),\nbecause(x y)((c)) is (cdr l), and (((c))) is the cdr of (cdr l).\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nwhat does car take as an argument?\nA:\nit takes any non-empty list.\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat does cdr take as an argument?\nA:\nIt takes any non-empty list.\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is the cons of the atom a and the list l\nWhere a is peanut\nand\n    l is (butter and jelly)\nThis can also be written &quot;(cons a l)&quot;.\n    Read: &quot;cons the atom a onto the list l.&quot;\nA:\n(peanut butter and jelly),\n    because cons adds an atom to the front of a list.\n</code></pre>\n<pre><code class="lang-scheme">Q:\nWhat is (cons s l)\nwhere\n    s is ((help) this)\nand\n    l is (is very ((hard) to learn))\nA:\n(((help) this) is very ((hard) to learn)).\n</code></pre>\n<pre><code class="lang-scheme">Q:\nWhat does cons take as its arguments?\nA:\ncons takes two arguments:\n    the first one is any S-expression;\n    the second one is any list.\n</code></pre>\n<h2 id="the-law-of-cons">The Law of Cons</h2>\n<blockquote>\n<p>The primitive cons takes two arguments.\nThe second argument to cons must be a list.\nThe result is a list.</p>\n</blockquote>\n',summary:'<hr>\n<style>img{max-width:100%;}</style>\n\n<p><a class="text-center" href="http://www.ccs.neu.edu/home/matthias/BTLS/"><img data-src="/img/the-lillte-scheme.jpg" alt="the-little-scheme"></a>\nthe little scheme 是一本小人书，却很精妙。阅读它可以让你对编程语言有更好的认识，也能增加你对算法的理解(你真的会用递归了吗？)。\n说明：该书籍使用scheme来作为讲解的语言，scheme是lisp的一门方言，语法上比较特别的是S表达式。看到S表达式是不是感觉和语法树一般，一开始估计不是很习惯S表达式，但静下心来就会发现其实是一种很好理解也很简洁的语法。Good Luck!</p>\n<p><img class="text-center" data-src="/img/learn-programm.png" alt="oh,man.I just want to learn programm video game!">\noh,man.I just want to learn programm video game!</p>\n<h2 id="the-law-of-car">The Law of Car</h2>\n<blockquote>\n<p>The primitive car is defined only for non-empty lists.</p>\n</blockquote>\n'},{meta:{title:"css特殊图形绘制",date:"2015-11-18T15:15:02.000Z",tags:"css",archives:"pl",id:"13",createTime:"2015-11-18",url:"2015-11-18-css特殊图形绘制",strTag:"css"},content:'<hr>\n<p><style>#line1{width: 300px;height: 0;border: 2px solid red;} #line2{width: 300px;height: 4px;background: blue;} #square1{width: 100px;height: 100px;background: #35b558;} #square2{width: 0;height:0;border:50px solid yellow;} #circle1{width: 100px;height: 100px;border-radius: 50%; background: #35b558;} #circle2{width: 0;height:0;border:50px solid yellow;border-radius: 50%;}#circle-box{width: 100px;height: 100px;border:50px solid #35b558; border-radius: 50%;} #circle2-box{width: 100px;height: 50px;border:20px solid red; border-radius: 100px 50px 100px 0px / 50px 20px 50px 0px} #trangle div{display: inline-block;} #trangle .trangle1{width: 0;height: 0;border-left:50px solid transparent;border-right:50px solid transparent;border-bottom:100px solid red;}#trangle .trangle2{width: 0;height: 0;border-left:50px solid transparent;border-right:50px solid transparent;border-top:100px solid #35b558;}#trangle .trangle3{width: 0;height: 0;border-left:100px solid blue;border-top:50px solid transparent;border-bottom:50px solid transparent;}#trangle .trangle4{width: 0;height: 0;border-right:100px solid yellow;border-top:50px solid transparent;border-bottom:50px solid transparent;} \n</style>\n<img src="/img/batteries_included.png" alt="batteries_included" style="max-width:100%;">\nOK... this one looked funnier in my head at 3 in the morning.</p>\n<p>直线</p>\n<div id="line1"></div>\n<div id="line2"></div>\n\n\n\n\n<pre><code class="lang-css">/*使用边框的方式需要注意添加了几个方向的边框，默认border会添加四个方向的边框*/\n#line1{\n    width: 100px;\n    height: 0;\n    border: 2px solid red;\n} \n\n#line2{\n    width: 100px;\n    height: 4px;\n    background: blue;\n}\n</code></pre>\n<p><hr>\n正方形</p>\n<div id="square1">#square1</div>\n<div id="square2">#square2</div>\n\n<pre><code class="lang-css">#square1{\n    width: 100px;\n    height: 100px;\n    background: #35b558;\n} \n\n/*注意文本区*/\n#square2{\n    width: 0;\n    height:0;\n    border:50px solid yellow;\n}\n</code></pre>\n<hr>\n\n\n<p>圆形</p>\n<div id="circle1">#circle1</div>\n<div id="circle2">#circle2</div>\n\n<pre><code class="lang-css">#circle1{\n    width: 100px;\n    height: 100px;\n    border-radius: 50%;\n    background: #35b558;\n} \n\n/*注意文本区*/\n#circle2{\n    width: 0;\n    height:0;\n    border-radius: 50%;\n    border:50px solid yellow;\n}\n</code></pre>\n<h2 id="border-radius-">border-radius参数说明</h2>\n<p>语法</p>\n<pre><code class="lang-css">/*完整的圆角可以设置8个参数，左上角水平圆角半径大小 右上角水平圆角半径大小 右下角水平圆角半径大小 左下角水平圆角半径大小/左上角垂直圆角半径大小 右上角垂直圆角半径大小 右下角垂直圆角半径大小 左下角垂直圆角半径大小*/\nborder-radius: 1-4 length|% / 1-4 length|%;\n\nborder-radius: 10px;\n/*等同于*/\nborder-top-left-radius: 10px;\nborder-top-right-radius: 10px;\nborder-bottom-right-radius: 10px;\nborder-bottom-left-radius: 10px;\n\n/*注意对角补全,斜杠前为水平半径、后为垂直半径*/\nborder-radius: 2px 1px 4px / 0.5px 3px;\n\nborder-top-left-radius: 2px 0.5px;\nborder-top-right-radius: 1px 3px;\nborder-bottom-right-radius: 4px 0.5px;\nborder-bottom-left-radius: 1px 3px;\n</code></pre>\n<p>圆环</p>\n<div id="circle-box"></div>\n<div id="circle2-box"></div>\n\n<pre><code class="lang-css">#circle-box{\n    width: 100px;\n    height: 100px;\n    border:50px solid #35b558; \n    border-radius: 50%;\n}\n\n/*调整单个参数可以得到更为复杂的图形*/\n#circle2-box{\n    width: 100px;\n    height: 50px;\n    border:20px solid red; \n    border-radius: 100px 50px 100px 0px / 50px 20px 50px 0px}\n</code></pre>\n<p>三角形</p>\n<div id="trangle"><div class="trangle1"></div><div class="trangle2"></div><div class="trangle3"></div><div class="trangle4"></div></div>\n\n<pre><code class="lang-css">#trangle .trangle1 {\n        width: 0;\n        height: 0;\n        border-left: 50px solid transparent;\n        border-right: 50px solid transparent;\n        border-bottom: 100px solid red;\n    }\n\n    #trangle .trangle2 {\n        width: 0;\n        height: 0;\n        border-left: 50px solid transparent;\n        border-right: 50px solid transparent;\n        border-top: 100px solid #35b558;\n    }\n\n    #trangle .trangle3 {\n        width: 0;\n        height: 0;\n        border-left: 100px solid blue;\n        border-top: 50px solid transparent;\n        border-bottom: 50px solid transparent;\n    }\n\n    #trangle .trangle4 {\n        width: 0;\n        height: 0;\n        border-right: 100px solid yellow;\n        border-top: 50px solid transparent;\n        border-bottom: 50px solid transparent;\n    }\n</code></pre>\n<p>爱心</p>\n<div id="heart"></div>\n\n<p>八卦</p>\n<p><div id="baguai-wrap"><div class="b1-circle"></div></div></p>\n<p><div id="baguai-wrap"><div class="b2-circle"></div></div></p>\n<p><div id="baguai-wrap"><div class="b-circle"></div></div></p>\n<pre><code class="lang-css">/*八卦*/\n#baguai-wrap{\n    padding-top: 30px;\n    height: 150px;\n    background-color: gray;\n}\n\n#baguai-wrap .b-circle{\n    position: relative;\n    width: 100px;\n    height: 0;\n    border-top: 50px solid #ffffff;\n    border-bottom: 50px solid #000000;\n    border-radius: 50%;\n    margin: 0 auto;\n    overflow: visible;\n}\n\n#baguai-wrap .b-circle:before{\n    position: absolute;\n    content: &#39;&#39;;\n    left: 0;\n    top: -25px;\n    width: 10px;\n    height: 10px;\n    border: 20px solid #000000;\n    background: #ffffff;\n    border-radius: 50%;\n}\n\n#baguai-wrap .b-circle:after{\n    position: absolute;\n    content: &#39;&#39;;\n    left: 50px;\n    top: -25px;\n    width: 10px;\n    height: 10px;\n    border: 20px solid #ffffff;\n    background-color: #000000;\n    border-radius: 50%;\n}\n</code></pre>\n',summary:'<hr>\n<p><style>#line1{width: 300px;height: 0;border: 2px solid red;} #line2{width: 300px;height: 4px;background: blue;} #square1{width: 100px;height: 100px;background: #35b558;} #square2{width: 0;height:0;border:50px solid yellow;} #circle1{width: 100px;height: 100px;border-radius: 50%; background: #35b558;} #circle2{width: 0;height:0;border:50px solid yellow;border-radius: 50%;}#circle-box{width: 100px;height: 100px;border:50px solid #35b558; border-radius: 50%;} #circle2-box{width: 100px;height: 50px;border:20px solid red; border-radius: 100px 50px 100px 0px / 50px 20px 50px 0px} #trangle div{display: inline-block;} #trangle .trangle1{width: 0;height: 0;border-left:50px solid transparent;border-right:50px solid transparent;border-bottom:100px solid red;}#trangle .trangle2{width: 0;height: 0;border-left:50px solid transparent;border-right:50px solid transparent;border-top:100px solid #35b558;}#trangle .trangle3{width: 0;height: 0;border-left:100px solid blue;border-top:50px solid transparent;border-bottom:50px solid transparent;}#trangle .trangle4{width: 0;height: 0;border-right:100px solid yellow;border-top:50px solid transparent;border-bottom:50px solid transparent;} \n</style>\n<img src="/img/batteries_included.png" alt="batteries_included" style="max-width:100%;">\nOK... this one looked funnier in my head at 3 in the morning.</p>\n<p>直线</p>\n<div id="line1"></div>\n<div id="line2"></div>\n\n'},{meta:{title:"css居中那些事",date:"2015-11-03T15:36:51.000Z",archives:"pl",tags:"css",id:"14",createTime:"2015-11-03",url:"2015-11-03-css居中那些事",strTag:"css"},content:'<hr>\n<h2 id="-">目录</h2>\n<ul>\n<li><a href="#CSS_margin_属性">margin: 0 auto</a></li>\n<li><a href="#text-align实现水平居中">text-algin: center;</a></li>\n<li><a href="#绝对定位实现垂直居中">position:absolute + margin负值</a></li>\n<li><a href="#绝对定位且居中元素不知宽高的情况">position:absolute + translate偏移</a></li>\n<li><a href="#绝对定位+margin:auto;实现水平垂直居中">position:absolute + margin:auto</a></li>\n</ul>\n<h2 id="css-margin-">CSS margin 属性</h2>\n<div style="border: 1px solid #444;">\n    <p style="background:green;margin:5px 4px 3px 5px;">设置 p 元素的 4 个外边距：margin:5px 4px 3px 5px;</p>\n</div>\n\n\n\n\n<h3 id="-">定义和用法</h3>\n<p>margin 简写属性在一个声明中设置所有外边距属性。该属性可以有 1 到 4 个值。</p>\n<h3 id="-">说明</h3>\n<p>这个简写属性设置一个元素所有外边距的宽度，或者设置各边上外边距的宽度。\n块级元素的垂直相邻外边距会合并，而行内元素实际上不占上下外边距。行内元素的的左右外边距不会合并。同样地，浮动元素的外边距也不会合并。允许指定负的外边距值，不过使用时要小心。</p>\n<p>注释：允许使用负值。</p>\n<p>垂直外边距之所以设计为可以在垂直方向合并主要是方便文本的排版，即一段文本分行的时候上下两行直接的间距不会叠加。</p>\n<p>简写的情况：</p>\n<pre><code class="lang-css">/*四个方向的外边距都是10px*/\nmargin: 10px;\n</code></pre>\n<pre><code class="lang-css">/*上下的外边距都是10px，左右的外边距20px*/\nmargin: 10px 20px;\n</code></pre>\n<pre><code class="lang-css">/*上的外边距都是10px，左右的外边距是5px，下外边距15px*/\nmargin: 10px 5px 15px;\n</code></pre>\n<pre><code class="lang-css">/*四个值依次是上、右、下、左*/\nmargin: 10px 5px 15px 20px;\n</code></pre>\n<pre><code class="lang-css">/*设为auto的计算方式*/\nmargin: 0 auto;    /*常用的水平居中对齐方式*/\nmargin: auto;\n</code></pre>\n<p>上述的auto的计算方式是父容器-子元素剩余部分浏览器自动计算，以上述的水平居中方式为例，左右的外边距等于父容器减去子容器剩余部分的宽度均匀分配给左右，从而实现居中对齐的效果。</p>\n<p>上诉的第二种声明并不能实现垂直居中的效果，具体可以看w3c标准声明或看下<a href="http://www.zhihu.com/question/21644198">知乎的这篇文章</a>。</p>\n<h3 id="margin-">margin使用百分比单位计算的情况</h3>\n<pre><code class="lang-css">/*百分比是按照父容器的宽度来计算的，务必注意*/\nmargin: 20%;\n</code></pre>\n<p>从上我们可以知道通过margin如何实现水平居中。</p>\n<h2 id="text-align-">text-align实现水平居中</h2>\n<p>text-align 属性规定元素中的文本的水平对齐方式。通过它我们可以设置行内元素的对齐方式</p>\n<pre><code class="lang-css">text-align:center\n</code></pre>\n<p style="text-align:center;border:1px solid #444;">text-align实现水平居中,我已经居中了</p>\n\n\n<h2 id="-">绝对定位实现垂直居中</h2>\n<div style="position:relative;background:#444;height:200px;">\n    <div style="position:absolute;top:50%;left:50%;margin-top:-50px;margin-left:-50px;width:100px;height:100px;background:#ffffff;text-align:center;line-height:100px;">居中一</div>\n</div>\n\n<p>实现代码：</p>\n<pre><code class="lang-css">    position:absolute;\n    top:50%;\n    left:50%;\n    margin-top:-50px;\n    margin-left:-50px;\n    width:100px;\n    height:100px;\n</code></pre>\n<p>采用绝对定位加负外边距的方式，首先上，左偏移父容器的50%;然后再自身偏移自己宽高的50%，从而实现垂直水平居中。该方式需要居中元素的宽高确定。</p>\n<h2 id="-">绝对定位且居中元素不知宽高的情况</h2>\n<div style="position:relative;background:#444;height:200px;">\n    <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:100px;height:100px;background:#ffffff;text-align:center;line-height:100px;">居中二</div>\n</div>\n\n<pre><code class="lang-css">    position:absolute;\n    top:50%;\n    left:50%;\n    transform:translate(-50%,-50%);\n    width:100px;\n    height:100px;\n</code></pre>\n<p>在这里使用css3的transform:translate(-50%,-50%);属性来实现元素自身的一个偏移</p>\n<h2 id="-margin-auto-">绝对定位+margin:auto;实现水平垂直居中</h2>\n<div style="position:relative;background:#444;height:200px;">\n    <div style="position:absolute;top:0;left:0;bottom:0;right:0;width:100px;height:100px;margin:auto;background:#ffffff; text-align:center;line-height:100px;">居中三</div>\n</div>\n\n<pre><code class="lang-css">position:absolute;\ntop:0;\nleft:0;\nbottom:0;\nright:0;\nwidth:100px;\nheight:100px;\nmargin:auto;\n</code></pre>\n',summary:'<hr>\n<h2 id="-">目录</h2>\n<ul>\n<li><a href="#CSS_margin_属性">margin: 0 auto</a></li>\n<li><a href="#text-align实现水平居中">text-algin: center;</a></li>\n<li><a href="#绝对定位实现垂直居中">position:absolute + margin负值</a></li>\n<li><a href="#绝对定位且居中元素不知宽高的情况">position:absolute + translate偏移</a></li>\n<li><a href="#绝对定位+margin:auto;实现水平垂直居中">position:absolute + margin:auto</a></li>\n</ul>\n<h2 id="css-margin-">CSS margin 属性</h2>\n<div style="border: 1px solid #444;">\n    <p style="background:green;margin:5px 4px 3px 5px;">设置 p 元素的 4 个外边距：margin:5px 4px 3px 5px;</p>\n</div>\n\n'},{meta:{title:"css3简易魔方绘制",date:"2015-11-11T14:08:10.000Z",tags:"css",archives:"pl",id:"15",createTime:"2015-11-11",url:"2015-11-11-css3简易魔方绘制",strTag:"css"},content:'<hr>\n<p>简易魔方效果：<a href="/other/3dCube/index.html">点击查看</a>\n在线编辑实例：<a href="/liveCoding/demo/index.html">点我开始制作</a></p>\n<h2 id="-">立方体绘制</h2>\n<p>3D变化的坐标如下所示：</p>\n<p><img src="/img/3d_axes.png" alt="css3D坐标系"></p>\n<p>网格所在的面代表我们的设备屏幕（大多情况下为电脑屏幕）</p>\n<h3 id="transform">transform</h3>\n<p>浏览器支持情况:\nInternet Explorer 10、Firefox 以及 Opera 支持 transform 属性。\nChrome 和 Safari 需要前缀 -webkit-。\n注释：Internet Explorer 9 需要前缀 -ms-。</p>\n<p>旋转测试：</p>\n<p>正常情况</p>\n<div class="margin-auto" style="height: 80px;">\n    <div style="position:absolute;background: brown;height: 50px;width: 50px;"></div>\n</div>\n\n<p>transform: rotateX(Xdeg);[以X为轴进行旋转]</p>\n<div class="rotateX-wrapper">\n    <div class="box"></div>\n</div>\n\n<p>transform: rotateY(Xdeg);[以Y为轴进行旋转]</p>\n<div class="rotateY-wrapper">\n    <div class="box"></div>\n</div>\n\n\n<p>transform: rotateZ(Xdeg);[以Z为轴进行旋转]</p>\n<div class="rotateZ-wrapper">\n    <div class="box"></div>\n</div>\n\n<p><hr>\n偏移测试：</p>\n<div class="translateX-wrapper">\n    <div class="box">translateX</div>\n</div>\n\n<div class="translateY-wrapper">\n    <div class="box">translateY</div>\n</div>\n<hr>\n\n\n\n注：这里将父容器宽高设为与子容器一样（若有边框需要考虑边框的大小）\n\n<div class="margin-auto" style="height: 150px;">\n    <div class="square-wrapper"><div class="front"></div><div class="behind"></div><div class="left"></div><div class="right"></div><div class="top"></div><div class="bottom"></div>\n    </div>\n</div>\n\n<p>注：示例并未做兼容处理\n1 前后两个面经Z轴偏移，前为正（向屏幕外，用户的方向偏移），后为负得到\n2 左右两个面经旋转偏移得到</p>\n<p>同时设置旋转和偏移时，属性的顺序会影响最终的效果</p>\n<div class="margin-auto" style="height: 150px;">\n    <div class="square-wrap"><div class="front"></div><div class="behind"></div><div class="left"></div><div class="right"></div><div class="top"></div><div class="bottom"></div>\n    </div>\n</div>\n\n<p>立方体效果（添加了旋转动画）</p>\n<pre><code class="lang-html">&lt;div class=&quot;square-wrapper&quot;&gt;\n    &lt;div class=&quot;front&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;behind&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-css">.square-wrapper,\n.square-wrapper &gt; div{\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n\n/*立体实现*/\n.square-wrapper{\n    margin-top: 20px;\n    transform-style: preserve-3d;\n    animation: square-animation 5s infinite;\n}\n\n@keyframes square-animation{\n    0% {transform: rotateX(0deg) rotateY(0deg);}\n    45% {transform: rotateX(90deg)}\n    75% {transform: rotateY(90deg);}\n    90% {transform: rotateX(45deg) rotateY(45deg);}\n    100% {transform: rotateX(0deg) rotateY(0deg);}\n}\n\n.square-wrap .top{\n    background-color: red;\n    transform: translateY(-50px) rotateX(90deg);\n}\n\n.square-wrap .bottom {\n    background-color: brown;\n    transform: translateY(50px) rotateX(-90deg);\n}\n\n.square-wrap .left{\n    background-color: green;\n    transform:translateX(-50px) rotateY(90deg);\n}\n\n.square-wrap .right{\n    background-color: blue;\n    transform: translateX(50px) rotateY(-90deg);\n}\n\n.square-wrap .front{\n    background-color: #ddd;\n    transform: translateZ(50px);\n}\n\n.square-wrap .behind{\n    background-color: #000000;\n    transform: translateZ(-50px);\n}\n</code></pre>\n',summary:'<hr>\n<p>简易魔方效果：<a href="/other/3dCube/index.html">点击查看</a>\n在线编辑实例：<a href="/liveCoding/demo/index.html">点我开始制作</a></p>\n<h2 id="-">立方体绘制</h2>\n<p>3D变化的坐标如下所示：</p>\n<p><img src="/img/3d_axes.png" alt="css3D坐标系"></p>\n<p>网格所在的面代表我们的设备屏幕（大多情况下为电脑屏幕）</p>\n<h3 id="transform">transform</h3>\n<p>浏览器支持情况:\nInternet Explorer 10、Firefox 以及 Opera 支持 transform 属性。\nChrome 和 Safari 需要前缀 -webkit-。\n注释：Internet Explorer 9 需要前缀 -ms-。</p>\n'},{meta:{title:"Coding form zero",date:"2015-12-18T15:36:51.000Z",tags:["随笔"],id:"16",createTime:"2015-12-18",url:"2015-12-18-Coding form zero",strTag:"随笔"},content:'<hr>\n<h2 id="why-code-from-zero-">Why code from zero?</h2>\n<blockquote>\n<p>因为我任性。。</p>\n</blockquote>\n<p>刚接触编程的人都会感叹，要学的怎么那么多？刚学的还没用就过时了。</p>\n<p>其实很多原理都是一样的，变的只是外观，掀开面纱就会发现原来就是那么回事。</p>\n<p>概念总是被复杂化，本来很简单的确弄得五花八门的，增加学习和使用的难度。</p>\n<h2 id="simple-maybe-better">Simple maybe better</h2>\n<p>我的入门语言是c，学了一个学期也没学到啥。后来我学了c++，学了一年，依然没有学到什么？并不是说C/C++不好，只是太复杂，不适合入门语言。后来我接触ruby，js，虽然时间不长但已经可以做出些有用的东西，当我再回过头去看c/c++时，才发现有些东西是如此简单。</p>\n<h2 id="scheme-">Scheme,简洁却功能强大，很多功能还是其它语言所没有的</h2>\n<p><img src="/img/matz/schme.png" alt="lambda"></p>\n',summary:'<hr>\n<h2 id="why-code-from-zero-">Why code from zero?</h2>\n<blockquote>\n<p>因为我任性。。</p>\n</blockquote>\n<p>刚接触编程的人都会感叹，要学的怎么那么多？刚学的还没用就过时了。</p>\n<p>其实很多原理都是一样的，变的只是外观，掀开面纱就会发现原来就是那么回事。</p>\n<p>概念总是被复杂化，本来很简单的确弄得五花八门的，增加学习和使用的难度。</p>\n<h2 id="simple-maybe-better">Simple maybe better</h2>\n<p>我的入门语言是c，学了一个学期也没学到啥。后来我学了c++，学了一年，依然没有学到什么？并不是说C/C++不好，只是太复杂，不适合入门语言。后来我接触r</p>\n'},{meta:{title:"jQuery is not must for us——DOM操作",date:"2015-11-24T12:50:32.000Z",tags:"jquery",archives:"pl",id:"17",createTime:"2015-11-24",url:"2015-11-24-jQuery is not must for us——DOM操作",strTag:"jquery"},content:'<hr>\n<p>通过浏览器提供的DOM API,我们可以完成对页面元素的增删改查移动等。</p>\n<ul>\n<li>创建元素</li>\n<li>插入元素</li>\n<li>移动元素</li>\n<li>删除元素</li>\n<li>类操作</li>\n<li>属性操作</li>\n<li>文本操作</li>\n<li>样式操作</li>\n</ul>\n<h2 id="-">创建元素</h2>\n<pre><code class="lang-javascript">/*jquery*/\n    $(&#39;&lt;div&gt;&lt;/div&gt;&#39;);\n/*DOM*/\ndocument.createElement(&#39;div&#39;);\n</code></pre>\n<h2 id="-">插入元素</h2>\n<pre><code class="lang-html">&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;3&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id="-id-1-div-id-1-1-div">在id为1的div的后面插入一个id为1.1的div</h3>\n<pre><code class="lang-html">&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;01&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;3&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-javascript">/*jquery*/\n    $(&#39;#1&#39;).after(&#39;&lt;div id=&quot;1.1&quot;&gt;&lt;/div&gt;&#39;);\n/*DOM*/\ndocument.getElementById(&#39;1&#39;).insertAdjacentHTML(&#39;afterend&#39;, &#39;&lt;div id=&quot;1.1&quot;&gt;&lt;/div&gt;&#39;);\n</code></pre>\n<h3 id="-id-1-div-id-a-div">在id为1的div之前插入一个id为A的div</h3>\n<pre><code class="lang-html">&lt;div id=&quot;A&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;3&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-javascript">$(&#39;#1&#39;).before(&#39;&lt;div id=&quot;A&quot;&gt;&lt;/div&gt;&#39;);\n\n/*DOM\ndocument.getElementById(&#39;1&#39;).insertAdjacentHTML(&#39;beforebegin&#39;, &#39;&lt;div id=&quot;A&quot;&gt;&lt;/div&gt;&#39;);\n</code></pre>\n<h3 id="-">插入子元素</h3>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;oldChild&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>插入一个子元素将其变成</p>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;newChild&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;oldChild&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).prepend(&#39;&lt;div id=&quot;newChild&quot;&gt;&lt;/div&gt;&#39;);\n\n/*DOM*/\ndocument.getElementById(&#39;parent&#39;)\n    .insertAdjacentHTML(&#39;afterbegin&#39;, &#39;&lt;div id=&quot;newChild&quot;&gt;&lt;/div&gt;&#39;);\n</code></pre>\n<h2 id="-">移动元素</h2>\n<p>将下面的结构</p>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;c1&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c2&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c3&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=&quot;orphan&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>变成</p>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;c1&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c2&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c3&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;orphan&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).append(&#39;#orphan&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;parent&#39;)\n    .appendChild(document.getElementById(&#39;orphan&#39;));\n</code></pre>\n<p>如果想将id为orphan的div插入到c1</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).prepend($(&#39;#orphan&#39;));\n</code></pre>\n<pre><code class="lang-javascript">document.getElementById(&#39;parent&#39;)\n    .insertBefore(document.getElementById(&#39;orphan&#39;), document.getElementById(&#39;c1&#39;));\n</code></pre>\n<h2 id="-">移除</h2>\n<p>这里假设存在一个id为foobar的元素</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foobar&#39;).remove();\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foobar&#39;).parentNode.removeChild(document.getElementById(&quot;foobar&quot;));\n</code></pre>\n<h2 id="-class">添加和移除class</h2>\n<p>现在我们希望将</p>\n<pre><code class="lang-html">&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-html">&lt;div id=&quot;foo&quot; class=&quot;bold&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).addClass(&#39;bold&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">/*IE9有问题*/\ndocuement.getElementById(&#39;foo&#39;).classList.add(&#39;bold&#39;);\n\n/*所有浏览器都支持*/\ndocument.getElementById(&#39;foo&#39;).className += &#39;bold&#39;;\n</code></pre>\n<p>移除bold类</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).removeClass(&#39;bold&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">/*IE9有问题*/\ndocuement.getElementById(&#39;foo&#39;).classList.remove(&#39;bold&#39;);\n\n/*所有浏览器都支持\ndocument.getElementById(&#39;foo&#39;).className = document.getElementById(&#39;foo&#39;).className.replace(/^bold$/, &#39;&#39;);\n</code></pre>\n<h2 id="-">属性修改</h2>\n<p>给id=&quot;foo&quot;的元素设置role属性为button</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).attr(&#39;role&#39;, &#39;button&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foo&#39;).setAttribute(&#39;role&#39;, &#39;button&#39;);\n</code></pre>\n<p>移除我们添加的属性</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).removeAttr(&#39;role&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foo&#39;).removeAttribute(&#39;role&#39;);\n</code></pre>\n<h2 id="-">文本修改</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).text(&#39;Goodbye!&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foo&#39;).innerHTML = &#39;Goodbye!&#39;;\ndocument.getElementById(&#39;foo&#39;).innerText = &#39;GoodBye!&#39;;\n/*IE9+*/\ndocument.getElementById(&#39;foo&#39;).textContent = &#39;GoodBye!&#39;;\n</code></pre>\n<h2 id="-">样式修改</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#note&#39;).css(&#39;fontWeight&#39;, &#39;bold&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;note&#39;).style.fontWeight = &#39;bold&#39;;\n</code></pre>\n',
summary:"<hr>\n<p>通过浏览器提供的DOM API,我们可以完成对页面元素的增删改查移动等。</p>\n<ul>\n<li>创建元素</li>\n<li>插入元素</li>\n<li>移动元素</li>\n<li>删除元素</li>\n<li>类操作</li>\n<li>属性操作</li>\n<li>文本操作</li>\n<li>样式操作</li>\n</ul>\n"},{meta:{title:"jQuery is not must for us——异步请求",date:"2015-11-24T12:40:32.000Z",tags:"jquery",archives:"pl",id:"18",createTime:"2015-11-24",url:"2015-11-24-jQuery is not must for us——异步请求",strTag:"jquery"},content:'<hr>\n<p>jQuery对象只是对XMLHttpRequest对象进行了封装，真正的异步请求还是由浏览器发起的。</p>\n<ul>\n<li>GET</li>\n<li>POST</li>\n<li>URL Encode</li>\n<li>JSON</li>\n<li>Uploading</li>\n<li>CORS</li>\n<li>JSONP</li>\n</ul>\n<h2 id="get-">GET请求</h2>\n<p>在这里我们向服务器发起一个请求，给服务器传一个id参数然后希望服务器传回该id的用户名。</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">/*常用的jquery get请求方式*/\n$.ajax(&#39;myservice/username&#39;, {\n    data: {\n    id: &#39;unique_id&#39;\n    }\n})\n.then(\nfunction success(name){\n    alert(&quot;用户名是：&quot; + name);\n},\nfunction fail(data, status){\n    alert(&quot;请求失败. Return status of &quot; + status);\n})\n</code></pre>\n<h3 id="-xmlhttprequest-">原生XMLHttpRequest对象实现</h3>\n<pre><code class="lang-javascript">var xhr = new XMLHttpRequest();\nxhr.open(&#39;GET&#39;, encodeURL(&#39;myservice/username?id=unique_id&#39;));\nxhr.onload = function(){\n    if(xhr.status === 200){\n    alert(&quot;用户名是：&quot; + xhr.responseText);\n}\nelse{\n    alert(&#39;Request failed. Return status of &#39; + xhr.status);\n}\n};\nxhr.send();\n</code></pre>\n<h2 id="post">POST</h2>\n<p>post用来向服务器传送数据，这里我们传入一个用户id和新用户名，希望服务器完成对该用户的修改同时会返回修改的内容。</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">var newName = &#39;yangxiaofu&#39;;\n$.ajax(&#39;myservice/username?&#39; + $.param({id: &#39;unique_id&#39;}),\n{    method: &#39;POST&#39;,\n    data: {\n        name: newName\n    }\n})\n.then(\n    function sucess(name){\n    if(name !== newName){\n        alert(&quot;something wrong. Name is now &quot; + name);\n    }\n},\nfunction fail(data, status){\n    alert(&#39;Request failed. Returned status of &#39; + status);\n}\n);\n</code></pre>\n<h3 id="-xmlhttprequest-">原生XMLHttpRequest对象实现</h3>\n<pre><code class="lang-javascript">var newName = &quot;yangxiaofu&quot;,\n    xhr = new XMLHttpRequest();\n\nxhr.open(&quot;POST&quot;,\n    encodeURI(&#39;myservice/username?id=unique_id&#39;));\n    xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencode&#39;);\n    xhr.onload = function(){\n        if(xhr.status === 200 &amp;&amp; xhr.responseText !== newName){\n        alert(&#39;Something went wrong.  Name is now &#39; + xhr.responseText);\n    } else if (xhr.status !== 200) {\n        alert(&#39;Request failed.  Returned status of &#39; + xhr.status);\n    }\n};\nxhr.send(encodeURI(&#39;name=&#39; + newName));\n</code></pre>\n<h3 id="url-encoding">URL Encoding</h3>\n<p>将一个对象转换成URL编码的字符串</p>\n<pre><code class="lang-javascript">$.param({\n    key1: &quot;value1&quot;,\n    &#39;key2&#39;: &quot;value2&quot;\n});\n</code></pre>\n<p>我们可以用encodeURL和encodeURLComponent来实现同样的功能,如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。</p>\n<pre><code class="lang-javascript">function param(obj){\n    var encodedString = &#39;&#39;;\n    for(var prop in object){\n        if(object.hasOwnProperty(prop)){\n            if(encodedString.length &gt; 0){\n                encodedString += &#39;&amp;&#39;;\n            }\n            encodedString += encodeURL(prop + &#39;=&#39; + object[prop]);\n        }\n    }\n    return encodedString;\n}\n</code></pre>\n<h2 id="-">文件上传</h2>\n<p>首先我们应该明确，IE9及之前的版本如果要上传文件的话只能通过form表单，即如下的形式</p>\n<pre><code class="lang-html">&lt;input type=&quot;file&quot;&gt;\n</code></pre>\n<p>通过浏览器提供的文件API ,我们可以通过两种方式上传文件：</p>\n<ul>\n<li>使用multipart/form-data形式的表单</li>\n<li>将文件数据存放在请求体中</li>\n</ul>\n<p>通过下面的表单提交文件</p>\n<pre><code class="lang-html">&lt;input type=&quot;file&quot; id=&quot;test-input&quot;&gt;\n</code></pre>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">var file = $(&#39;#test-input&#39;)[0].files[0],\n    formData = new FormData();\n\nformData.append(&#39;file&#39;, file);\n\n$.ajax(&#39;myserver/uploads&#39;,{\n    method: &#39;POST&#39;,\n    contentType: false,\n    processData: false,\n    data: formData\n});\n\n/*直接提交文件数据*/\n$.ajax(&#39;myserver/uploads&#39;,{\n    method: &#39;POST&#39;,\n    contentType: file.type,\n    processData: false,    /*避免jquery使用URL encode的形式对文件数据进行编码*/\n    data: file\n})\n</code></pre>\n<h3 id="xmlhttprequest">XMLHttpRequest</h3>\n<pre><code class="lang-javascript">/*multipart编码形式*/\nvar formData = new FormData(),\n    file = document.getElementById(&#39;test-input&#39;).files[0],\n    xhr = new XMLHttpRequest();\n\nformData.append(&#39;file&#39;, file);\nxhr.open(&#39;POST&#39;, &#39;myserver/uploads&#39;);\nxhr.send(formData);\n\n/*将文件数据以request body的形式提交*/\nvar file = document.getElementById(&#39;test-input&#39;).files[0],\n    xhr = new XMLHttpRequest();\n\n    xhr.open(&#39;POST&#39;, &#39;myserver/uploads&#39;);\n    xhr.setRequestHeader(&#39;Content-Type&#39;, file.type);\n    xhr.send(file);\n</code></pre>\n',summary:"<hr>\n<p>jQuery对象只是对XMLHttpRequest对象进行了封装，真正的异步请求还是由浏览器发起的。</p>\n<ul>\n<li>GET</li>\n<li>POST</li>\n<li>URL Encode</li>\n<li>JSON</li>\n<li>Uploading</li>\n<li>CORS</li>\n<li>JSONP</li>\n</ul>\n"},{meta:{title:"再谈对闭包的理解",date:"2016-03-05T15:06:36.000Z",tags:["js","pl"],id:"19",createTime:"2016-03-05",url:"2016-03-05-再谈对闭包的理解",strTag:"js、pl"},content:'<hr>\n<h3 id="-">闭包只是为了实现词法作用域而用到的一种数据结构而已</h3>\n<p>先从阮一峰09年写的一篇关于闭包的文章开始<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">(原文地址)</a>文中说&quot;可以把闭包理解为就是能够读取其他函数内部变量的函数,因为js中,只有函数内部的子函数才能读取局部变量，因此也可以把闭包定义在一个函数内部的函数。所以闭包本质就是将函数内部和函数外部连接起来的一座桥梁&quot;。</p>\n<p>毕竟不是专业学习js的，也不是程序语言方面的专家，在这里就不去计较了，下文会给出更完整的闭包说明。(PS:个人还是比较欣赏阮一峰写的文章的，能将一些概念讲得通俗易懂)</p>\n<p>最后还留下了一个思考题</p>\n<ul>\n<li>示例01：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()());\n</code></pre>\n</li>\n<li>示例02：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　var that = this;\n　　　　　　return function(){\n　　　　　　　　return that.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()());\n</code></pre>\n看完这道题，就希望大家将this和闭包分开，不要给自己找麻烦？</li>\n</ul>\n<p>在开始说闭包之前，需要理解好以下的概念：</p>\n<ul>\n<li>词法作用域(静态作用域)</li>\n<li>函数上下文</li>\n</ul>\n<p><a href="http://yangxiaofu.com/2016/01/25/js/closure-this/">之前简单的提过</a>,词法作用域简单的理解就是函数的上下文是在声明是确定的，而不是在调用时确定的。这里不想对这两个名词作过多的解释，我们知道js/ruby/python等主流的语言都是词法作用域就好，因为与之相对的动态作用域有许多的问题，所以现在的语言基本都是词法作用域的。</p>\n<p>函数上下文就简单的理解为函数执行的环境好了，在这个环境中保存了函数执行所需的变量。</p>\n<h3 id="javascript-">JavaScript权威指南第六版关于闭包的说明</h3>\n<blockquote>\n<p>JavaScript采用词法作用域，也就是说函数的执行依赖于变量的作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现词法作用域，JavaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为&quot;闭包&quot;。</p>\n<p>当定义一个函数时，它实际上保存了一个作用域链。当调用这个函数时，它创建\n一个新的对象来存储它的局部变量，并将这个对象添加到保存的作用域链上。</p>\n</blockquote>\n<p>(闭包可以简单的理解为函数用来存储它的局部变量的对象，这个对象我们来说是不可见的，是js解释器实现的过程中才会用到的。每一个函数都会有这样的一个对象，作用域链则是这些对象之间的关系。)</p>\n<p>&quot;闭包&quot;这个术语的来源：指函数变量可以被隐藏于作用域链之内，因此看起来是函数将变量&quot;包裹&quot;了起来。</p>\n<p>看文字可能会比较绕，下面是书中的一个例子：</p>\n<pre><code class="lang-js">var scope = &quot;global scope&quot;;            /*全局变量*/\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;        /*局部变量*/\n    function f(){return scope;}\n    return f();\n}\ncheckscope();                        /*=&gt;&quot;local scope&quot;*/\n</code></pre>\n<pre><code class="lang-js">var scope = &quot;global scope&quot;;            /*全局变量*/\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;        /*局部变量*/\n    function f(){return scope;}\n    return f;\n}\ncheckscope()();                        /*=&gt;&quot;local scope&quot;*/\n</code></pre>\n<p>checkscope最后的返回值都是一样的，即&quot;local scope&quot;。</p>\n<p>上面两个例子的不同之处就是函数f执行的地方不同，一个在checkscope这个作用域里调用的(每一个函数都是一个作用域)，一个在全局作用域里调用的。回忆之前说的，函数调用时的上下文或者说作用域是在声明时确定的，所以与调用的位置无关，即f函数的调用位置虽然不同，调用的环境虽然不同，但最终的结果都是一样的。</p>\n<p>说到这里，闭包就说得差不多了，回过头来看一下常规的对于闭包的理解：</p>\n<blockquote>\n<p>通过返回函数的形式取得函数的局部变量。</p>\n</blockquote>\n<p>这种说法本身没有错，但它只是闭包的一种表现形式，</p>\n<p>比如将上例进行下更改：</p>\n<pre><code class="lang-js">var scope = &quot;global scope&quot;;            /*全局变量*/\nfunction checkscope(fn){\n    var scope = &quot;local scope&quot;;        /*局部变量*/\n    function f(){return scope;}\n    fn(f);\n}\ncheckscope(function(func){\n    var scope = &quot;func scope&quot;;\n    return func();\n});                                    /*=&gt;&quot;local scope&quot;*/\n</code></pre>\n<p>改成类似回调的执行方式，结果还是一样的，注意结果并不是func scope，但是并没有返回f函数这一说，难道这就不是闭包了吗？(当然这里有点扣字眼)</p>\n<h3 id="-">复杂点的闭包题</h3>\n<p>真不知道按照前面那种简单的理解该怎么来理解这道题，但是如果理解了闭包的实质，那么就会发现其实很简单。</p>\n<pre><code class="lang-js">function fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      return fun(m,n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);    /*undefined,?,?,?*/\nvar b = fun(0).fun(1).fun(2).fun(3);                /*undefined,?,?,?*/\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);        /*undefined,?,?,?*/\n\n/*\n* 问:三行a,b,c的输出分别是什么？\n* 提示:形参也属于局部变量，包含在作用域中\n*/\n</code></pre>\n<p>这里就不给出答案了，自行运行即可知道结果。</p>\n<h3 id="-this">说说this</h3>\n<p>想起最开始时的那个思考题了吗？与闭包就没什么关系(注：任何一个函数其实都用到了闭包，但我们暂且考虑两层以及两层以上的嵌套情况，未嵌套情况下因为使用的都是全局作用域，结果应该是很直观的)。this一般用来代表函数的调用对象，它和上下文对象并不是同一个，上下文对象对我们来说是不可见的，除了全局作用域。</p>\n<ul>\n<li>示例01：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()());        /*The Window*/\n</code></pre>\n</li>\n<li>示例02：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　var that = this;\n　　　　　　return function(){\n　　　　　　　　return that.name;\n　　　　　　};\n　　　　}\n　　};\n var that = {name: &#39;xiaofu&#39;};            /*干扰项*/ \n　　alert(object.getNameFunc()());        /*My Object*/\n</code></pre>\n</li>\n</ul>\n<p>我们再来看一下题目，示例01输出的是&quot;The Window&quot;,示例02输出的是&quot;My Object&quot;。</p>\n<p>说明：\n示例01最终执行的是 function(){return this.name}，因为没有显示指明调用对象，所以其this执行全局对象。\n示例02先调用object.getNameFunc(),因为显示的指定了调用对象，所以内部的this是object(注：这里说的是this指向的问题，还没有说闭包)，接着执行function (){return that.name}，这个函数在getNameFunc这个函数作用域中声明的，所以它调用的时候使用的是这个作用域，即得到var that = this;的这个that;而不是外面的that。</p>\n<h3 id="-">作用域链不等同于原型链</h3>\n<p>真不知道这两个不相关的东西怎么会被等同起来看待，以后谁告诉我它们是同一个东西，我就想问了，ruby、python这种没有原型概念的语言难道就没有作用域链了吗？</p>\n<p>更有甚者将变量声明提升和闭包混在一起，也是醉了。</p>\n<h3 id="-this-">如果无法理解，但记住下面的一点使用技巧，那么遇到闭包和this时也能够轻松的应对</h3>\n<ul>\n<li>闭包：函数执行时变量的获取从声明的作用域处去获取(注意链式关系，当前没有就往父级找，知道全局作用域)</li>\n<li>this：显示指定调用者则this就指向谁，如未指定则为全局对象</li>\n</ul>\n',summary:'<hr>\n<h3 id="-">闭包只是为了实现词法作用域而用到的一种数据结构而已</h3>\n<p>先从阮一峰09年写的一篇关于闭包的文章开始<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">(原文地址)</a>文中说&quot;可以把闭包理解为就是能够读取其他函数内部变量的函数,因为js中,只有函数内部的子函数才能读取局部变量，因此也可以把闭包定义在一个函数内部的函数。所以闭包本质就是将函数内部和函数外部连接起来的一座桥梁&quot;。</p>\n<p>毕竟不是专业学习js的，也不是程序语言方面的专家，在这里就不去计较了，下文会给出更完整的闭包说明。(PS:个人还是比较欣赏阮一峰写的文章的，能将一些概念讲得通俗易懂)</p>\n<p>最后还留下了一个思考题</p>\n<ul>\n<li>示例01：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()());\n</code></pre>\n</li>\n<li>示例02：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　var that = this;\n　　　　　　return function(){\n　　　　　　　　return that.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()());\n</code></pre>\n看完这道题，就希望大家将this和闭包分开，不要给自己找麻烦？</li>\n</ul>\n'},{meta:{title:"jQuery is not must for us——事件",date:"2015-11-25T12:40:32.000Z",tags:"jquery",archives:"pl",id:"20",createTime:"2015-11-25",url:"2015-11-25-jQuery is not must for us——事件",strTag:"jquery"},content:'<hr>\n<p>在这里我们将对比Web提供的事件API与jQuery 事件函数间的差别。jQuery给我们提供了非常好的事件API,但理解好底层是如何实现的可以帮助我们更好的使用jQuery,同时遇到错误也能修复。</p>\n<ul>\n<li>发送DOM事件</li>\n<li>发送自定义事件</li>\n<li>监听事件</li>\n<li>移除事件句柄</li>\n<li>修改事件</li>\n<li>事件预测</li>\n<li>键盘事件</li>\n<li>鼠标事件</li>\n<li>浏览器加载事件</li>\n<li>老式浏览器的支持</li>\n</ul>\n<h2 id="dom-">DOM事件发送</h2>\n<p>以点击事件为例：\nfocus/blur/submit语法相同</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(a).click();\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">a.click();\n</code></pre>\n<h2 id="-">自定义事件</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">/*触发一个事件(custom-event)*/\n$(&#39;element&#39;).trigger(&#39;custom-event&#39;);\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">var event = document.createEvent(&#39;Event&#39;);\nevent.initEvent(&#39;custom-event&#39;, true, true); /*第二和第三参数说明属于冒泡事件并可取消默认事件*/\nsomeElement.dispatchEvent(event);    /*发起事件*/\n\n/*ie not support*/\nvar event = new CustomEvent(&#39;custom-event&#39;, {bubbles: true, cancelable: true});\nsomeElement.dispatchEvent(event);\n</code></pre>\n<h2 id="-">事件监听</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;element&#39;).on(&#39;click&#39;, function(){\n    /*当点击的时候做点什么*、\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">/*ie 9*/\nelement.addEventLister(&#39;click&#39;, function(){\n    /*当点击的时候做点什么*、\n})\n</code></pre>\n<h2 id="-">移除事件</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">/*jquery还提供了一个移除某元素上所有事件的api*/\n$(&#39;element&#39;).off(&#39;click&#39;, myEventHander);\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">elment.removeEventLister(&#39;click&#39;, myEventHander);\n</code></pre>\n<h2 id="-">事件修改</h2>\n<p>阻止事件冒泡</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(element).on(&#39;event&#39;, function(event){\n    event.stopPropagation();\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">element.addEventListener(&#39;event&#39;, function(event){\n    event.stopPropagation();\n})\n</code></pre>\n<p>阻止其它事件对当前元素的影响</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(element).on(&#39;event&#39;, function(event){\n    event.stopImmediatePropagation();\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">element.addEventListener(&#39;event&#39;, function(event){\n    event.stopImmediatePropagation();\n})\n</code></pre>\n<p>阻止浏览器默认事件，比如一个a标签的跳转事件</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(Aelement).on(&#39;click&#39;, function(event){\n    event.stopPropagation();\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">Aelement.addEventListener(&#39;click&#39;, function(event){\n    event.preventDefault();\n})\n</code></pre>\n<h2 id="-">预测事件</h2>\n<pre><code class="lang-html">&lt;ul id=&quot;my-list&quot;&gt;\n    &lt;li&gt;foo &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n    &lt;li&gt;bar &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n    &lt;li&gt;abc &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n    &lt;li&gt;123 &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>点击按钮的时候删除其li标签</p>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(&#39;#my-list&#39;).on(&#39;click&#39;, &#39;BUTTON&#39;, function() {\n    $(this).parent().remove();\n});\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;my-list&#39;).addEventListener(&#39;click&#39;, function(event) {\n    var clickedEl = event.target;\n    if(clickedEl.tagName === &#39;BUTTON&#39;) {\n       var listItem = clickedEl.parentNode;\n       listItem.parentNode.removeChild(listItem);\n    }\n});\n</code></pre>\n<h2 id="-">键盘事件</h2>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(document).keydown(function(event){\n    if(event.ctrlkey &amp;&amp; event.which === 72){\n        /*ctrl+H*/\n    }\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">document.addEventListener(&#39;keydown&#39;, function(event) {\n    if (event.ctrlKey &amp;&amp; event.which === 72) {\n        /*ctrl+H*/\n    }\n});\n</code></pre>\n<h2 id="-">鼠标事件</h2>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(&#39;element&#39;).hover(function hoverIn(){\n\n},\nfunction hoverOut(){\n\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">someEl.addEventListener(&#39;mouseover&#39;, function() {\n});\n\nsomeEl.addEventListener(&#39;mouseout&#39;, function() {\n});\n</code></pre>\n<h2 id="-">浏览器加载事件</h2>\n<ul>\n<li>文档加载</li>\n<li>样式加载</li>\n<li>图片加载</li>\n<li>iframes加载</li>\n</ul>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(window).load(function(){\n    /*页面加载并渲染完毕*/\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">window.addEventListener(&#39;load&#39;, function(){\n    /*页面加载并渲染完毕*/\n})\n</code></pre>\n<p>文档加载完毕但未渲染</p>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(document).ready(function(){\n    /*文档加载完毕*/\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">document.addEventListener(&#39;DOMContentLoaded&#39;,function(){\n\n})\n</code></pre>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">\n</code></pre>\n',summary:"<hr>\n<p>在这里我们将对比Web提供的事件API与jQuery 事件函数间的差别。jQuery给我们提供了非常好的事件API,但理解好底层是如何实现的可以帮助我们更好的使用jQuery,同时遇到错误也能修复。</p>\n<ul>\n<li>发送DOM事件</li>\n<li>发送自定义事件</li>\n<li>监听事件</li>\n<li>移除事件句柄</li>\n<li>修改事件</li>\n<li>事件预测</li>\n<li>键盘事件</li>\n<li>鼠标事件</li>\n<li>浏览器加载事件</li>\n<li>老式浏览器的支持</li>\n</ul>\n"},{meta:{title:"jQuery is not must for us——DOM操作",date:"2015-11-24T12:50:32.000Z",tags:"jquery",archives:"pl",id:"21",createTime:"2015-11-24",url:"2015-11-24-jQuery is not must for us——DOM操作",strTag:"jquery"},content:'<hr>\n<p>通过浏览器提供的DOM API,我们可以完成对页面元素的增删改查移动等。</p>\n<ul>\n<li>创建元素</li>\n<li>插入元素</li>\n<li>移动元素</li>\n<li>删除元素</li>\n<li>类操作</li>\n<li>属性操作</li>\n<li>文本操作</li>\n<li>样式操作</li>\n</ul>\n<h2 id="-">创建元素</h2>\n<pre><code class="lang-javascript">/*jquery*/\n    $(&#39;&lt;div&gt;&lt;/div&gt;&#39;);\n/*DOM*/\ndocument.createElement(&#39;div&#39;);\n</code></pre>\n<h2 id="-">插入元素</h2>\n<pre><code class="lang-html">&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;3&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id="-id-1-div-id-1-1-div">在id为1的div的后面插入一个id为1.1的div</h3>\n<pre><code class="lang-html">&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;01&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;3&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-javascript">/*jquery*/\n    $(&#39;#1&#39;).after(&#39;&lt;div id=&quot;1.1&quot;&gt;&lt;/div&gt;&#39;);\n/*DOM*/\ndocument.getElementById(&#39;1&#39;).insertAdjacentHTML(&#39;afterend&#39;, &#39;&lt;div id=&quot;1.1&quot;&gt;&lt;/div&gt;&#39;);\n</code></pre>\n<h3 id="-id-1-div-id-a-div">在id为1的div之前插入一个id为A的div</h3>\n<pre><code class="lang-html">&lt;div id=&quot;A&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;3&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-javascript">$(&#39;#1&#39;).before(&#39;&lt;div id=&quot;A&quot;&gt;&lt;/div&gt;&#39;);\n\n/*DOM\ndocument.getElementById(&#39;1&#39;).insertAdjacentHTML(&#39;beforebegin&#39;, &#39;&lt;div id=&quot;A&quot;&gt;&lt;/div&gt;&#39;);\n</code></pre>\n<h3 id="-">插入子元素</h3>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;oldChild&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>插入一个子元素将其变成</p>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;newChild&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;oldChild&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).prepend(&#39;&lt;div id=&quot;newChild&quot;&gt;&lt;/div&gt;&#39;);\n\n/*DOM*/\ndocument.getElementById(&#39;parent&#39;)\n    .insertAdjacentHTML(&#39;afterbegin&#39;, &#39;&lt;div id=&quot;newChild&quot;&gt;&lt;/div&gt;&#39;);\n</code></pre>\n<h2 id="-">移动元素</h2>\n<p>将下面的结构</p>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;c1&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c2&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c3&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=&quot;orphan&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>变成</p>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;c1&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c2&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c3&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;orphan&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).append(&#39;#orphan&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;parent&#39;)\n    .appendChild(document.getElementById(&#39;orphan&#39;));\n</code></pre>\n<p>如果想将id为orphan的div插入到c1</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).prepend($(&#39;#orphan&#39;));\n</code></pre>\n<pre><code class="lang-javascript">document.getElementById(&#39;parent&#39;)\n    .insertBefore(document.getElementById(&#39;orphan&#39;), document.getElementById(&#39;c1&#39;));\n</code></pre>\n<h2 id="-">移除</h2>\n<p>这里假设存在一个id为foobar的元素</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foobar&#39;).remove();\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foobar&#39;).parentNode.removeChild(document.getElementById(&quot;foobar&quot;));\n</code></pre>\n<h2 id="-class">添加和移除class</h2>\n<p>现在我们希望将</p>\n<pre><code class="lang-html">&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-html">&lt;div id=&quot;foo&quot; class=&quot;bold&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).addClass(&#39;bold&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">/*IE9有问题*/\ndocuement.getElementById(&#39;foo&#39;).classList.add(&#39;bold&#39;);\n\n/*所有浏览器都支持*/\ndocument.getElementById(&#39;foo&#39;).className += &#39;bold&#39;;\n</code></pre>\n<p>移除bold类</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).removeClass(&#39;bold&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">/*IE9有问题*/\ndocuement.getElementById(&#39;foo&#39;).classList.remove(&#39;bold&#39;);\n\n/*所有浏览器都支持\ndocument.getElementById(&#39;foo&#39;).className = document.getElementById(&#39;foo&#39;).className.replace(/^bold$/, &#39;&#39;);\n</code></pre>\n<h2 id="-">属性修改</h2>\n<p>给id=&quot;foo&quot;的元素设置role属性为button</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).attr(&#39;role&#39;, &#39;button&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foo&#39;).setAttribute(&#39;role&#39;, &#39;button&#39;);\n</code></pre>\n<p>移除我们添加的属性</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).removeAttr(&#39;role&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foo&#39;).removeAttribute(&#39;role&#39;);\n</code></pre>\n<h2 id="-">文本修改</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).text(&#39;Goodbye!&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foo&#39;).innerHTML = &#39;Goodbye!&#39;;\ndocument.getElementById(&#39;foo&#39;).innerText = &#39;GoodBye!&#39;;\n/*IE9+*/\ndocument.getElementById(&#39;foo&#39;).textContent = &#39;GoodBye!&#39;;\n</code></pre>\n<h2 id="-">样式修改</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#note&#39;).css(&#39;fontWeight&#39;, &#39;bold&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;note&#39;).style.fontWeight = &#39;bold&#39;;\n</code></pre>\n',summary:"<hr>\n<p>通过浏览器提供的DOM API,我们可以完成对页面元素的增删改查移动等。</p>\n<ul>\n<li>创建元素</li>\n<li>插入元素</li>\n<li>移动元素</li>\n<li>删除元素</li>\n<li>类操作</li>\n<li>属性操作</li>\n<li>文本操作</li>\n<li>样式操作</li>\n</ul>\n"},{meta:{title:"ES6 new features",date:"2016-01-23T15:06:36.000Z",tags:["js","pl"],id:"22",createTime:"2016-01-23",url:"2016-01-23-ES6 new features",strTag:"js、pl"},content:'<hr>\n<h2 id="es6-">ES6新语法</h2>\n<h3 id="let-const-">let、const、块级作用域</h3>\n<p>在这之前js中声明变量可以用var或是直接省略不写就可以声明一个变量，并且使用的是函数作用域。</p>\n<p>es6可以通过 let、const(常量)这两个关键字来声明变量，并且支持块级作用域。</p>\n<pre><code class="lang-js">var buttons = document.querySelectorAll(&#39;button&#39;)\n  var output = document.querySelector(&#39;#output&#39;)\n\n  for (var i = 0; i &lt; buttons.length; i++) {\n    buttons[i].addEventListener(&#39;click&#39;, function() {\n      output.innerText = buttons[i].innerText\n    })\n  }\n</code></pre>\n<p>上面这段代码会报错，因为点击事件的回调函数中的i的值都是buttons.length而不是当前循环的i.但\n如果使用 let i 的话就不会出现这个问题。</p>\n<h3 id="-">=&gt; 箭头函数</h3>\n<p>箭头函数可以把它当做匿名函数，优点就是语法简洁。</p>\n<pre><code class="lang-js">x =&gt; x\n\n(x, y) =&gt; x + y\n\nx =&gt; {\n    return x\n}\n\n(x, y) =&gt; {\n    return x + y\n}\n</code></pre>\n<h3 id="-">函数上下文</h3>\n<p>箭头函数带来的另外一个改变是函数上下文的绑定(this)，this不再是随着调用者而改变，即使使用\ncall、apply也不会改变。即函数的上下文一直都是函数声明时的上下文。</p>\n<pre><code class="lang-js">name = &quot;xiaofu&quot;;\nage = 20;\nvar obj = {\n        name: &quot;yang&quot;,\n        age: 17,\n        getName: function(){\n            var name = () =&gt; {\n                return this.name;\n            }\n            return name;\n        },\n        getAge: function(){\n            var age = function(){\n                return this.age;\n            }\n            return age;\n        }\n    }\nvar person = {\n    name: &#39;cat&#39;,\n    age: 28\n}\nmyname = obj.getName();\nmyage = obj.getAge();\nconsole.log(myname());                /*yang*/\nconsole.log(myage())                /*20*/\nconsole.log(myname.call(person));    /*yang*/\nconsole.log(myage.call(person));    /*28*/\n</code></pre>\n<p>从上面我们可以发现箭头函数输出的一直都是声明的上下文即 obj 对象。</p>\n<p>注：let const 带来了变量的作用域改变，而箭头函数带来了this指向的改变。而且我觉得这两个改变使js\n与其它主流的语言更接近。</p>\n<h3 id="-">模板字符串</h3>\n<ul>\n<li>支持变量注入</li>\n<li>支持换行</li>\n</ul>\n<blockquote>\n<p>ruby中就很好的支持这个特性。</p>\n</blockquote>\n<p>模板使我们不在需要使用 &#39;+&#39; 来拼接字符串。</p>\n<pre><code class="lang-js">let name = &#39;yangxiaofu&#39;;\nlet company = &#39;jikexueyuan&#39;;\n\nlet greet = `Hi, I am ${name}, I am working at ${company}`\nconsole.log(greet) /* Hi, I am yangxiaofu, I am working at jikexueyuan*/\n</code></pre>\n<p>如果使用es5, 那么我们需要这样做：</p>\n<pre><code class="lang-js">var name = &#39;yangxiaofu&#39;;\nvar company = &#39;jikexueyuan&#39;;\n\nvar greet = &quot;Hi, I am &quot; + name &quot;, I am working at &quot;;\n    greet += company;\nconsole.log(greet) /* Hi, I am yangxiaofu, I am working at jikexueyuan*/\n</code></pre>\n<h3 id="-function-">函数作为属性时可用省略 function 关键字</h3>\n<pre><code class="lang-js">let person = {\n    //es5\n    getName: function(){\n        return &#39;person&#39;;\n    },\n    //es6\n    getAge(){\n        return &#39;age&#39;;\n    }\n}\n</code></pre>\n<p>不过我还是看着之前的写法比较习惯， function 关键字让我一眼就知道它是一个函数，\n不过省略的写法的确简洁不少。</p>\n<h3 id="-">多重赋值</h3>\n<pre><code class="lang-js">let [x, y] = [30, 20];\n</code></pre>\n<h3 id="-">默认值参数</h3>\n<pre><code class="lang-js">//es6\nfunction person(name = &quot;name&quot;){\n    return name;\n}\n\n//es5\nfunction person(name){\n    name = name || &quot;name&quot;;\n}\n</code></pre>\n<p>上面是es5的一种常用的默认值赋值方式，但当传入的值为 false 的情况下则无法达到预想的结果。</p>\n<h3 id="-args-arguments">...args 替代 arguments</h3>\n<pre><code class="lang-js">/*es5*/\nfunction method01() {\n  var args = [].slice.apply(arguments)\n\n}\nfunction method02(name) {\n  var args = [].slice.apply(arguments, 1)\n\n}\n\n/*es6*/\nfunction method01(...args) {\n\n}\nfunction method02(name, ...args) {\n\n}\n</code></pre>\n<h3 id="class">class</h3>\n<p>本质还是函数</p>\n<pre><code class="lang-js">class Cat{}\n/*\n* [Function: Cat]\n*/\n\nclass Person {\n  constructor(name, height, age) {\n    this.name = name;\n    this.height = height;\n    this.age = age;\n  }\n\n  toStr() {\n    return `my name is ${this.name}`;\n  }\n}\n\nvar  me = new Person(&#39;yangxiaofu&#39;, 180, 19)\nconsole.log(me.toStr()) /*my name is yangxiaofu*/\n</code></pre>\n<p>不足：无法直接设置类变量，这在其他原生支持类的语言中是可以的</p>\n<pre><code class="lang-js">class Person{\n    let parent = &#39;parents&#39;;    //wrong\n    constructor(name){\n        this.name = name;\n    }\n}\n</code></pre>\n<p>上面给类添加一个parent变量的写法是错误的。</p>\n<h3 id="-">类继承</h3>\n<pre><code class="lang-js">\nclass Animal{\n    eat(){\n        console.log(&#39;eating something&#39;);\n    }\n}\n\nclass Cat extends Animal{\n    constructor(name){\n        super()\n        this.name = name;\n    }\n}\n\nvar cat = new Cat(&#39;cat&#39;);\ncat.eat();\n</code></pre>\n<p>使用extends关键字以及 super 方法，super方法必须在 this使用之前调用。</p>\n<h3 id="-static-">可以通过static定义静态方法</h3>\n<pre><code class="lang-js">class Animal{\n    eat(){\n        console.log(&#39;eating something&#39;);\n    }\n}\n\nclass Cat extends Animal{\n    constructor(name){\n        super()\n        this.name = name;\n    }\n\n    static get fullname(){\n        return &#39;cat animal&#39;;\n    }\n}\n\nvar cat = new Cat(&#39;cat&#39;);\nconsole.log(Cat.fullname);\n</code></pre>\n<p>与c++这样的语言相比，类的特性还比较少。</p>\n',summary:'<hr>\n<h2 id="es6-">ES6新语法</h2>\n<h3 id="let-const-">let、const、块级作用域</h3>\n<p>在这之前js中声明变量可以用var或是直接省略不写就可以声明一个变量，并且使用的是函数作用域。</p>\n<p>es6可以通过 let、const(常量)这两个关键字来声明变量，并且支持块级作用域。</p>\n<p>```js\nvar buttons = document.querySelectorAll(&#39;button&#39;)\n  var output = document.querySelector(&#39;#output&#39;)</p>\n<p>  for (var i</p>\n'},{meta:{title:"轮播图，So easy",date:"2015-11-25T15:36:51.000Z",archives:"pl",tags:["css","js","jquery","插件"],id:"23",createTime:"2015-11-25",url:"2015-11-25-轮播图，So easy",strTag:"css、js、jquery、插件"},content:'<hr>\n<h2 id="-">轮播效果预览</h2>\n<p><style>iframe{width: 100%;min-height: 400px;}</style></p>\n<iframe src="/compents/galler/index.html" frameborder="0"></iframe>\n\n\n\n\n\n<h3 id="-">结构布局</h3>\n<p>三层布局：</p>\n<p>——page-wrapp\n—— ——item-wrap[轮播效果是通过这一层的滚动实现的]\n—— —— ——sub-item</p>\n<p>说明：</p>\n<ul>\n<li>page-wrapp作为轮播盒子框架，即限定可见区域</li>\n<li>item-wrap作为轮播外层的盒子</li>\n<li>sub-item作为每一个轮播图的盒子</li>\n</ul>\n<p>1 .page-wrapp的宽高等于sub-item的宽高,page-wrapp的overflow属性设为hidden,这样超出page-wrap范围的将是不可见的\n2 .item-wrap的宽度等于sub-item的总宽度，,多个sub-item并排[可以用浮动的方式实现],高度等于sub-item的高度.\n3 .这样虽然item-wrap的宽度大于page-wrapp的宽度，但因为page-wrapp设置了overflow:hidden,所以也只能显示一张图片的大小。\n4 .为了得到轮播的效果这时可以使用动画将item-wrap在水平方向平移，也就得到了轮播的效果</p>\n<pre><code class="lang-html">&lt;div class=&quot;page-wrapp&quot;&gt;\n    &lt;div class=&quot;item-wrap&quot;&gt;\n        &lt;div class=&quot;sub-item&quot;&gt;\n            &lt;img src=&quot;/img/compents/background01.jpg&quot; alt=&quot;&quot; class=&quot;img-item&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;sub-item&quot;&gt;\n            &lt;img src=&quot;/img/compents/cat-cartoon.jpg&quot; alt=&quot;&quot; class=&quot;img-item&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;sub-item&quot;&gt;\n            &lt;img src=&quot;/img/compents/cup.jpg&quot; alt=&quot;&quot; class=&quot;img-item&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;sub-item&quot;&gt;\n            &lt;img src=&quot;/img/compents/leaf.jpg&quot; alt=&quot;&quot; class=&quot;img-item&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;sub-item&quot;&gt;\n            &lt;img src=&quot;/img/compents/nature01.jpg&quot; alt=&quot;&quot; class=&quot;img-item&quot;&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>css样式</p>\n<pre><code class="lang-css">/*这里的样式是针对全屏设置的，最外层的轮播框架宽高在此设为浏览器窗口的大小*/\n.page-wrapper,\n    .page-wrapper .item-wrap,\n    .page-wrapper .sub-item,\n    .page-wrapper .sub-item .img-item {\n        position: relative;\n        height: 100%;\n    }\n\n    .page-wrapper {\n        min-width: 720px;\n        min-height: 500px;\n        overflow: hidden;\n        zoom: 1;\n    }\n\n    .page-wrapper .item-wrap {\n        /*因为有5个子元素，所以宽度是5个子元素之和[子元素和父级的宽度是相等的],所以总宽度为父级的5倍*/\n        width: 500%;\n        overflow: hidden;\n        zoom: 1;\n    }\n\n    .page-wrapper .sub-item {\n        float: left;\n        width: 20%;\n    }\n\n    .page-wrapper .sub-item .img-item {\n        width: 100%;\n    }\n</code></pre>\n<h3 id="-">轮播动画实现</h3>\n<p>添加轮播按钮，点击时触发轮播事件</p>\n<pre><code class="lang-html">&lt;!-- 轮播按钮 --&gt;\n&lt;div class=&quot;left-btn-wrap&quot;&gt;\n    &lt;span class=&quot;silder-left-btn&quot; id=&quot;leftBtn&quot;&gt;&lt;/span&gt;\n&lt;/div&gt;\n&lt;div class=&quot;right-btn-wrap&quot;&gt;\n    &lt;span class=&quot;silder-right-btn&quot; id=&quot;rightBtn&quot;&gt;&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>\n<p>这里可以使用jQuery的animate动效实现轮播效果</p>\n<pre><code class="lang-javascript">/*左滚动\n参数说明：\n$itemWrap=$(&#39;.item-wrap&#39;); 轮播外层盒子\n*/\n$leftBtn.on(&#39;click&#39;, function(){\n    $itemWrap.animate({\n        &#39;margin-left&#39;: 0 - $imgItems.width()\n    }, 1000, function(){\n        /*轮播一次就动态的将第一个图片元素移到最后，变成最后一张图片，这样可以实现无限循环的效果*/\n        $itemWrap.append($(&#39;.item-wrap .sub-item&#39;).first());\n        $itemWrap.css(&quot;margin-left&quot;,0);\n    })\n}）\n\n/*右滚动*/\n$rightBtn.on(&#39;click&#39;, function(){\n    $itemWrap.prepend($(&#39;#itemWrap .sub-item&#39;).last());\n        $itemWrap.css(&quot;margin-left&quot;,0 - $imgItems.width());\n    $itemWrap.animate({\n        &#39;margin-left&#39;: 0\n    }, 1000)\n}）\n</code></pre>\n<p>这样就可以实现一个简单的轮播图的效果，上面给出的事例还带有轮播导航条[右下角],这可以通过增加一个data-index属性来记录轮播索引位置。</p>\n<p>注：这中做法每旋转一次就需要动态的修改DOM结构，另一种思路是将第一屏copy到最后的方式来实现无缝衔接</p>\n<p><a href="/compents/galler/index.html">查看完整demo</a></p>\n<p>github:<a href="https://github.com/xiaofuzi/gallery">https://github.com/xiaofuzi/gallery</a></p>\n',
summary:'<hr>\n<h2 id="-">轮播效果预览</h2>\n<p><style>iframe{width: 100%;min-height: 400px;}</style></p>\n<iframe src="/compents/galler/index.html" frameborder="0"></iframe>\n\n'},{meta:{title:"jQuery is not must for us——事件",date:"2015-11-25T12:40:32.000Z",tags:"jquery",archives:"pl",id:"24",createTime:"2015-11-25",url:"2015-11-25-jQuery is not must for us——事件",strTag:"jquery"},content:'<hr>\n<p>在这里我们将对比Web提供的事件API与jQuery 事件函数间的差别。jQuery给我们提供了非常好的事件API,但理解好底层是如何实现的可以帮助我们更好的使用jQuery,同时遇到错误也能修复。</p>\n<ul>\n<li>发送DOM事件</li>\n<li>发送自定义事件</li>\n<li>监听事件</li>\n<li>移除事件句柄</li>\n<li>修改事件</li>\n<li>事件预测</li>\n<li>键盘事件</li>\n<li>鼠标事件</li>\n<li>浏览器加载事件</li>\n<li>老式浏览器的支持</li>\n</ul>\n<h2 id="dom-">DOM事件发送</h2>\n<p>以点击事件为例：\nfocus/blur/submit语法相同</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(a).click();\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">a.click();\n</code></pre>\n<h2 id="-">自定义事件</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">/*触发一个事件(custom-event)*/\n$(&#39;element&#39;).trigger(&#39;custom-event&#39;);\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">var event = document.createEvent(&#39;Event&#39;);\nevent.initEvent(&#39;custom-event&#39;, true, true); /*第二和第三参数说明属于冒泡事件并可取消默认事件*/\nsomeElement.dispatchEvent(event);    /*发起事件*/\n\n/*ie not support*/\nvar event = new CustomEvent(&#39;custom-event&#39;, {bubbles: true, cancelable: true});\nsomeElement.dispatchEvent(event);\n</code></pre>\n<h2 id="-">事件监听</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;element&#39;).on(&#39;click&#39;, function(){\n    /*当点击的时候做点什么*、\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">/*ie 9*/\nelement.addEventLister(&#39;click&#39;, function(){\n    /*当点击的时候做点什么*、\n})\n</code></pre>\n<h2 id="-">移除事件</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">/*jquery还提供了一个移除某元素上所有事件的api*/\n$(&#39;element&#39;).off(&#39;click&#39;, myEventHander);\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">elment.removeEventLister(&#39;click&#39;, myEventHander);\n</code></pre>\n<h2 id="-">事件修改</h2>\n<p>阻止事件冒泡</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(element).on(&#39;event&#39;, function(event){\n    event.stopPropagation();\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">element.addEventListener(&#39;event&#39;, function(event){\n    event.stopPropagation();\n})\n</code></pre>\n<p>阻止其它事件对当前元素的影响</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(element).on(&#39;event&#39;, function(event){\n    event.stopImmediatePropagation();\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">element.addEventListener(&#39;event&#39;, function(event){\n    event.stopImmediatePropagation();\n})\n</code></pre>\n<p>阻止浏览器默认事件，比如一个a标签的跳转事件</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(Aelement).on(&#39;click&#39;, function(event){\n    event.stopPropagation();\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">Aelement.addEventListener(&#39;click&#39;, function(event){\n    event.preventDefault();\n})\n</code></pre>\n<h2 id="-">预测事件</h2>\n<pre><code class="lang-html">&lt;ul id=&quot;my-list&quot;&gt;\n    &lt;li&gt;foo &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n    &lt;li&gt;bar &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n    &lt;li&gt;abc &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n    &lt;li&gt;123 &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>点击按钮的时候删除其li标签</p>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(&#39;#my-list&#39;).on(&#39;click&#39;, &#39;BUTTON&#39;, function() {\n    $(this).parent().remove();\n});\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;my-list&#39;).addEventListener(&#39;click&#39;, function(event) {\n    var clickedEl = event.target;\n    if(clickedEl.tagName === &#39;BUTTON&#39;) {\n       var listItem = clickedEl.parentNode;\n       listItem.parentNode.removeChild(listItem);\n    }\n});\n</code></pre>\n<h2 id="-">键盘事件</h2>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(document).keydown(function(event){\n    if(event.ctrlkey &amp;&amp; event.which === 72){\n        /*ctrl+H*/\n    }\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">document.addEventListener(&#39;keydown&#39;, function(event) {\n    if (event.ctrlKey &amp;&amp; event.which === 72) {\n        /*ctrl+H*/\n    }\n});\n</code></pre>\n<h2 id="-">鼠标事件</h2>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(&#39;element&#39;).hover(function hoverIn(){\n\n},\nfunction hoverOut(){\n\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">someEl.addEventListener(&#39;mouseover&#39;, function() {\n});\n\nsomeEl.addEventListener(&#39;mouseout&#39;, function() {\n});\n</code></pre>\n<h2 id="-">浏览器加载事件</h2>\n<ul>\n<li>文档加载</li>\n<li>样式加载</li>\n<li>图片加载</li>\n<li>iframes加载</li>\n</ul>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(window).load(function(){\n    /*页面加载并渲染完毕*/\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">window.addEventListener(&#39;load&#39;, function(){\n    /*页面加载并渲染完毕*/\n})\n</code></pre>\n<p>文档加载完毕但未渲染</p>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(document).ready(function(){\n    /*文档加载完毕*/\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">document.addEventListener(&#39;DOMContentLoaded&#39;,function(){\n\n})\n</code></pre>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">\n</code></pre>\n',summary:"<hr>\n<p>在这里我们将对比Web提供的事件API与jQuery 事件函数间的差别。jQuery给我们提供了非常好的事件API,但理解好底层是如何实现的可以帮助我们更好的使用jQuery,同时遇到错误也能修复。</p>\n<ul>\n<li>发送DOM事件</li>\n<li>发送自定义事件</li>\n<li>监听事件</li>\n<li>移除事件句柄</li>\n<li>修改事件</li>\n<li>事件预测</li>\n<li>键盘事件</li>\n<li>鼠标事件</li>\n<li>浏览器加载事件</li>\n<li>老式浏览器的支持</li>\n</ul>\n"},{meta:{title:"javascript 闭包、this",date:"2016-01-25T15:06:36.000Z",tags:["js","pl"],id:"25",createTime:"2016-01-25",url:"2016-01-25-javascript 闭包、this",strTag:"js、pl"},content:'<hr>\n<blockquote>\n<p>闭包其实很好理解，但是由于经常把this和闭包绑在一起，从而加大了理解的难度，如果将他们分开考虑，那就清晰多了。</p>\n</blockquote>\n<h2 id="-">闭包</h2>\n<p>闭包并不是js首创，在许多语言中都支持闭包，如schemer、ruby等。如果没有闭包，像js这样的支持高阶函数特性的语言将是一个噩梦。</p>\n<ul>\n<li>静态作用域</li>\n<li>动态作用域</li>\n</ul>\n<pre><code class="lang-js">var name = &quot;xiaofu&quot;;\nvar person = function(lastname){\n    var name = &#39;yang&#39;;\n\n    function personName(){\n        return name + lastname;\n    }\n    return personName;\n}\nvar pName = person();\npName(&quot;xiaoming&quot;);\n</code></pre>\n<p>js是函数作用域的，即一个function就是一个作用域，所以personName在person这个函数的作用域里面。但是调用的是在这个作用域的外面，那么当personName执行的时候，它里面的name取的是person这个作用域还是最外层的作用域呢？</p>\n<p>如果是静态作用域则调用的是person里面的 name, 如果是动态作用域则调用的是外层的name(&quot;xiaofu&quot;);而不是&quot;yang&quot;。</p>\n<p>而闭包就是用来实现静态作用域的一种方式，即通过闭包将函数和它声明时的作用域保存下来，这样在调用的时候取到的就是声明时所在的作用域而不是调用时的作用域。</p>\n<h2 id="this">this</h2>\n<p>this则与变量有点不同，即this采用的是类似于动态作用域的情况。js里面一切都是对象，所以函数也都是某个对象的方法，如果没有显示指定则是全局对象。</p>\n<pre><code class="lang-js">var person = {\n    fullname: function{\n        console.log(this);\n    },\n    printAge: function(){\n        console.log(this);\n    }\n}\nperson.fullname();        //this指向person\nvar age = person.printAge;\nage();                    //this指向window(浏览器中)\n</code></pre>\n<p>将person.printAge赋值给age之后，再执行age(),此时age没有显示指定调用对象则默认是window(浏览器环境)。所以this并不是声明所在的环境。</p>\n<h2 id="-es6-">箭头函数（es6)</h2>\n<p>es6中新增了箭头函数，箭头函数与通过function声明的函数不同，它的this是使用的声明时上下文中的this.并且不可通过apply, call等改变。</p>\n',summary:'<hr>\n<blockquote>\n<p>闭包其实很好理解，但是由于经常把this和闭包绑在一起，从而加大了理解的难度，如果将他们分开考虑，那就清晰多了。</p>\n</blockquote>\n<h2 id="-">闭包</h2>\n<p>闭包并不是js首创，在许多语言中都支持闭包，如schemer、ruby等。如果没有闭包，像js这样的支持高阶函数特性的语言将是一个噩梦。</p>\n<ul>\n<li>静态作用域</li>\n<li>动态作用域</li>\n</ul>\n<pre><code class="lang-js">var name = &quot;xiaofu&quot;;\nvar person = function(lastname){\n    var name = &#39;yang&#39;;\n\n    function personName(){\n        return name + lastname;\n    }\n    return personName;\n}\nvar pName = person();\npName(&quot;xiaoming&quot;);\n</code></pre>\n<p>js是函数作用域的，即一个function就是一个作用域，所以personName在person这个函数的作用域里面。但是调用的是在这个作用域的外面，那么当personName执行的时候，它里面的name取的是person这个作用域还是最外层的作用域呢？</p>\n<p>如果是静态作用域则调用的是person里面的 name, 如果是动态作用域则调用的是外层的name(&quot;xiaofu&quot;);而不是&quot;yang&quot;。</p>\n<p>而闭包就是用来实现静态作用域的一种方式，即通过闭包将函数和它声明时的作用域保存下来，这样在调用的时候取到的就是声明时所在的作用域而不是调用时的作用域。</p>\n'},{meta:{title:"简单的dom库和轻量级mvvm框架的尝试",date:"2016-02-21T19:07:19.000Z",tags:["js"],id:"26",createTime:"2016-02-22",url:"2016-02-22-简单的dom库和轻量级mvvm框架的尝试",strTag:"js"},content:'<hr>\n<p>很早之前就有去jquery化的打算，但一直在犹豫，直到最近用原生的写的越来越多，所以将jquery的功能抽取出来，封装了一个简单的 dom 库。jquery是一个非常好的库，使用非常方便，但随着浏览器兼容性越来越好，jquery也显得并不是那么必要。除此之外，现在热门的前端框架大多不依赖于jquery,而是使用原生的js或是自己封装一个小的库，原生的js能带来一定速度上的提升，同时编码量也并不比使用jquery多多少，所以个人觉得去jquery也将成为一个趋势。</p>\n<p>mvvm最近特别火，仿佛不熟悉某一款框架都不好出去见人了，自己也用了许多，一直没有特别顺手的。一直也想写一个组件式的库或框架，在筹备的过程中一直没有好的思路，所以索性先模仿其它框架来写，再从中体会。本次参考angularJS写了一个微型的框架，从中也做了不少改进，本着轻框架的原则，将更多的逻辑交由用户去做，即只在常规的css+html+js的基础上做些改进.虽然如此离实际使用还是有距离，不过再写的过程中却发现不少问题，所以说造轮子其实也是很有意义的。</p>\n<h3 id="tiny-js-a-simple-dom-libary-">tiny.js(a simple dom libary)</h3>\n<p>暂且就这么命名好了，功能上还是参考了jquery的很多特性，同时也做了不少的改进。</p>\n<h3 id="-">特性</h3>\n<ul>\n<li>链式调用</li>\n<li>获取单一 dom 元素</li>\n<li>拟人化的api</li>\n<li>函数式编程</li>\n</ul>\n<h2 id="api-doc-">api doc:</h2>\n<h3 id="core">core</h3>\n<ul>\n<li>DOM</li>\n<li>all</li>\n<li>each</li>\n<li>map</li>\n</ul>\n<h3 id="dom">dom</h3>\n<ul>\n<li>val</li>\n<li>clone</li>\n<li>append</li>\n<li>prepend</li>\n<li>after</li>\n<li>before</li>\n<li>remove</li>\n<li>prev</li>\n<li>next</li>\n<li>siblings</li>\n<li>addClass</li>\n<li>removeClass</li>\n<li>toggleClass</li>\n<li>hasClass</li>\n<li>attr</li>\n<li>removeAttr</li>\n<li>text</li>\n<li>html</li>\n<li>replaceWith</li>\n</ul>\n<h3 id="css">css</h3>\n<ul>\n<li>css</li>\n<li>height</li>\n<li>width</li>\n<li>innerHeight</li>\n<li>innerWidth</li>\n<li>outHeight</li>\n<li>outWidth</li>\n<li>position</li>\n<li>viewportPostion</li>\n<li>scrollTop</li>\n<li>scrollLeft</li>\n</ul>\n<h3 id="event">event</h3>\n<ul>\n<li>on</li>\n<li>off</li>\n<li>trigger</li>\n<li>triggerCustom</li>\n</ul>\n<h3 id="ajax">ajax</h3>\n<ul>\n<li>getJSON</li>\n<li>post</li>\n<li>get</li>\n</ul>\n<h3 id="animation">animation</h3>\n<ul>\n<li>fadeIn</li>\n<li>fadeOut</li>\n<li>hide</li>\n<li>show</li>\n</ul>\n<p>待完善\ngithub: <a href="https://github.com/xiaofuzi/tiny.js">https://github.com/xiaofuzi/tiny.js</a></p>\n<h2 id="con-js">con.js</h2>\n<p>核心思想： 给声明式的html增添逻辑编程的能力。</p>\n<p>大多数情况下的web页面使用html+css+js就可以，不需要过多的库和框架，这三者的结合其实能满足大部分的需求，但富web应用还是显得有些不足，需要手动的不断的反复的更新dom,但如果只是因为一张页面上需要几个功能比较复杂的组件就去引入框架又显得有些没有必要，所以说大多数情况下需要的是轻量化的框架。</p>\n<h3 id="-">特性</h3>\n<ul>\n<li>通过指令，给html增加上下文的概念(如同函数的上下文)</li>\n<li>双向数据绑定</li>\n<li>angular式的脏检查更新数据</li>\n<li>模板语法</li>\n<li>静态数据类型</li>\n</ul>\n<p>more and more.....</p>\n<p>github: <a href="https://github.com/xiaofuzi/con.js">https://github.com/xiaofuzi/con.js</a></p>\n',summary:"<hr>\n<p>很早之前就有去jquery化的打算，但一直在犹豫，直到最近用原生的写的越来越多，所以将jquery的功能抽取出来，封装了一个简单的 dom 库。jquery是一个非常好的库，使用非常方便，但随着浏览器兼容性越来越好，jquery也显得并不是那么必要。除此之外，现在热门的前端框架大多不依赖于jquery,而是使用原生的js或是自己封装一个小的库，原生的js能带来一定速度上的提升，同时编码量也并不比使用jquery多多少，所以个人觉得去jquery也将成为一个趋势。</p>\n<p>mvvm最近特别火</p>\n"},{meta:{title:"基于NodeJS实现的一个css预处理器",date:"2015-12-14T15:36:51.000Z",tags:["nodeJS","开源项目"],id:"27",createTime:"2015-12-14",url:"2015-12-14-基于NodeJS实现的一个css预处理器",strTag:"nodeJS、开源项目"},content:'<hr>\n<div class="header-preview" style=""><h2>json_script,基于nodeJS实现的css预处理器</h2><p>just for fun?</p></div>\n\n<p>一时兴起，想用json格式来编写css，然后就出现了json_script.json是一种十分简洁的数据格式，学过javascript的人都会用，现在已作为web中传递数据的一种主要的数据格式，所以也有很多时候需要将json格式的数据转换成css、html。既然如此，为什么不能直接将json转为web页面呢？web页面基本上是由css/html/javascript组成的，所以可以用json或是javascript来直接生成一张web页面那不是很方便？</p>\n<h2 id="just-for-fun-">just for fun?</h2>\n<p>虽然只是因为有趣，但我还是发现有人已经做出了这样的东西，而且还很不错。但依然不影响我去做这样一个东西的兴趣，这也是在web组件化上探索的一步。</p>\n<div><a href="https://github.com/xiaofuzi/json_script" target="_blank"><img style="position: fixed; top: -7px; right: 0; border: 0;z-index: 999;" src="https://i.alipayobjects.com/e/201211/1dbSqT9ykm.png" width="149" height="149" alt="Fork me on GitHub"></a></div>\n\n<h2 id="-">原理？</h2>\n<p>这里得益于json这种数据格式非常简洁，已经不再需要正则这种进行数据提取。因为它已经自带了很好的结构化的信息。</p>\n<ul>\n<li>传入json格式数据</li>\n<li>转换为中间数据格式(css是不支持嵌套的，转换成不嵌套的格式)</li>\n<li>生成css格式数据</li>\n</ul>\n<h3 id="json">json</h3>\n<pre><code class="lang-javascript">{\n    &#39;.wrap&#39;: {\n        &#39;margin-top&#39;: &#39;20px&#39;,\n        &#39;padding&#39;: &#39;20px&#39;,\n        &#39;color&#39;: &#39;#444&#39;,\n        p: {\n            &#39;padding-top&#39;: &#39;20px&#39;,\n            &#39;font-size&#39;: &#39;28px&#39;\n        }\n    }\n}\n</code></pre>\n<h3 id="-json_css">中间格式-json_css</h3>\n<pre><code class="lang-javascript">{\n    &#39;.wrap&#39;: {\n        &#39;margin-top&#39;: &#39;20px&#39;,\n        &#39;padding&#39;: &#39;20px&#39;,\n        &#39;color&#39;: &#39;#444&#39;,\n        p: false\n    }\n    &#39;.wrap p&#39;: {\n            &#39;padding-top&#39;: &#39;20px&#39;,\n            &#39;font-size&#39;: &#39;28px&#39;\n        }\n}\n</code></pre>\n<h3 id="css-">css格式</h3>\n<pre><code class="lang-javascript">.wrap {\n  margin-top: 20px;\n  padding: 20px;\n  color: #444;\n}\n.wrap p {\n  padding-top: 20px;\n  font-size: 28px;\n}\n</code></pre>\n<h2 id="-">如何安装</h2>\n<pre><code class="lang-git">npm install --save json_script\n</code></pre>\n<p>全局安装</p>\n<pre><code class="lang-git">npm install json_script -g\n</code></pre>\n<p>项目介绍: <a href="http://yangxiaofu.com/json_script/readme.html">http://yangxiaofu.com/json_script/readme.html</a>\ngithub: <a href="https://github.com/xiaofuzi/json_script">https://github.com/xiaofuzi/json_script</a></p>\n',summary:'<hr>\n<div class="header-preview" style=""><h2>json_script,基于nodeJS实现的css预处理器</h2><p>just for fun?</p></div>\n\n<p>一时兴起，想用json格式来编写css，然后就出现了json_script.json是一种十分简洁的数据格式，学过javascript的人都会用，现在已作为web中传递数据的一种主要的数据格式，所以也有很多时候需要将json格式的数据转换成css、html。既然如此，为什么不能直接将json转为web页面呢？web页面基本上是由css/html/javascript组成的，所以可以用json或是javascript来直接生成一张web页面那不是很方便？</p>\n<h2 id="just-for-fun-">just for fun?</h2>\n<p>虽然只是因为有趣，但我还是发现有人已经做出了这样的东西，而且还很不错。但依然不影响我去做这样一个东西的兴趣，这也是在web组件化上探索的一步。</p>\n'},{meta:{title:"jQuery is not must for us--元素选取",date:"2015-11-28T11:40:32.000Z",tags:"jquery",archives:"pl",id:"28",createTime:"2015-11-28",url:"2015-11-28-jQuery is not must for us--元素选取",strTag:"jquery"},content:'<hr>\n<h2 id="-">元素选择</h2>\n<p>1 .ID\n2 .class\n3 .Tag\n4 .Attributes\n5 .伪类\n6 .孩子选择器\n7 .后代选择器\n8 .排除选择器\n9 .多组选择器</p>\n<h3 id="id">ID</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;#myElement&quot;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.getElementById(&quot;myElement&quot;);\n/*IE 8+*/\ndocument.querySelector(&#39;#myElement&#39;);\n</code></pre>\n<h3 id="class">class</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;.myElement&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">/*ie 9+*/\ndocument.getElementsByClassNmae(&#39;.myElement&#39;);\n/*ie 8+*/\ndocument.querySelectorAll(&#39;.myElement&#39;);\n</code></pre>\n<h3 id="tag">Tag</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;div&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.getElementsByTagName(&#39;div&#39;);\n/**ie 8+/\ndocument.querySelectorAll(&#39;div&#39;);\n</code></pre>\n<h3 id="attribute-">Attribute[属性]</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;[data-bar=&quot;red-bar&quot;&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">/*ie 8+*/\ndocument.querySelectorAll(&#39;[data-bar=&quot;red-bar&quot;&#39;);\n</code></pre>\n<h3 id="-">伪类</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;#myForm:invalid&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">//IE 10+\ndocument.querySelectorAll(&#39;#myForm:invalid&#39;)\n</code></pre>\n<h3 id="-">孩子选择器</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).children();\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">/*会返回注释和文本节点*/\ndocument.getElementById(&#39;parent&#39;).childNodes\n/*ie 9+ 忽略注释和文本节点*/\ndocument.getElementById(&#39;parent&#39;).children;\n</code></pre>\n<p>选择包含ng-click属性的子节点</p>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).children(&#39;[ng-click]&#39;);\n$(&#39;#parent &gt; [ng-click]&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.querySelector(&#39;#parent &gt; [ng-click]&#39;);\n</code></pre>\n<h3 id="-">后代选择</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;#parent a&quot;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.querySelectorAll(&quot;#parent a&quot;);\n</code></pre>\n<h3 id="-">排除选择</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;div&quot;).not(&#39;.ignore&#39;);\n$(&#39;div:not(.ignore)&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">documenet.querySelectorAll(&#39;div:not(.ignore)&#39;);\n</code></pre>\n<h3 id="-">多重选择</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;DIV, A, SCRIPT&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.querySelectorAll(&#39;DIV, A, SCRIPT&#39;);\n</code></pre>\n<h3 id="jquery-">jQuery选择器模拟</h3>\n<pre><code class="lang-javascript">window.$ = function(selector) {\n    var selectorType = &#39;querySelectorAll&#39;;\n\n    if (selector.indexOf(&#39;#&#39;) === 0) {\n        selectorType = &#39;getElementById&#39;;\n        selector = selector.substr(1, selector.length);\n    }\n\n    return document[selectorType](selector);\n};\n</code></pre>\n',summary:'<hr>\n<h2 id="-">元素选择</h2>\n<p>1 .ID\n2 .class\n3 .Tag\n4 .Attributes\n5 .伪类\n6 .孩子选择器\n7 .后代选择器\n8 .排除选择器\n9 .多组选择器</p>\n<h3 id="id">ID</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;#myElement&quot;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.getElementById(&quot;myElement&quot;);\n/*IE 8+*/\ndocument.querySelector(&#39;#myElement&#39;);\n</code></pre>\n'},{meta:{title:"jQuery is not must for us--元素选取",date:"2015-11-28T11:40:32.000Z",tags:"jquery",archives:"pl",id:"29",createTime:"2015-11-28",url:"2015-11-28-jQuery is not must for us--元素选取",strTag:"jquery"},content:'<hr>\n<h2 id="-">元素选择</h2>\n<p>1 .ID\n2 .class\n3 .Tag\n4 .Attributes\n5 .伪类\n6 .孩子选择器\n7 .后代选择器\n8 .排除选择器\n9 .多组选择器</p>\n<h3 id="id">ID</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;#myElement&quot;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.getElementById(&quot;myElement&quot;);\n/*IE 8+*/\ndocument.querySelector(&#39;#myElement&#39;);\n</code></pre>\n<h3 id="class">class</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;.myElement&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">/*ie 9+*/\ndocument.getElementsByClassNmae(&#39;.myElement&#39;);\n/*ie 8+*/\ndocument.querySelectorAll(&#39;.myElement&#39;);\n</code></pre>\n<h3 id="tag">Tag</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;div&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.getElementsByTagName(&#39;div&#39;);\n/**ie 8+/\ndocument.querySelectorAll(&#39;div&#39;);\n</code></pre>\n<h3 id="attribute-">Attribute[属性]</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;[data-bar=&quot;red-bar&quot;&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">/*ie 8+*/\ndocument.querySelectorAll(&#39;[data-bar=&quot;red-bar&quot;&#39;);\n</code></pre>\n<h3 id="-">伪类</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;#myForm:invalid&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">//IE 10+\ndocument.querySelectorAll(&#39;#myForm:invalid&#39;)\n</code></pre>\n<h3 id="-">孩子选择器</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).children();\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">/*会返回注释和文本节点*/\ndocument.getElementById(&#39;parent&#39;).childNodes\n/*ie 9+ 忽略注释和文本节点*/\ndocument.getElementById(&#39;parent&#39;).children;\n</code></pre>\n<p>选择包含ng-click属性的子节点</p>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).children(&#39;[ng-click]&#39;);\n$(&#39;#parent &gt; [ng-click]&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.querySelector(&#39;#parent &gt; [ng-click]&#39;);\n</code></pre>\n<h3 id="-">后代选择</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;#parent a&quot;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.querySelectorAll(&quot;#parent a&quot;);\n</code></pre>\n<h3 id="-">排除选择</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;div&quot;).not(&#39;.ignore&#39;);\n$(&#39;div:not(.ignore)&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">documenet.querySelectorAll(&#39;div:not(.ignore)&#39;);\n</code></pre>\n<h3 id="-">多重选择</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;DIV, A, SCRIPT&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.querySelectorAll(&#39;DIV, A, SCRIPT&#39;);\n</code></pre>\n<h3 id="jquery-">jQuery选择器模拟</h3>\n<pre><code class="lang-javascript">window.$ = function(selector) {\n    var selectorType = &#39;querySelectorAll&#39;;\n\n    if (selector.indexOf(&#39;#&#39;) === 0) {\n        selectorType = &#39;getElementById&#39;;\n        selector = selector.substr(1, selector.length);\n    }\n\n    return document[selectorType](selector);\n};\n</code></pre>\n',summary:'<hr>\n<h2 id="-">元素选择</h2>\n<p>1 .ID\n2 .class\n3 .Tag\n4 .Attributes\n5 .伪类\n6 .孩子选择器\n7 .后代选择器\n8 .排除选择器\n9 .多组选择器</p>\n<h3 id="id">ID</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;#myElement&quot;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.getElementById(&quot;myElement&quot;);\n/*IE 8+*/\ndocument.querySelector(&#39;#myElement&#39;);\n</code></pre>\n'}],total:38}}],error:null,serverRendered:!0}</script><script defer src="/nuxt-blog/_nuxt/vendor.bundle.js"></script><script defer src="/nuxt-blog/_nuxt/nuxt.bundle.js"></script>