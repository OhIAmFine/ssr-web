<!DOCTYPE html><html n-head=""n-head-ssr><meta n-head="true"charset="utf-8"><meta n-head="true"content="width=device-width,initial-scale=1"name="viewport"><meta n-head="true"content="ffe blog"name="description"hid="description"><title n-head="true">Archive list</title><link href="/favicon.ico"rel="icon"n-head="true"type="image/x-icon"><link href="http://cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"rel="stylesheet"n-head="true"><base href="/ssr-web/"><link href="/ssr-web/_nuxt/style.css"rel="stylesheet"><body n-head=""><div id="__nuxt"server-rendered="true"><div class="progress"data-v-1ef32859 style="width:0;height:2px;background-color:#000;opacity:0"></div><div class="wrapper"><nav class="main-menu navbar navbar-default"><div class="container"><div class="logo"><a href="/"><h2>ffe</h2></a></div><div class="nav-item"><ul class="nav navbar-nav navbar-right"><li><a href="/">Home</a><li><a href="/page/1">Posts</a><li><a href="/about">About</a></ul></div></div></nav><section class="container page-wrapper"data-v-f6bdeb56><div class="pageWrap"data-v-f6bdeb56><ul data-v-f6bdeb56><li data-v-f6bdeb56><a href="/posts/2"data-v-f6bdeb56>jQuery is not must for us——DOM操作</a><li data-v-f6bdeb56><a href="/posts/3"data-v-f6bdeb56>jQuery is not must for us--元素选取</a><li data-v-f6bdeb56><a href="/posts/4"data-v-f6bdeb56>jQuery is not must for us——异步请求</a><li data-v-f6bdeb56><a href="/posts/5"data-v-f6bdeb56>Javascript-类-模块化</a><li data-v-f6bdeb56><a href="/posts/6"data-v-f6bdeb56>javascript 闭包、this</a><li data-v-f6bdeb56><a href="/posts/7"data-v-f6bdeb56>ES6 new features</a><li data-v-f6bdeb56><a href="/posts/8"data-v-f6bdeb56>react/react-native代码规范实践</a><li data-v-f6bdeb56><a href="/posts/9"data-v-f6bdeb56>再谈对闭包的理解</a><li data-v-f6bdeb56><a href="/posts/10"data-v-f6bdeb56>Coding form zero</a><li data-v-f6bdeb56><a href="/posts/11"data-v-f6bdeb56>松本行弘的程序世界——编程语言知多少</a><li data-v-f6bdeb56><a href="/posts/12"data-v-f6bdeb56>booker.js,一个web-book 生成工具</a><li data-v-f6bdeb56><a href="/posts/13"data-v-f6bdeb56>CommonJS模块加载工具实现</a><li data-v-f6bdeb56><a href="/posts/14"data-v-f6bdeb56>基于NodeJS实现的一个css预处理器</a><li data-v-f6bdeb56><a href="/posts/15"data-v-f6bdeb56>轮播图，So easy</a><li data-v-f6bdeb56><a href="/posts/16"data-v-f6bdeb56>图片延迟加载简单实现</a><li data-v-f6bdeb56><a href="/posts/17"data-v-f6bdeb56>jQuery is not must for us——事件</a><li data-v-f6bdeb56><a href="/posts/18"data-v-f6bdeb56>简单的dom库和轻量级mvvm框架的尝试</a><li data-v-f6bdeb56><a href="/posts/19"data-v-f6bdeb56>帽子还是蛇，黑匣子真是我们需要的吗？</a><li data-v-f6bdeb56><a href="/posts/20"data-v-f6bdeb56>jQuery is not must for us</a><li data-v-f6bdeb56><a href="/posts/21"data-v-f6bdeb56>js lexer and highlighting</a><li data-v-f6bdeb56><a href="/posts/22"data-v-f6bdeb56>不要再说正则表达式学不会，其实很简单</a><li data-v-f6bdeb56><a href="/posts/23"data-v-f6bdeb56>前端代码规范</a><li data-v-f6bdeb56><a href="/posts/24"data-v-f6bdeb56>The Little Schemer——read again</a><li data-v-f6bdeb56><a href="/posts/25"data-v-f6bdeb56>css特殊图形绘制</a><li data-v-f6bdeb56><a href="/posts/26"data-v-f6bdeb56>html不能这么写，你知道吗？</a><li data-v-f6bdeb56><a href="/posts/27"data-v-f6bdeb56>静态服务器搭建</a><li data-v-f6bdeb56><a href="/posts/28"data-v-f6bdeb56>简单cssHack了解，让ie支持H5、css3</a><li data-v-f6bdeb56><a href="/posts/29"data-v-f6bdeb56>css3简易魔方绘制</a><li data-v-f6bdeb56><a href="/posts/30"data-v-f6bdeb56>使用inline-block与浮动前需要了解这些</a><li data-v-f6bdeb56><a href="/posts/31"data-v-f6bdeb56>前端开发环境搭建</a><li data-v-f6bdeb56><a href="/posts/32"data-v-f6bdeb56>what's is yeoman</a><li data-v-f6bdeb56><a href="/posts/33"data-v-f6bdeb56>CSS3布局</a></ul></div></section><footer class="footer">Visit our website for more documentation : <a href="https://github.com/xiaofuzi/ssr-web"target="_blank">ssr-web</a></footer></div></div><script defer>window.__NUXT__={data:[{posts:{data:[{meta:{title:"jQuery is not must for us——DOM操作",date:"2015-11-24T12:50:32.000Z",tags:"jquery",archives:"pl",id:"2",createTime:"2015-11-24",url:"2015-11-24-jQuery is not must for us——DOM操作",strTag:"jquery"},content:'<hr>\n<p>通过浏览器提供的DOM API,我们可以完成对页面元素的增删改查移动等。</p>\n<ul>\n<li>创建元素</li>\n<li>插入元素</li>\n<li>移动元素</li>\n<li>删除元素</li>\n<li>类操作</li>\n<li>属性操作</li>\n<li>文本操作</li>\n<li>样式操作</li>\n</ul>\n<h2 id="-">创建元素</h2>\n<pre><code class="lang-javascript">/*jquery*/\n    $(&#39;&lt;div&gt;&lt;/div&gt;&#39;);\n/*DOM*/\ndocument.createElement(&#39;div&#39;);\n</code></pre>\n<h2 id="-">插入元素</h2>\n<pre><code class="lang-html">&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;3&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id="-id-1-div-id-1-1-div">在id为1的div的后面插入一个id为1.1的div</h3>\n<pre><code class="lang-html">&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;01&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;3&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-javascript">/*jquery*/\n    $(&#39;#1&#39;).after(&#39;&lt;div id=&quot;1.1&quot;&gt;&lt;/div&gt;&#39;);\n/*DOM*/\ndocument.getElementById(&#39;1&#39;).insertAdjacentHTML(&#39;afterend&#39;, &#39;&lt;div id=&quot;1.1&quot;&gt;&lt;/div&gt;&#39;);\n</code></pre>\n<h3 id="-id-1-div-id-a-div">在id为1的div之前插入一个id为A的div</h3>\n<pre><code class="lang-html">&lt;div id=&quot;A&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;\n&lt;div id=&quot;3&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-javascript">$(&#39;#1&#39;).before(&#39;&lt;div id=&quot;A&quot;&gt;&lt;/div&gt;&#39;);\n\n/*DOM\ndocument.getElementById(&#39;1&#39;).insertAdjacentHTML(&#39;beforebegin&#39;, &#39;&lt;div id=&quot;A&quot;&gt;&lt;/div&gt;&#39;);\n</code></pre>\n<h3 id="-">插入子元素</h3>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;oldChild&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>插入一个子元素将其变成</p>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;newChild&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;oldChild&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).prepend(&#39;&lt;div id=&quot;newChild&quot;&gt;&lt;/div&gt;&#39;);\n\n/*DOM*/\ndocument.getElementById(&#39;parent&#39;)\n    .insertAdjacentHTML(&#39;afterbegin&#39;, &#39;&lt;div id=&quot;newChild&quot;&gt;&lt;/div&gt;&#39;);\n</code></pre>\n<h2 id="-">移动元素</h2>\n<p>将下面的结构</p>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;c1&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c2&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c3&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=&quot;orphan&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>变成</p>\n<pre><code class="lang-html">&lt;div id=&quot;parent&quot;&gt;\n    &lt;div id=&quot;c1&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c2&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;c3&quot;&gt;&lt;/div&gt;\n    &lt;div id=&quot;orphan&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).append(&#39;#orphan&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;parent&#39;)\n    .appendChild(document.getElementById(&#39;orphan&#39;));\n</code></pre>\n<p>如果想将id为orphan的div插入到c1</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).prepend($(&#39;#orphan&#39;));\n</code></pre>\n<pre><code class="lang-javascript">document.getElementById(&#39;parent&#39;)\n    .insertBefore(document.getElementById(&#39;orphan&#39;), document.getElementById(&#39;c1&#39;));\n</code></pre>\n<h2 id="-">移除</h2>\n<p>这里假设存在一个id为foobar的元素</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foobar&#39;).remove();\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foobar&#39;).parentNode.removeChild(document.getElementById(&quot;foobar&quot;));\n</code></pre>\n<h2 id="-class">添加和移除class</h2>\n<p>现在我们希望将</p>\n<pre><code class="lang-html">&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-html">&lt;div id=&quot;foo&quot; class=&quot;bold&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).addClass(&#39;bold&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">/*IE9有问题*/\ndocuement.getElementById(&#39;foo&#39;).classList.add(&#39;bold&#39;);\n\n/*所有浏览器都支持*/\ndocument.getElementById(&#39;foo&#39;).className += &#39;bold&#39;;\n</code></pre>\n<p>移除bold类</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).removeClass(&#39;bold&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">/*IE9有问题*/\ndocuement.getElementById(&#39;foo&#39;).classList.remove(&#39;bold&#39;);\n\n/*所有浏览器都支持\ndocument.getElementById(&#39;foo&#39;).className = document.getElementById(&#39;foo&#39;).className.replace(/^bold$/, &#39;&#39;);\n</code></pre>\n<h2 id="-">属性修改</h2>\n<p>给id=&quot;foo&quot;的元素设置role属性为button</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).attr(&#39;role&#39;, &#39;button&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foo&#39;).setAttribute(&#39;role&#39;, &#39;button&#39;);\n</code></pre>\n<p>移除我们添加的属性</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).removeAttr(&#39;role&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foo&#39;).removeAttribute(&#39;role&#39;);\n</code></pre>\n<h2 id="-">文本修改</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#foo&#39;).text(&#39;Goodbye!&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;foo&#39;).innerHTML = &#39;Goodbye!&#39;;\ndocument.getElementById(&#39;foo&#39;).innerText = &#39;GoodBye!&#39;;\n/*IE9+*/\ndocument.getElementById(&#39;foo&#39;).textContent = &#39;GoodBye!&#39;;\n</code></pre>\n<h2 id="-">样式修改</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;#note&#39;).css(&#39;fontWeight&#39;, &#39;bold&#39;);\n</code></pre>\n<h3 id="dom">DOM</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;note&#39;).style.fontWeight = &#39;bold&#39;;\n</code></pre>\n',summary:"<hr>\n<p>通过浏览器提供的DOM API,我们可以完成对页面元素的增删改查移动等。</p>\n<ul>\n<li>创建元素</li>\n<li>插入元素</li>\n<li>移动元素</li>\n<li>删除元素</li>\n<li>类操作</li>\n<li>属性操作</li>\n<li>文本操作</li>\n<li>样式操作</li>\n</ul>\n"},{meta:{title:"jQuery is not must for us--元素选取",date:"2015-11-28T11:40:32.000Z",tags:"jquery",archives:"pl",id:"3",createTime:"2015-11-28",url:"2015-11-28-jQuery is not must for us--元素选取",strTag:"jquery"},content:'<hr>\n<h2 id="-">元素选择</h2>\n<p>1 .ID\n2 .class\n3 .Tag\n4 .Attributes\n5 .伪类\n6 .孩子选择器\n7 .后代选择器\n8 .排除选择器\n9 .多组选择器</p>\n<h3 id="id">ID</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;#myElement&quot;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.getElementById(&quot;myElement&quot;);\n/*IE 8+*/\ndocument.querySelector(&#39;#myElement&#39;);\n</code></pre>\n<h3 id="class">class</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;.myElement&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">/*ie 9+*/\ndocument.getElementsByClassNmae(&#39;.myElement&#39;);\n/*ie 8+*/\ndocument.querySelectorAll(&#39;.myElement&#39;);\n</code></pre>\n<h3 id="tag">Tag</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;div&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.getElementsByTagName(&#39;div&#39;);\n/**ie 8+/\ndocument.querySelectorAll(&#39;div&#39;);\n</code></pre>\n<h3 id="attribute-">Attribute[属性]</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;[data-bar=&quot;red-bar&quot;&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">/*ie 8+*/\ndocument.querySelectorAll(&#39;[data-bar=&quot;red-bar&quot;&#39;);\n</code></pre>\n<h3 id="-">伪类</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;#myForm:invalid&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">//IE 10+\ndocument.querySelectorAll(&#39;#myForm:invalid&#39;)\n</code></pre>\n<h3 id="-">孩子选择器</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).children();\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">/*会返回注释和文本节点*/\ndocument.getElementById(&#39;parent&#39;).childNodes\n/*ie 9+ 忽略注释和文本节点*/\ndocument.getElementById(&#39;parent&#39;).children;\n</code></pre>\n<p>选择包含ng-click属性的子节点</p>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;#parent&#39;).children(&#39;[ng-click]&#39;);\n$(&#39;#parent &gt; [ng-click]&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.querySelector(&#39;#parent &gt; [ng-click]&#39;);\n</code></pre>\n<h3 id="-">后代选择</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;#parent a&quot;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.querySelectorAll(&quot;#parent a&quot;);\n</code></pre>\n<h3 id="-">排除选择</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;div&quot;).not(&#39;.ignore&#39;);\n$(&#39;div:not(.ignore)&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">documenet.querySelectorAll(&#39;div:not(.ignore)&#39;);\n</code></pre>\n<h3 id="-">多重选择</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&#39;DIV, A, SCRIPT&#39;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.querySelectorAll(&#39;DIV, A, SCRIPT&#39;);\n</code></pre>\n<h3 id="jquery-">jQuery选择器模拟</h3>\n<pre><code class="lang-javascript">window.$ = function(selector) {\n    var selectorType = &#39;querySelectorAll&#39;;\n\n    if (selector.indexOf(&#39;#&#39;) === 0) {\n        selectorType = &#39;getElementById&#39;;\n        selector = selector.substr(1, selector.length);\n    }\n\n    return document[selectorType](selector);\n};\n</code></pre>\n',summary:'<hr>\n<h2 id="-">元素选择</h2>\n<p>1 .ID\n2 .class\n3 .Tag\n4 .Attributes\n5 .伪类\n6 .孩子选择器\n7 .后代选择器\n8 .排除选择器\n9 .多组选择器</p>\n<h3 id="id">ID</h3>\n<h4 id="jquery">jQuery</h4>\n<pre><code class="lang-javascript">$(&quot;#myElement&quot;);\n</code></pre>\n<h4 id="dom-api">DOM API</h4>\n<pre><code class="lang-javascript">document.getElementById(&quot;myElement&quot;);\n/*IE 8+*/\ndocument.querySelector(&#39;#myElement&#39;);\n</code></pre>\n'},{meta:{title:"jQuery is not must for us——异步请求",date:"2015-11-24T12:40:32.000Z",tags:"jquery",archives:"pl",id:"4",createTime:"2015-11-24",url:"2015-11-24-jQuery is not must for us——异步请求",strTag:"jquery"},content:'<hr>\n<p>jQuery对象只是对XMLHttpRequest对象进行了封装，真正的异步请求还是由浏览器发起的。</p>\n<ul>\n<li>GET</li>\n<li>POST</li>\n<li>URL Encode</li>\n<li>JSON</li>\n<li>Uploading</li>\n<li>CORS</li>\n<li>JSONP</li>\n</ul>\n<h2 id="get-">GET请求</h2>\n<p>在这里我们向服务器发起一个请求，给服务器传一个id参数然后希望服务器传回该id的用户名。</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">/*常用的jquery get请求方式*/\n$.ajax(&#39;myservice/username&#39;, {\n    data: {\n    id: &#39;unique_id&#39;\n    }\n})\n.then(\nfunction success(name){\n    alert(&quot;用户名是：&quot; + name);\n},\nfunction fail(data, status){\n    alert(&quot;请求失败. Return status of &quot; + status);\n})\n</code></pre>\n<h3 id="-xmlhttprequest-">原生XMLHttpRequest对象实现</h3>\n<pre><code class="lang-javascript">var xhr = new XMLHttpRequest();\nxhr.open(&#39;GET&#39;, encodeURL(&#39;myservice/username?id=unique_id&#39;));\nxhr.onload = function(){\n    if(xhr.status === 200){\n    alert(&quot;用户名是：&quot; + xhr.responseText);\n}\nelse{\n    alert(&#39;Request failed. Return status of &#39; + xhr.status);\n}\n};\nxhr.send();\n</code></pre>\n<h2 id="post">POST</h2>\n<p>post用来向服务器传送数据，这里我们传入一个用户id和新用户名，希望服务器完成对该用户的修改同时会返回修改的内容。</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">var newName = &#39;yangxiaofu&#39;;\n$.ajax(&#39;myservice/username?&#39; + $.param({id: &#39;unique_id&#39;}),\n{    method: &#39;POST&#39;,\n    data: {\n        name: newName\n    }\n})\n.then(\n    function sucess(name){\n    if(name !== newName){\n        alert(&quot;something wrong. Name is now &quot; + name);\n    }\n},\nfunction fail(data, status){\n    alert(&#39;Request failed. Returned status of &#39; + status);\n}\n);\n</code></pre>\n<h3 id="-xmlhttprequest-">原生XMLHttpRequest对象实现</h3>\n<pre><code class="lang-javascript">var newName = &quot;yangxiaofu&quot;,\n    xhr = new XMLHttpRequest();\n\nxhr.open(&quot;POST&quot;,\n    encodeURI(&#39;myservice/username?id=unique_id&#39;));\n    xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencode&#39;);\n    xhr.onload = function(){\n        if(xhr.status === 200 &amp;&amp; xhr.responseText !== newName){\n        alert(&#39;Something went wrong.  Name is now &#39; + xhr.responseText);\n    } else if (xhr.status !== 200) {\n        alert(&#39;Request failed.  Returned status of &#39; + xhr.status);\n    }\n};\nxhr.send(encodeURI(&#39;name=&#39; + newName));\n</code></pre>\n<h3 id="url-encoding">URL Encoding</h3>\n<p>将一个对象转换成URL编码的字符串</p>\n<pre><code class="lang-javascript">$.param({\n    key1: &quot;value1&quot;,\n    &#39;key2&#39;: &quot;value2&quot;\n});\n</code></pre>\n<p>我们可以用encodeURL和encodeURLComponent来实现同样的功能,如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。</p>\n<pre><code class="lang-javascript">function param(obj){\n    var encodedString = &#39;&#39;;\n    for(var prop in object){\n        if(object.hasOwnProperty(prop)){\n            if(encodedString.length &gt; 0){\n                encodedString += &#39;&amp;&#39;;\n            }\n            encodedString += encodeURL(prop + &#39;=&#39; + object[prop]);\n        }\n    }\n    return encodedString;\n}\n</code></pre>\n<h2 id="-">文件上传</h2>\n<p>首先我们应该明确，IE9及之前的版本如果要上传文件的话只能通过form表单，即如下的形式</p>\n<pre><code class="lang-html">&lt;input type=&quot;file&quot;&gt;\n</code></pre>\n<p>通过浏览器提供的文件API ,我们可以通过两种方式上传文件：</p>\n<ul>\n<li>使用multipart/form-data形式的表单</li>\n<li>将文件数据存放在请求体中</li>\n</ul>\n<p>通过下面的表单提交文件</p>\n<pre><code class="lang-html">&lt;input type=&quot;file&quot; id=&quot;test-input&quot;&gt;\n</code></pre>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">var file = $(&#39;#test-input&#39;)[0].files[0],\n    formData = new FormData();\n\nformData.append(&#39;file&#39;, file);\n\n$.ajax(&#39;myserver/uploads&#39;,{\n    method: &#39;POST&#39;,\n    contentType: false,\n    processData: false,\n    data: formData\n});\n\n/*直接提交文件数据*/\n$.ajax(&#39;myserver/uploads&#39;,{\n    method: &#39;POST&#39;,\n    contentType: file.type,\n    processData: false,    /*避免jquery使用URL encode的形式对文件数据进行编码*/\n    data: file\n})\n</code></pre>\n<h3 id="xmlhttprequest">XMLHttpRequest</h3>\n<pre><code class="lang-javascript">/*multipart编码形式*/\nvar formData = new FormData(),\n    file = document.getElementById(&#39;test-input&#39;).files[0],\n    xhr = new XMLHttpRequest();\n\nformData.append(&#39;file&#39;, file);\nxhr.open(&#39;POST&#39;, &#39;myserver/uploads&#39;);\nxhr.send(formData);\n\n/*将文件数据以request body的形式提交*/\nvar file = document.getElementById(&#39;test-input&#39;).files[0],\n    xhr = new XMLHttpRequest();\n\n    xhr.open(&#39;POST&#39;, &#39;myserver/uploads&#39;);\n    xhr.setRequestHeader(&#39;Content-Type&#39;, file.type);\n    xhr.send(file);\n</code></pre>\n',summary:"<hr>\n<p>jQuery对象只是对XMLHttpRequest对象进行了封装，真正的异步请求还是由浏览器发起的。</p>\n<ul>\n<li>GET</li>\n<li>POST</li>\n<li>URL Encode</li>\n<li>JSON</li>\n<li>Uploading</li>\n<li>CORS</li>\n<li>JSONP</li>\n</ul>\n"},{meta:{title:"Javascript-类-模块化",date:"2015-12-08T15:06:36.000Z",tags:["js"],id:"5",createTime:"2015-12-08",url:"2015-12-08-Javascript-类-模块化",strTag:"js"},content:'<hr>\n<div class="text-center" style="background:#414141;font-size: 48px;padding:40px 0;color:#ffffff;">Learn OOP -prototype<p style="font-size: 16px;">这里并不吹嘘面向对象有多牛，但作为现在主流的一种编程范式，我们有必要去了解。</p></div>\n\n<h2 id="-">目录</h2>\n<ul>\n<li><a href="#Javascript面向对象实现">Javascript面向对象实现</a><ul>\n<li><a href="#封装">封装</a></li>\n<li><a href="#继承">继承</a></li>\n<li><a href="#原始类型与复合类型说明">原始类型与复合类型说明</a></li>\n<li><a href="#继承实现">继承实现</a></li>\n<li><a href="#Mix-in">Mix-in</a></li>\n</ul>\n</li>\n<li><a href="#模块化">模块化</a></li>\n</ul>\n<p>Javascript是基于原型的编程语言，并不是面向对象的语言。</p>\n<p class="text-important">ES6已实现class关键字，这让js看起来更像一门面向对象的语言</p>\n\n\n\n\n<p>主流语言类型：</p>\n<ul>\n<li>基于原型的语言</li>\n<li>面向过程的语言</li>\n<li>面向对象的语言</li>\n<li>函数式的语言</li>\n</ul>\n<p>每一种语言的编程方式以及语法都会有所不同。</p>\n<p>虽然Javascript并没有内置的类的实现，但可以模拟。Javascript有构造函数和new运算符，我们可以通过构造函数来实例化一个对象。</p>\n<p>当使用new关键字来调用构造函数时，执行上下文变成一个空的上下文，这个上下文代表了新生成的实例，所以this指向当前创建的实例。</p>\n<p>面向对象应该是现在使用最广的一种编程思想<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">不了解的点此，需自备梯子</a></p>\n<p>说到面向对象，首先让我想起的是C++，在我的印象里，C++是一门严格遵循面向对象思想的一门语言，封装、继承、多态。不仅如此，还支持多继承，这是其它很多语言没有做到的。</p>\n<h2 id="javascript-">Javascript面向对象实现</h2>\n<p>说到面向对象，最直观的就是通过 class 关键字来声明，因为js还没实现该关键字(ES6已实现)，在这里我们直接用构造函数来模拟即可。(以C++为例，在生成一个对象的时候也是去调用构造函数来创建对象的)</p>\n<p>面向对象的三个特点：</p>\n<ul>\n<li>封装</li>\n<li>继承</li>\n<li>多态</li>\n</ul>\n<h3 id="-animal-">创建一个Animal类</h3>\n<pre><code class="lang-javascript">var Animal = function(){\n    /*属性*/\n    this.name = &quot;animal&quot;;\n\n    /*方法[函数、方法，在这里为什么不称为函数而称之为方法？]*/\n    this.talk = function(){\n        console.log(&quot;what&#39;s your name?&quot;);\n    }\n}\n</code></pre>\n<h3 id="-">实例化对象</h3>\n<pre><code class="lang-javascript">var Cat = new Animal;\nvar Dog = new Animal;\n</code></pre>\n<p>实例化一个对象时一般会需要进行初始化设置，这里可以通过构造函数传参实现</p>\n<pre><code class="lang-javascript">var Animal = function(name){\n    /*属性*/\n    this.name = name || &quot;Animal&quot;;\n\n    /*方法*/\n    this.talk = function(){\n        console.log(&quot;My name is: &quot;, name);\n    }\n}\n\nvar cat = new Animal(&quot;Cat&quot;);    /*名字是Cat*/\nvar dog = new Animal(&quot;Dog&quot;);    /*名字是Dog*/\n</code></pre>\n<p class="text-important">说明:</p>\n\n<pre><code class="lang-javascript">var name;\nname = pname || &quot;Animal&quot;;\n/*与下面的功能等同*/\nvar name;\nif(pname){\n    name = pname;\n}else{\n    name = &quot;Animal&quot;;\n}\n</code></pre>\n<p>这是js的一种默认值设置技巧，当pname == undefined时，name赋值为 &quot;Animal&quot;,否则name等于pname</p>\n<h3 id="-">封装</h3>\n<p>封装也叫数据抽象，将数据和处理数据的方法结合起来，对数据的处理和操作只能通过事先定义好的方法来进行。</p>\n<pre><code class="lang-javascript">var Animal = function(name, age, weight, height){\n    /*属性:名字、年龄、体重、身高*/\n    this.name = name || &quot;Animal&quot;;\n    this.age = age || 0;\n    this.weight = weight || 0;\n    this.height = height || 0;\n\n\n    /*方法*/\n    /*输出对象信息*/\n    this.introduce = function(){\n        console.log(&quot;name: &quot;, this.name, &quot;age: &quot;, this.age, &quot;weight: &quot;, this.weight, &quot;height: &quot;, this.height);\n    }\n    /*设置对象属性*/\n    this.setMyself = function(name, age, weight, height){\n        this.name = name || this.name;\n        this.age = age || this.age;\n        this.weight = weight || this.weight;\n        this.height = height || this.height;\n    }\n}\n/*实例化的对象自带的方法*/\nvar cat = new Animal(&quot;Cat&quot;);    /*名字是Cat*/\n\ncat.introduce();        /*输出：name:  Cat age:  0 weight:  0 height:  0*/\ncat.setMyself(&quot;cat&quot;, &quot;18&quot;, &quot;50kg&quot;, &quot;170cm&quot;);\ncat.introduce();        /*这时输出: name:  cat age:  18 weight:  50kg height:  170cm*/\n</code></pre>\n<p>上面我们给Animal设置了四个属性：名字、年龄、体重、身高;两个个方法：introduce(), setMyself();\n在这里我们对Animal做了封装即数据的抽象,类的数据部分由四个属性构成，方法则是处理部分.这里我们通过introduce()和setMyself()方法来输出、设置属性的值。</p>\n<p class="text-important">注(javasript语言自身的一些特点)：</p>\n\n<ul>\n<li><p>1.从上面的代码我们可以看到，this无处不在，也正是通过this才实现了类到对象的传递。Does it must？</p>\n</li>\n<li><p>2.主流的边长语言中都会有private/protect/public这三个参数来控制继承关系中变量的作用域，但是js中没有，对此我们需要进行一定的处理</p>\n</li>\n<li><p>3.js函数的参数是灵活可变[声明的参数与传入的参数不强制要求相同]\n  因为js函数参数的这种特点，一般我们传入一个对象作为参数，如：{name: &quot;cat&quot;, age: &quot;18&quot;, wight: &quot;50kg&quot;, height: &quot;170cm&quot;}</p>\n</li>\n</ul>\n<h4 id="-this">无处不在的this</h4>\n<p>这里为了更清晰，我们将代码稍稍简化一下(从程序的健壮性来说，对参数的合法性进行验证是很有必要的)：</p>\n<pre><code class="lang-javascript">var Animal = function(name, age, weight, height){\n    /*属性:名字、年龄、体重、身高*/\n    this.name = name;\n    this.age = age;\n\n    /*这里我们使用局部变量来声明体重和身高属性*/\n    var weight = weight;\n    var height = height;\n\n\n    /*方法*/\n    /*输出对象信息*/\n    this.introduce = function(){\n        /*这里的weight和height不需要用this.weight/this/height的形式来调用*/\n        console.log(this);    /*谁调用，this就指向谁,这里是实例化的对象调用，则指向该对象*/\n        /*这里的weight和height不需要用this.weight/this/height的形式来调用*/\n        console.log(&quot;name: &quot;, this.name, &quot;age: &quot;, this.age, &quot;weight: &quot;, weight, &quot;height: &quot;, height);\n    }\n    /*设置对象属性*/\n    this.setMyself = function(name, age, pweight, pheight){\n        this.name = name;\n        this.age = age;\n        /*为什么改成pweight, pheight,当形参和函数所在上下文的变量冲突时，函数内部是取不到变量的\n        这种情况下，这两个都是形参，而不是我们上面声明的局部变量，所以在此将变量名称更改为不同的值。\n        weight = weight;\n        height = height;\n        */\n        weight = pweight;\n        height = pheight;\n    }\n}\n\n/*实例化的对象自带的方法*/\nvar cat = new Animal(&quot;cat&quot;, &quot;18&quot;, &quot;50kg&quot;, &quot;170cm&quot;);    /*名字是Cat*/\n\ncat.introduce();\ncat.setMyself(&quot;cat&quot;, &quot;28&quot;, &quot;70kg&quot;, &quot;180cm&quot;);\ncat.introduce();\n</code></pre>\n<p>输出结果：</p>\n<pre><code class="lang-javascript">name:  cat age:  18 weight:  50kg height:  170cm\nname:  cat age:  28 weight:  70kg height:  180cm\n\n/*cat对象的值,并没有包括weight和height*/\n{\n    name: &quot;cat&quot;, \n    age: &quot;28&quot;,\n    this.introduce: function(){...},\n    this.setMyself: function(){...}\n}\n</code></pre>\n<p>从这里我们可以得出结论：</p>\n<ul>\n<li>实例化的对象得到的是挂载在构造函数this下的属性和方法(new 关键字的作用是返回一个新的对象并将this指向该对象)。所以为了将属性和方法传递给实例化的对象，我们就需要将属性和方法挂在this下。</li>\n<li>闭包,这里虽然weight和height并没有挂在构造函数的this下，但实例化的对象cat却能够通过introduce()方法访问到,这就是闭包的作用，要理解闭包，需要清除两点。<ul>\n<li>函数调用时上下文是声明时所在的上下文(introduce()声明的作用域是Animal构造函数，可以访问局部变量weight/height)</li>\n<li>函数内部的this指向的是调用者(调用cat.introduce():所以introduce内部的this指向cat对象)\n这样虽然实力话的对象(cat)不能访问weight和height变量，却可以通过introcuce方法来访问。</li>\n</ul>\n</li>\n</ul>\n<h3 id="-private-protect-public-">继承作用域限制(private/protect/public)</h3>\n<ul>\n<li>private声明：类本身可以访问</li>\n<li>protect声明：子类可以访问</li>\n<li>public声明：对象可以访问</li>\n</ul>\n<p>从上面this的分析我们可以知道，因为构造函数的this即指向实例化的对象，所以对象是可以直接访问属性的，即可以这样写:</p>\n<pre><code class="lang-javascript">cat.name;\ncat.age;\n</code></pre>\n<p>那么挂载在this下的即相当于public声明，通过闭包形式实现的则类似于privite,对象只能通过继承而来的方法来访问变量。这样我们就可以简单的模拟公共变量和私有变量。</p>\n<p>注：闭包会造成作用域不能及时的释放，所以不易大量的使用。</p>\n<p>一种比较简单的做法是通过&quot;_&quot;的形式来声明私有变量，这需要人为的约定遵从。如：</p>\n<pre><code class="lang-javasript">this._name;\nthis._age;\n</code></pre>\n<p>并不是真正意义上的私有变量，只是让它看起来像私有变量。我们依然可以通过cat._name的形式来访问。</p>\n<p>protect形式的用得并不太多，这里就不考虑了。</p>\n<h4 id="-">参数说明</h4>\n<p>javascript是一门动态、弱类型的语言。我们不需要预先声明变量的类型，这非常的灵活但有时也会造成类型的混乱。同时javascript函数的参数非常的灵活，\n形参和实参并不需要一一对应的关系。所以为确保程序能够正确的运行，我们往往需要对参数进行验证。</p>\n<p>在此基础上，我们可以通过传递Object对象作为参数的方式来编写，</p>\n<pre><code class="lang-javascript">var Animal = function(obj){\n    /*属性:名字、年龄、体重、身高*/\n    this.name = &quot;Animal&quot;;\n    this.age = 0;\n    this.weight = 0;\n    this.height = 0;\n\n    /*初始化方法*/\n    this.initial = function(obj){\n        this.name = obj[&#39;name&#39;] || this.name;\n        this.age = obj[&#39;age&#39;] || this.age;\n        this.weight = obj[&#39;weight&#39;] || this.weight;\n        this.height = obj[&#39;height&#39;] || this.height;\n    }\n\n    /*方法*/\n    /*输出对象信息*/\n    this.introduce = function(){\n        console.log(&quot;name: &quot;, this.name, &quot;age: &quot;, this.age, &quot;weight: &quot;, this.weight, &quot;height: &quot;, this.height);\n    }\n}\n/*实例化的对象自带的方法*/\nvar cat = new Animal({name: &#39;Cat&#39;});    /*名字是Cat*/\n\ncat.introduce();\ncat.initial({name:&quot;cat&quot;,age: &quot;18&quot;,weight: &quot;50kg&quot;,height: &quot;170cm&quot;});\n</code></pre>\n<h3 id="-">继承</h3>\n<p>类和对象的关系已经实现了继承，即对象会继承类的特性。更进一步，因为都是对象，所以可以直接赋值</p>\n<pre><code class="lang-javascript">/*新建一个cat对象*/\ncat = new Animal;\n/*将cat对象拷贝给redCat,这样redCat也具有了cat的属性和方法*/\nredCat = cat;\n</code></pre>\n<p>这种方式只是更改了名字而已，它们其实还是同一个对象，redCat的操作等同于cat进行的操作</p>\n<h3 id="-">原始类型与复合类型说明</h3>\n<ul>\n<li>原始值：按值传递 string/number/boolean/null/undefined 注:null和undefine是不同的.</li>\n<li>复合类型：按引用传递 object/array/function</li>\n</ul>\n<pre><code class="lang-javascript">/*原始类型*/\nvar name = &quot;yangxiaofu&quot;;\nvar age = 18;\n\n/*复合类型*/\nvar person = {\n    name: &quot;yangxiaofu&quot;,\n    age: 18\n}\nvar score = [100, 90, 80]\n\nvar newName = name;\nvar newAge = age;\nvar newPerson = person;\nvar newScore = score;\n\nnewName = &quot;xiaoyang&quot;;\nnewAge = 20;\n\nnewPerson.name = &quot;newPerson&quot;;\nnewPerson.age = &#39;30&#39;;\n\nnewScore[1] = 0;\n\nconsole.log(name, age);        /*yangxiaofu 18,说明改变newName和newAge并不影响到name,age的值*/\nconsole.log(person, score);    /*{name: &quot;newPerson&quot;, age: &quot;30&quot;} [100, 0, 80]，对newPerson和newScore的修改影响到了person和score*/\n</code></pre>\n<p>复合类型的这种引用传递方式有时很有用，但我们在实现继承的时候却不希望继承者的改变会影响到被继承者。这里可以通过拷贝的方式来实现。</p>\n<ul>\n<li>浅拷贝</li>\n<li>深拷贝</li>\n</ul>\n<pre><code class="lang-javascript">var person = {\n    name: &quot;yangxiaofu&quot;,\n    brother: {\n        name: &quot;xiaoyang&quot;,\n        age: 12\n    }\n}\n\n/*浅拷贝，即只拷贝第一层*/\nvar copy = function(obj){\n    var newObj = {};\n    for(var p in obj){\n        newObj[p] = obj[p];\n    }\n    return newObj;\n}\n\nvar newPerson = copy(person);\nnewPerson.name = &quot;newPerson&quot;;\nnewPerson.brother.name = &quot;newBrother&quot;;\n\nconsole.log(person, newPerson);\n\n/*深拷贝，检测对象属性是否是复合类型，若是则递归拷贝*/\nvar deepCopy = function(obj){\n    if(typeof obj != &#39;object&#39;){\n        return obj;\n    }else{\n        /*var newObj = {};*/\n        var newObj = obj.constructor === Array?[]:{}; /*增加对数组的支持*/\n        for(var p in obj){\n            newObj[p] = deepCopy(obj[p])/*递归拷贝*/\n        }\n        return newObj;\n    }\n}\n\nvar deepPerson = deepCopy(person);\ndeepPerson.name = &quot;deepPerson&quot;;\ndeepPerson.brother.name = &quot;deepBrother&quot;;\nconsole.log(person, newPerson, deepPerson);\n</code></pre>\n<p><img src="/img/prototype/deepCopy.png" alt="浅拷贝、深拷贝">\n从上图可以知道使用浅拷贝时，拷贝所得新对象的属性brother(也是一个对象)的修改操作会影响到原对象的brother属性，而使用深拷贝已不会影响。</p>\n<p>继承也可通过上面的拷贝函数来实现。</p>\n<h3 id="-">继承实现</h3>\n<ul>\n<li>构造函数实现</li>\n</ul>\n<p>上面我们已经用构造函数实现了类，并实现了继承。实例对象会继承类的属性和方法</p>\n<ul>\n<li>拷贝实现</li>\n</ul>\n<pre><code class="lang-javascript">function extend(subObj, obj){\n    if(typeof obj != &#39;object&#39;){\n        subObj = obj;\n    }else{\n        /*var newObj = {};*/\n        var newObj = obj.constructor === Array?[]:{}; /*增加对数组的支持*/\n        for(var p in obj){\n            newObj[p] = extend(obj[p])/*递归拷贝*/\n        }\n        subObj = newObj;\n    }\n}\n</code></pre>\n<p>subObj会继承obj对象的属性方法，如果有同样的属性方法会被obj的替代。</p>\n<p>在ruby中有一种实现类似多继承的功能，是mix-in,使用模块继承方式，其实类似于我们这里的拷贝继承，将一个对象[注意这里不是类]的方法属性继承到一个新的对象中。</p>\n<ul>\n<li>prototype实现</li>\n</ul>\n<p>prototype即原型，通过原型链，可以实现层次关系，这是拷贝的方式所不能达到的。</p>\n<pre><code class="lang-javascript">var Animal = function(obj){\n    /*属性:名字、年龄、体重、身高*/\n    this.name = &quot;Animal&quot;;\n    this.age = 0;\n    this.weight = 0;\n    this.height = 0;\n\n    /*初始化方法*/\n    this.initial = function(obj){\n        this.name = obj[&#39;name&#39;] || this.name;\n        this.age = obj[&#39;age&#39;] || this.age;\n        this.weight = obj[&#39;weight&#39;] || this.weight;\n        this.height = obj[&#39;height&#39;] || this.height;\n    }\n\n    /*方法*/\n    /*输出对象信息*/\n    this.introduce = function(){\n        console.log(&quot;name: &quot;, this.name, &quot;age: &quot;, this.age, &quot;weight: &quot;, this.weight, &quot;height: &quot;, this.height);\n    }\n}\n\nAnimal.prototype.fly = function(){\n    console.log(&quot;I can fly!&quot;);\n}\n/*实例化的对象自带的方法*/\nvar cat = new Animal({name: &#39;Cat&#39;});    /*名字是Cat*/\ncat.fly();    /*I can fly!*/\ncat.fly = function(){\n    console.log(&quot;I can&#39;t fly!&quot;);\n}\ncat.fly();    /*I can&#39;t fly!*/\n</code></pre>\n<p>对象在调用它的方法的时候会先去查找自己是否有这个方法，若没有则通过<strong>proto</strong>找到原型对象，从原型对象上查找该方法，如果还没找到则会继续往上找即js原型链。挂在prototype对象下的好处是所有的实例对象公用，不会每一个对象保存一份拷贝，这样会节省不少内存.</p>\n<h3 id="mix-in">Mix-in</h3>\n<p>拷贝继承会将一个对象的方法属性加到我们的对象中，这样出现冲突则会覆盖，并且没有层级关系，我们可以通过prototype来解决。</p>\n<pre><code class="lang-javascript">function extended(sub, parent){\n    if(typeof sub.__proto__ === &#39;object&#39;){\n        /*如果sub对象的__proto__对象是object，则直接赋值，否则在sub上多加一层__proto__*/\n        sub.__proto__ = parent;\n    }else{\n        var temp = sub.__proto__;\n        sub.__proto__ = parent;\n        parent.__proto__ = temp;\n    }\n}\n</code></pre>\n<p>如我们现在的继承关系是这样的：</p>\n<ul>\n<li>1.动物[类|Animal]——&gt;猫[实例对象|cat]</li>\n<li>2.给猫增加咖菲猫的功能[coffeCat]</li>\n<li>3.extended(cat, coffeCat)</li>\n</ul>\n<p>这时我们得到的继承关系是这样的：</p>\n<ul>\n<li>cat.<strong>proto</strong>: 指向coffeCat</li>\n<li>coffeCat.<strong>proto</strong>: 指向Animal</li>\n</ul>\n<p>即cat-&gt;Animal变成了cat-&gt;coffeCat-&gt;Animal</p>\n<p>上面这种继承方式会优先调用通过extended继承来的属性。</p>\n<p>如果想要优先继承自己的类的可以这样做：</p>\n<pre><code class="lang-javascript">function extended(sub, parent){\n    if(typeof sub.__proto__ === &#39;object&#39;){\n        /*如果sub对象的__proto__对象是object，则直接赋值，否则在sub上多加一层__proto__*/\n        sub.__proto__ = parent;\n    }else{\n        sub.__proto__.__proto__ = parent;\n    }\n}\n</code></pre>\n<p>即cat-&gt;Animal变成了cat-&gt;Animal-&gt;coffeCat这样的继承关系</p>\n<h3 id="-">多态</h3>\n<p>在动态类型的语言里面一般较少的提到多态，所以这里不提及。</p>\n<h2 id="-">模块化</h2>\n<p>模块化即抽象，我们前面的封装操作即模块化的过程，一个函数可以作为一个模块，一个类可以作为一个模块，一个对象可以作为一个模块，一个文件也可以作为一个模块。</p>\n<p>当我们谈到js的模块化的时候更多的是从文件层次，即一个文件代表一个模块。seaJS就是出于这样的目的来的，因为js自身没有这样的功能(ES6已具备这样的功能)。</p>\n<ul>\n<li>cmd</li>\n<li>amd</li>\n<li>Es6</li>\n</ul>\n',summary:'<hr>\n<div class="text-center" style="background:#414141;font-size: 48px;padding:40px 0;color:#ffffff;">Learn OOP -prototype<p style="font-size: 16px;">这里并不吹嘘面向对象有多牛，但作为现在主流的一种编程范式，我们有必要去了解。</p></div>\n\n<h2 id="-">目录</h2>\n<ul>\n<li><a href="#Javascript面向对象实现">Javascript面向对象实现</a><ul>\n<li><a href="#封装">封装</a></li>\n<li><a href="#继承">继承</a></li>\n<li><a href="#原始类型与复合类型说明">原始类型与复合类型说明</a></li>\n<li><a href="#继承实现">继承实现</a></li>\n<li><a href="#Mix-in">Mix-in</a></li>\n</ul>\n</li>\n<li><a href="#模块化">模块化</a></li>\n</ul>\n<p>Javascript是基于原型的编程语言，并不是面向对象的语言。</p>\n<p class="text-important">ES6已实现class关键字，这让js看起来更像一门面向对象的语言</p>\n\n'},{meta:{title:"javascript 闭包、this",date:"2016-01-25T15:06:36.000Z",tags:["js","pl"],id:"6",createTime:"2016-01-25",url:"2016-01-25-javascript 闭包、this",strTag:"js、pl"},content:'<hr>\n<blockquote>\n<p>闭包其实很好理解，但是由于经常把this和闭包绑在一起，从而加大了理解的难度，如果将他们分开考虑，那就清晰多了。</p>\n</blockquote>\n<h2 id="-">闭包</h2>\n<p>闭包并不是js首创，在许多语言中都支持闭包，如schemer、ruby等。如果没有闭包，像js这样的支持高阶函数特性的语言将是一个噩梦。</p>\n<ul>\n<li>静态作用域</li>\n<li>动态作用域</li>\n</ul>\n<pre><code class="lang-js">var name = &quot;xiaofu&quot;;\nvar person = function(lastname){\n    var name = &#39;yang&#39;;\n\n    function personName(){\n        return name + lastname;\n    }\n    return personName;\n}\nvar pName = person();\npName(&quot;xiaoming&quot;);\n</code></pre>\n<p>js是函数作用域的，即一个function就是一个作用域，所以personName在person这个函数的作用域里面。但是调用的是在这个作用域的外面，那么当personName执行的时候，它里面的name取的是person这个作用域还是最外层的作用域呢？</p>\n<p>如果是静态作用域则调用的是person里面的 name, 如果是动态作用域则调用的是外层的name(&quot;xiaofu&quot;);而不是&quot;yang&quot;。</p>\n<p>而闭包就是用来实现静态作用域的一种方式，即通过闭包将函数和它声明时的作用域保存下来，这样在调用的时候取到的就是声明时所在的作用域而不是调用时的作用域。</p>\n<h2 id="this">this</h2>\n<p>this则与变量有点不同，即this采用的是类似于动态作用域的情况。js里面一切都是对象，所以函数也都是某个对象的方法，如果没有显示指定则是全局对象。</p>\n<pre><code class="lang-js">var person = {\n    fullname: function{\n        console.log(this);\n    },\n    printAge: function(){\n        console.log(this);\n    }\n}\nperson.fullname();        //this指向person\nvar age = person.printAge;\nage();                    //this指向window(浏览器中)\n</code></pre>\n<p>将person.printAge赋值给age之后，再执行age(),此时age没有显示指定调用对象则默认是window(浏览器环境)。所以this并不是声明所在的环境。</p>\n<h2 id="-es6-">箭头函数（es6)</h2>\n<p>es6中新增了箭头函数，箭头函数与通过function声明的函数不同，它的this是使用的声明时上下文中的this.并且不可通过apply, call等改变。</p>\n',
summary:'<hr>\n<blockquote>\n<p>闭包其实很好理解，但是由于经常把this和闭包绑在一起，从而加大了理解的难度，如果将他们分开考虑，那就清晰多了。</p>\n</blockquote>\n<h2 id="-">闭包</h2>\n<p>闭包并不是js首创，在许多语言中都支持闭包，如schemer、ruby等。如果没有闭包，像js这样的支持高阶函数特性的语言将是一个噩梦。</p>\n<ul>\n<li>静态作用域</li>\n<li>动态作用域</li>\n</ul>\n<pre><code class="lang-js">var name = &quot;xiaofu&quot;;\nvar person = function(lastname){\n    var name = &#39;yang&#39;;\n\n    function personName(){\n        return name + lastname;\n    }\n    return personName;\n}\nvar pName = person();\npName(&quot;xiaoming&quot;);\n</code></pre>\n<p>js是函数作用域的，即一个function就是一个作用域，所以personName在person这个函数的作用域里面。但是调用的是在这个作用域的外面，那么当personName执行的时候，它里面的name取的是person这个作用域还是最外层的作用域呢？</p>\n<p>如果是静态作用域则调用的是person里面的 name, 如果是动态作用域则调用的是外层的name(&quot;xiaofu&quot;);而不是&quot;yang&quot;。</p>\n<p>而闭包就是用来实现静态作用域的一种方式，即通过闭包将函数和它声明时的作用域保存下来，这样在调用的时候取到的就是声明时所在的作用域而不是调用时的作用域。</p>\n'},{meta:{title:"ES6 new features",date:"2016-01-23T15:06:36.000Z",tags:["js","pl"],id:"7",createTime:"2016-01-23",url:"2016-01-23-ES6 new features",strTag:"js、pl"},content:'<hr>\n<h2 id="es6-">ES6新语法</h2>\n<h3 id="let-const-">let、const、块级作用域</h3>\n<p>在这之前js中声明变量可以用var或是直接省略不写就可以声明一个变量，并且使用的是函数作用域。</p>\n<p>es6可以通过 let、const(常量)这两个关键字来声明变量，并且支持块级作用域。</p>\n<pre><code class="lang-js">var buttons = document.querySelectorAll(&#39;button&#39;)\n  var output = document.querySelector(&#39;#output&#39;)\n\n  for (var i = 0; i &lt; buttons.length; i++) {\n    buttons[i].addEventListener(&#39;click&#39;, function() {\n      output.innerText = buttons[i].innerText\n    })\n  }\n</code></pre>\n<p>上面这段代码会报错，因为点击事件的回调函数中的i的值都是buttons.length而不是当前循环的i.但\n如果使用 let i 的话就不会出现这个问题。</p>\n<h3 id="-">=&gt; 箭头函数</h3>\n<p>箭头函数可以把它当做匿名函数，优点就是语法简洁。</p>\n<pre><code class="lang-js">x =&gt; x\n\n(x, y) =&gt; x + y\n\nx =&gt; {\n    return x\n}\n\n(x, y) =&gt; {\n    return x + y\n}\n</code></pre>\n<h3 id="-">函数上下文</h3>\n<p>箭头函数带来的另外一个改变是函数上下文的绑定(this)，this不再是随着调用者而改变，即使使用\ncall、apply也不会改变。即函数的上下文一直都是函数声明时的上下文。</p>\n<pre><code class="lang-js">name = &quot;xiaofu&quot;;\nage = 20;\nvar obj = {\n        name: &quot;yang&quot;,\n        age: 17,\n        getName: function(){\n            var name = () =&gt; {\n                return this.name;\n            }\n            return name;\n        },\n        getAge: function(){\n            var age = function(){\n                return this.age;\n            }\n            return age;\n        }\n    }\nvar person = {\n    name: &#39;cat&#39;,\n    age: 28\n}\nmyname = obj.getName();\nmyage = obj.getAge();\nconsole.log(myname());                /*yang*/\nconsole.log(myage())                /*20*/\nconsole.log(myname.call(person));    /*yang*/\nconsole.log(myage.call(person));    /*28*/\n</code></pre>\n<p>从上面我们可以发现箭头函数输出的一直都是声明的上下文即 obj 对象。</p>\n<p>注：let const 带来了变量的作用域改变，而箭头函数带来了this指向的改变。而且我觉得这两个改变使js\n与其它主流的语言更接近。</p>\n<h3 id="-">模板字符串</h3>\n<ul>\n<li>支持变量注入</li>\n<li>支持换行</li>\n</ul>\n<blockquote>\n<p>ruby中就很好的支持这个特性。</p>\n</blockquote>\n<p>模板使我们不在需要使用 &#39;+&#39; 来拼接字符串。</p>\n<pre><code class="lang-js">let name = &#39;yangxiaofu&#39;;\nlet company = &#39;jikexueyuan&#39;;\n\nlet greet = `Hi, I am ${name}, I am working at ${company}`\nconsole.log(greet) /* Hi, I am yangxiaofu, I am working at jikexueyuan*/\n</code></pre>\n<p>如果使用es5, 那么我们需要这样做：</p>\n<pre><code class="lang-js">var name = &#39;yangxiaofu&#39;;\nvar company = &#39;jikexueyuan&#39;;\n\nvar greet = &quot;Hi, I am &quot; + name &quot;, I am working at &quot;;\n    greet += company;\nconsole.log(greet) /* Hi, I am yangxiaofu, I am working at jikexueyuan*/\n</code></pre>\n<h3 id="-function-">函数作为属性时可用省略 function 关键字</h3>\n<pre><code class="lang-js">let person = {\n    //es5\n    getName: function(){\n        return &#39;person&#39;;\n    },\n    //es6\n    getAge(){\n        return &#39;age&#39;;\n    }\n}\n</code></pre>\n<p>不过我还是看着之前的写法比较习惯， function 关键字让我一眼就知道它是一个函数，\n不过省略的写法的确简洁不少。</p>\n<h3 id="-">多重赋值</h3>\n<pre><code class="lang-js">let [x, y] = [30, 20];\n</code></pre>\n<h3 id="-">默认值参数</h3>\n<pre><code class="lang-js">//es6\nfunction person(name = &quot;name&quot;){\n    return name;\n}\n\n//es5\nfunction person(name){\n    name = name || &quot;name&quot;;\n}\n</code></pre>\n<p>上面是es5的一种常用的默认值赋值方式，但当传入的值为 false 的情况下则无法达到预想的结果。</p>\n<h3 id="-args-arguments">...args 替代 arguments</h3>\n<pre><code class="lang-js">/*es5*/\nfunction method01() {\n  var args = [].slice.apply(arguments)\n\n}\nfunction method02(name) {\n  var args = [].slice.apply(arguments, 1)\n\n}\n\n/*es6*/\nfunction method01(...args) {\n\n}\nfunction method02(name, ...args) {\n\n}\n</code></pre>\n<h3 id="class">class</h3>\n<p>本质还是函数</p>\n<pre><code class="lang-js">class Cat{}\n/*\n* [Function: Cat]\n*/\n\nclass Person {\n  constructor(name, height, age) {\n    this.name = name;\n    this.height = height;\n    this.age = age;\n  }\n\n  toStr() {\n    return `my name is ${this.name}`;\n  }\n}\n\nvar  me = new Person(&#39;yangxiaofu&#39;, 180, 19)\nconsole.log(me.toStr()) /*my name is yangxiaofu*/\n</code></pre>\n<p>不足：无法直接设置类变量，这在其他原生支持类的语言中是可以的</p>\n<pre><code class="lang-js">class Person{\n    let parent = &#39;parents&#39;;    //wrong\n    constructor(name){\n        this.name = name;\n    }\n}\n</code></pre>\n<p>上面给类添加一个parent变量的写法是错误的。</p>\n<h3 id="-">类继承</h3>\n<pre><code class="lang-js">\nclass Animal{\n    eat(){\n        console.log(&#39;eating something&#39;);\n    }\n}\n\nclass Cat extends Animal{\n    constructor(name){\n        super()\n        this.name = name;\n    }\n}\n\nvar cat = new Cat(&#39;cat&#39;);\ncat.eat();\n</code></pre>\n<p>使用extends关键字以及 super 方法，super方法必须在 this使用之前调用。</p>\n<h3 id="-static-">可以通过static定义静态方法</h3>\n<pre><code class="lang-js">class Animal{\n    eat(){\n        console.log(&#39;eating something&#39;);\n    }\n}\n\nclass Cat extends Animal{\n    constructor(name){\n        super()\n        this.name = name;\n    }\n\n    static get fullname(){\n        return &#39;cat animal&#39;;\n    }\n}\n\nvar cat = new Cat(&#39;cat&#39;);\nconsole.log(Cat.fullname);\n</code></pre>\n<p>与c++这样的语言相比，类的特性还比较少。</p>\n',summary:'<hr>\n<h2 id="es6-">ES6新语法</h2>\n<h3 id="let-const-">let、const、块级作用域</h3>\n<p>在这之前js中声明变量可以用var或是直接省略不写就可以声明一个变量，并且使用的是函数作用域。</p>\n<p>es6可以通过 let、const(常量)这两个关键字来声明变量，并且支持块级作用域。</p>\n<p>```js\nvar buttons = document.querySelectorAll(&#39;button&#39;)\n  var output = document.querySelector(&#39;#output&#39;)</p>\n<p>  for (var i</p>\n'},{meta:{title:"react/react-native代码规范实践",date:"2016-09-26T10:06:36.000Z",tags:["js","react","react-native"],topper:!0,id:"8",createTime:"2016-09-26",url:"2016-09-26-react/react-native代码规范实践",strTag:"js、react、react-native"},content:'<hr>\n<h3 id="-">驼峰式命名 + 首字母大写</h3>\n<ul>\n<li>基于react本身的特性，组件命名首字母必须大写</li>\n<li>Javascript本身类命名推荐首字母</li>\n<li>组件对应文件首字母大写并与组件名相对应</li>\n</ul>\n<pre><code class="lang-js">/*TopicComponent*/\nclass TopicComponent extends Component {}\n</code></pre>\n<p>对应的文件名推荐使用 <code>TopicComponent</code></p>\n<h3 id="let-const-var">let/const 替代var</h3>\n<p>使用let/const而不是var,给所以变量加上块级作用域</p>\n<h3 id="-tab-tab-4-">四个空格缩进(若使用tab缩进可将tab设为4个空格)</h3>\n<h3 id="-">语句必须分号结尾</h3>\n<h3 id="-">声明语句运算符、括号前后加一个空格</h3>\n<pre><code class="lang-js">/*变量声明*/\nconst name = &#39;react&#39;;\nlet myname = &#39;xiaofu&#39;;\nlet num = 1 + 1;\n\n/*函数声明*/\nfunction fetch (params) {\n    /**\n     * body\n     */\n}\n\n/*对象声明*/\nlet topicData = {\n    msg: &#39;message&#39;,\n    data: [],\n    getData () {\n        /**\n         * body\n         */\n    }\n}\n</code></pre>\n<h3 id="-">私有属性及方法加下划线前缀</h3>\n<h3 id="-class-200-">建议一个class一个文件，单文件不要超过200行</h3>\n<p>单文件过大会带来阅读障碍，如果功能过于复杂，建议拆分为子类</p>\n<h3 id="-class-">文件名与class名保持一致</h3>\n<h3 id="-props-state-">严格划分好实例属性、props、state，避免重复渲染</h3>\n<p>不要滥用 state,应该只将影响视图的值存放在 state 中，这样可以避免频繁的 state 操作以及渲染。</p>\n<h3 id="proptypes-es7-static-">propTypes类型声明必须，并以es7 static关键字的格式声明</h3>\n<pre><code class="lang-js">export default class TopicComponent extends Component {\n    static propTypes = {\n        data: PropTypes.object.isRequired,\n        fetchData: PropTypes.func.isRequired\n    }\n\n    constructor (props) {\n        super(props);\n    }\n}\n</code></pre>\n<h3 id="state-">state在构造函数中声明</h3>\n<pre><code class="lang-js">export default class TopicComponent extends Component {\n    static propTypes = {\n        data: PropTypes.object.isRequired,\n        fetchData: PropTypes.func.isRequired\n    }\n\n    constructor (props) {\n        super(props);\n\n        this.state = {\n\n        }\n    }\n}\n</code></pre>\n<h3 id="-">单行注释写在当前代码行的末尾，尽量保持当前文件所有单行注释对齐</h3>\n<h3 id="-">多行注释按如下格式，紧贴所需注释代码上方，无需空行(注意空格)</h3>\n<pre><code class="lang-js">/**\n * 注释\n */\n</code></pre>\n<h3 id="-class-">常量声明在class之前</h3>\n<h3 id="import-">import模块按类型划分在当前文件最前面部分，解构类型的导入一个空行分隔，与其它代码用两个空行分隔</h3>\n<pre><code class="lang-js">import React, {\n    Component,\n    PropTypes\n} from &#39;react&#39;;\n\nimport {\n    View,\n    Text,\n    StyleSheet,\n    NavigatorIOS,\n    ListView,\n    TouchableHighlight,\n    Image,\n    ActivityIndicator,\n    RefreshControl\n} from &#39;react-native&#39;;\n\nimport ScrollableTabView from &#39;react-native-scrollable-tab-view&#39;;\nimport moment from &#39;moment&#39;;\n\n\nconst styles = StyleSheet.create({\n    container: {\n        flex: 1,\n        marginTop: 64,\n        paddingBottom: 48,\n        backgroundColor: &#39;#ffffff&#39;\n    }\n}\n</code></pre>\n<h3 id="-">组件代码编写顺序</h3>\n<ul>\n<li>PropType声明</li>\n<li>静态属性</li>\n<li>实例属性</li>\n<li>构造函数(包含state)</li>\n<li>静态方法</li>\n<li>实例方法 </li>\n<li>私有函数</li>\n<li>生命周期函数 </li>\n<li>render子函数以及render函数</li>\n</ul>\n',summary:'<hr>\n<h3 id="-">驼峰式命名 + 首字母大写</h3>\n<ul>\n<li>基于react本身的特性，组件命名首字母必须大写</li>\n<li>Javascript本身类命名推荐首字母</li>\n<li>组件对应文件首字母大写并与组件名相对应</li>\n</ul>\n<pre><code class="lang-js">/*TopicComponent*/\nclass TopicComponent extends Component {}\n</code></pre>\n<p>对应的文件名推荐使用 <code>TopicComponent</code></p>\n<h3 id="let-const-var">let/const 替代var</h3>\n<p>使用let/const而不是var,给所以变量加上块级作用域</p>\n'},{meta:{title:"再谈对闭包的理解",date:"2016-03-05T15:06:36.000Z",tags:["js","pl"],id:"9",createTime:"2016-03-05",url:"2016-03-05-再谈对闭包的理解",strTag:"js、pl"},content:'<hr>\n<h3 id="-">闭包只是为了实现词法作用域而用到的一种数据结构而已</h3>\n<p>先从阮一峰09年写的一篇关于闭包的文章开始<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">(原文地址)</a>文中说&quot;可以把闭包理解为就是能够读取其他函数内部变量的函数,因为js中,只有函数内部的子函数才能读取局部变量，因此也可以把闭包定义在一个函数内部的函数。所以闭包本质就是将函数内部和函数外部连接起来的一座桥梁&quot;。</p>\n<p>毕竟不是专业学习js的，也不是程序语言方面的专家，在这里就不去计较了，下文会给出更完整的闭包说明。(PS:个人还是比较欣赏阮一峰写的文章的，能将一些概念讲得通俗易懂)</p>\n<p>最后还留下了一个思考题</p>\n<ul>\n<li>示例01：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()());\n</code></pre>\n</li>\n<li>示例02：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　var that = this;\n　　　　　　return function(){\n　　　　　　　　return that.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()());\n</code></pre>\n看完这道题，就希望大家将this和闭包分开，不要给自己找麻烦？</li>\n</ul>\n<p>在开始说闭包之前，需要理解好以下的概念：</p>\n<ul>\n<li>词法作用域(静态作用域)</li>\n<li>函数上下文</li>\n</ul>\n<p><a href="http://yangxiaofu.com/2016/01/25/js/closure-this/">之前简单的提过</a>,词法作用域简单的理解就是函数的上下文是在声明是确定的，而不是在调用时确定的。这里不想对这两个名词作过多的解释，我们知道js/ruby/python等主流的语言都是词法作用域就好，因为与之相对的动态作用域有许多的问题，所以现在的语言基本都是词法作用域的。</p>\n<p>函数上下文就简单的理解为函数执行的环境好了，在这个环境中保存了函数执行所需的变量。</p>\n<h3 id="javascript-">JavaScript权威指南第六版关于闭包的说明</h3>\n<blockquote>\n<p>JavaScript采用词法作用域，也就是说函数的执行依赖于变量的作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现词法作用域，JavaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为&quot;闭包&quot;。</p>\n<p>当定义一个函数时，它实际上保存了一个作用域链。当调用这个函数时，它创建\n一个新的对象来存储它的局部变量，并将这个对象添加到保存的作用域链上。</p>\n</blockquote>\n<p>(闭包可以简单的理解为函数用来存储它的局部变量的对象，这个对象我们来说是不可见的，是js解释器实现的过程中才会用到的。每一个函数都会有这样的一个对象，作用域链则是这些对象之间的关系。)</p>\n<p>&quot;闭包&quot;这个术语的来源：指函数变量可以被隐藏于作用域链之内，因此看起来是函数将变量&quot;包裹&quot;了起来。</p>\n<p>看文字可能会比较绕，下面是书中的一个例子：</p>\n<pre><code class="lang-js">var scope = &quot;global scope&quot;;            /*全局变量*/\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;        /*局部变量*/\n    function f(){return scope;}\n    return f();\n}\ncheckscope();                        /*=&gt;&quot;local scope&quot;*/\n</code></pre>\n<pre><code class="lang-js">var scope = &quot;global scope&quot;;            /*全局变量*/\nfunction checkscope(){\n    var scope = &quot;local scope&quot;;        /*局部变量*/\n    function f(){return scope;}\n    return f;\n}\ncheckscope()();                        /*=&gt;&quot;local scope&quot;*/\n</code></pre>\n<p>checkscope最后的返回值都是一样的，即&quot;local scope&quot;。</p>\n<p>上面两个例子的不同之处就是函数f执行的地方不同，一个在checkscope这个作用域里调用的(每一个函数都是一个作用域)，一个在全局作用域里调用的。回忆之前说的，函数调用时的上下文或者说作用域是在声明时确定的，所以与调用的位置无关，即f函数的调用位置虽然不同，调用的环境虽然不同，但最终的结果都是一样的。</p>\n<p>说到这里，闭包就说得差不多了，回过头来看一下常规的对于闭包的理解：</p>\n<blockquote>\n<p>通过返回函数的形式取得函数的局部变量。</p>\n</blockquote>\n<p>这种说法本身没有错，但它只是闭包的一种表现形式，</p>\n<p>比如将上例进行下更改：</p>\n<pre><code class="lang-js">var scope = &quot;global scope&quot;;            /*全局变量*/\nfunction checkscope(fn){\n    var scope = &quot;local scope&quot;;        /*局部变量*/\n    function f(){return scope;}\n    fn(f);\n}\ncheckscope(function(func){\n    var scope = &quot;func scope&quot;;\n    return func();\n});                                    /*=&gt;&quot;local scope&quot;*/\n</code></pre>\n<p>改成类似回调的执行方式，结果还是一样的，注意结果并不是func scope，但是并没有返回f函数这一说，难道这就不是闭包了吗？(当然这里有点扣字眼)</p>\n<h3 id="-">复杂点的闭包题</h3>\n<p>真不知道按照前面那种简单的理解该怎么来理解这道题，但是如果理解了闭包的实质，那么就会发现其实很简单。</p>\n<pre><code class="lang-js">function fun(n,o) {\n  console.log(o)\n  return {\n    fun:function(m){\n      return fun(m,n);\n    }\n  };\n}\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);    /*undefined,?,?,?*/\nvar b = fun(0).fun(1).fun(2).fun(3);                /*undefined,?,?,?*/\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);        /*undefined,?,?,?*/\n\n/*\n* 问:三行a,b,c的输出分别是什么？\n* 提示:形参也属于局部变量，包含在作用域中\n*/\n</code></pre>\n<p>这里就不给出答案了，自行运行即可知道结果。</p>\n<h3 id="-this">说说this</h3>\n<p>想起最开始时的那个思考题了吗？与闭包就没什么关系(注：任何一个函数其实都用到了闭包，但我们暂且考虑两层以及两层以上的嵌套情况，未嵌套情况下因为使用的都是全局作用域，结果应该是很直观的)。this一般用来代表函数的调用对象，它和上下文对象并不是同一个，上下文对象对我们来说是不可见的，除了全局作用域。</p>\n<ul>\n<li>示例01：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()());        /*The Window*/\n</code></pre>\n</li>\n<li>示例02：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　var that = this;\n　　　　　　return function(){\n　　　　　　　　return that.name;\n　　　　　　};\n　　　　}\n　　};\n var that = {name: &#39;xiaofu&#39;};            /*干扰项*/ \n　　alert(object.getNameFunc()());        /*My Object*/\n</code></pre>\n</li>\n</ul>\n<p>我们再来看一下题目，示例01输出的是&quot;The Window&quot;,示例02输出的是&quot;My Object&quot;。</p>\n<p>说明：\n示例01最终执行的是 function(){return this.name}，因为没有显示指明调用对象，所以其this执行全局对象。\n示例02先调用object.getNameFunc(),因为显示的指定了调用对象，所以内部的this是object(注：这里说的是this指向的问题，还没有说闭包)，接着执行function (){return that.name}，这个函数在getNameFunc这个函数作用域中声明的，所以它调用的时候使用的是这个作用域，即得到var that = this;的这个that;而不是外面的that。</p>\n<h3 id="-">作用域链不等同于原型链</h3>\n<p>真不知道这两个不相关的东西怎么会被等同起来看待，以后谁告诉我它们是同一个东西，我就想问了，ruby、python这种没有原型概念的语言难道就没有作用域链了吗？</p>\n<p>更有甚者将变量声明提升和闭包混在一起，也是醉了。</p>\n<h3 id="-this-">如果无法理解，但记住下面的一点使用技巧，那么遇到闭包和this时也能够轻松的应对</h3>\n<ul>\n<li>闭包：函数执行时变量的获取从声明的作用域处去获取(注意链式关系，当前没有就往父级找，知道全局作用域)</li>\n<li>this：显示指定调用者则this就指向谁，如未指定则为全局对象</li>\n</ul>\n',summary:'<hr>\n<h3 id="-">闭包只是为了实现词法作用域而用到的一种数据结构而已</h3>\n<p>先从阮一峰09年写的一篇关于闭包的文章开始<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">(原文地址)</a>文中说&quot;可以把闭包理解为就是能够读取其他函数内部变量的函数,因为js中,只有函数内部的子函数才能读取局部变量，因此也可以把闭包定义在一个函数内部的函数。所以闭包本质就是将函数内部和函数外部连接起来的一座桥梁&quot;。</p>\n<p>毕竟不是专业学习js的，也不是程序语言方面的专家，在这里就不去计较了，下文会给出更完整的闭包说明。(PS:个人还是比较欣赏阮一峰写的文章的，能将一些概念讲得通俗易懂)</p>\n<p>最后还留下了一个思考题</p>\n<ul>\n<li>示例01：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()());\n</code></pre>\n</li>\n<li>示例02：<pre><code class="lang-js">　　var name = &quot;The Window&quot;;\n　　var object = {\n　　　　name : &quot;My Object&quot;,\n　　　　getNameFunc : function(){\n　　　　　　var that = this;\n　　　　　　return function(){\n　　　　　　　　return that.name;\n　　　　　　};\n　　　　}\n　　};\n　　alert(object.getNameFunc()());\n</code></pre>\n看完这道题，就希望大家将this和闭包分开，不要给自己找麻烦？</li>\n</ul>\n'},{meta:{title:"Coding form zero",date:"2015-12-18T15:36:51.000Z",tags:["随笔"],id:"10",createTime:"2015-12-18",url:"2015-12-18-Coding form zero",strTag:"随笔"},content:'<hr>\n<h2 id="why-code-from-zero-">Why code from zero?</h2>\n<blockquote>\n<p>因为我任性。。</p>\n</blockquote>\n<p>刚接触编程的人都会感叹，要学的怎么那么多？刚学的还没用就过时了。</p>\n<p>其实很多原理都是一样的，变的只是外观，掀开面纱就会发现原来就是那么回事。</p>\n<p>概念总是被复杂化，本来很简单的确弄得五花八门的，增加学习和使用的难度。</p>\n<h2 id="simple-maybe-better">Simple maybe better</h2>\n<p>我的入门语言是c，学了一个学期也没学到啥。后来我学了c++，学了一年，依然没有学到什么？并不是说C/C++不好，只是太复杂，不适合入门语言。后来我接触ruby，js，虽然时间不长但已经可以做出些有用的东西，当我再回过头去看c/c++时，才发现有些东西是如此简单。</p>\n<h2 id="scheme-">Scheme,简洁却功能强大，很多功能还是其它语言所没有的</h2>\n<p><img src="/img/matz/schme.png" alt="lambda"></p>\n',summary:'<hr>\n<h2 id="why-code-from-zero-">Why code from zero?</h2>\n<blockquote>\n<p>因为我任性。。</p>\n</blockquote>\n<p>刚接触编程的人都会感叹，要学的怎么那么多？刚学的还没用就过时了。</p>\n<p>其实很多原理都是一样的，变的只是外观，掀开面纱就会发现原来就是那么回事。</p>\n<p>概念总是被复杂化，本来很简单的确弄得五花八门的，增加学习和使用的难度。</p>\n<h2 id="simple-maybe-better">Simple maybe better</h2>\n<p>我的入门语言是c，学了一个学期也没学到啥。后来我学了c++，学了一年，依然没有学到什么？并不是说C/C++不好，只是太复杂，不适合入门语言。后来我接触r</p>\n'},{meta:{title:"松本行弘的程序世界——编程语言知多少",date:"2015-12-05T15:36:51.000Z",archives:"pl",tags:["pl","ruby"],id:"11",createTime:"2015-12-05",url:"2015-12-05-松本行弘的程序世界——编程语言知多少",strTag:"pl、ruby"},content:'<hr>\n<p>第一次读这本书，是我还在读书的时候，那时的我正为C++这样的语言而苦恼，就这样接触了ruby，ruby是一门动态类型的语言，语法优雅，非常灵活，也因为它我开始开发web程序。这本书并不是一本ruby程序指南，而是一本描述程序世界的书籍，虽然讲得不那么深入，却很广泛。</p>\n<p><img data-src="/img/matz/matz.jpg" alt="matz"></p>\n<h2 id="-ruby">一、我为什么开发Ruby</h2>\n<h3 id="-">编程语言的重要性</h3>\n<p>语言体现了人类思考的本质。因为语言，人与人之间才能传递知识和交流思想，才能做深入的思考。在语言学领域，有一个Sapir-Whirf假说，认为语言可以影响说话者的思想，即语言的不同，造成了思想的不同。在这里，我觉得计算机语言很符合这个假说。程序员由于使用的编程语言不同，他的思考方法和编写出来的代码都会受到编程语言的很大影响。</p>\n<h3 id="ruby-">Ruby的原则</h3>\n<p>Ruby编程语言的设计目标是轻松编程、提高开发效率。</p>\n<p>三个原则：</p>\n<ul>\n<li>简洁性</li>\n<li>扩展性</li>\n<li>稳定性</li>\n</ul>\n<h4 id="-">简洁性</h4>\n<p>面向对象编程——面向对象的思想只是把数据和方法看作一个整体，当做对象来处理，并没有解决以前解决不了的问题。面向对象的方法并没有实现任何新的东西，却要在运行时判定要调用的方法，倾向于增大程序的运行开销。实现同样的算法，面向对象的程序往往更慢，过去计算机的执行速度不够快，所以不容许这样的浪费。</p>\n<p>内存管理，不用的内存现在可用垃圾收集器自动释放，而不用程序员自己去释放。变量和表达式的类型检查，在执行时已经可以自动检查，而不用在编译时检查了。</p>\n<p>如果可以把伪代码中非实质性的东西去掉，只保留描述算法的部分就直接运行，那么这种编程语言不就是最好的吗？ruby的目标就是成为开发效率高、“能直接运行的伪码式编程语言”。</p>\n<h4 id="-">扩展性</h4>\n<p>编程语言作为软件开发工具，其最大的特征就是对要实现的功能没有限制。“如果想到就可以做到”，这听起来像小孩说的话，但这在编程语言的世界里，真的就是这么一回事。不管在什么领域，做什么处理，只要用一种编程语言编写出了程序，我们就可以说这种语言适用于这一领域。</p>\n<p>实现扩展性的一个重要方法是抽象化。抽象化是指把数据和要做的处理都封装起来，就像一个黑盒子，我们不知道内部是如何实现的，但是可以用它。ruby在扩展性上看重的是如何最大限度地发挥程序员自身的能力。</p>\n<h4 id="-">稳定性</h4>\n<p>我相信，作为在世界上广泛使用的编程语言，应该有稳定的语法，不能像随风飘荡的灯芯那样闪烁不定。注：作者以Lisp的宏为例，指出了提供巨大的扩展性的同时也使得程序难以理解和阅读。</p>\n<h2 id="-">二、面向对象</h2>\n<p>程序员控制计算机，还是在为计算机工作？</p>\n<p>阿尔法综合征——指在伺养宠物的时候，宠物狗误解了一直细心照顾它的主人的地位，反而感觉到它是主人，比主人更了不起。</p>\n<p>几乎所有的编程语言都具备“图灵完备”的属性，无论何种编程语言都可以实现等价的程序，但这并不是说选择什么样的编程语言都一样。每一种语言都有自己的特征、属性、都各有长处和短处，写程序的难易程度也有很大的不同。</p>\n<p>编程技巧：</p>\n<ul>\n<li>编程风格</li>\n<li>算法</li>\n<li>数据结构</li>\n<li>设计模式</li>\n<li>开发方法</li>\n</ul>\n<h3 id="-">面向对象编程</h3>\n<p>面向对象的设计方法是20世纪60年代后期，在诞生于瑞典的Simula编程语言中最早使用。Smalltalk编程语言对近代面向对象编程语言影响很大，可以称之为面向对象语言之母。到现在，大多数主流的编程语言使用的都是面向对象的设计方法。</p>\n<h4 id="-">多态性</h4>\n<p>多态就是可以把不同种类的东西当做相同的东西来处理。各种数据可以统一地处理、根据对象的不同自动选择最合适的方法而程序内部则不发生冲突、具备扩展性。</p>\n<h4 id="-">数据抽象和继承</h4>\n<p>数据抽象有时也会称为封装，多态性、数据抽象和继承被称为面向对象编程的三原则。</p>\n<h4 id="-">面向对象的历史</h4>\n<p>Simula语言最早引入了数据和处理数据方法自动结合的抽象数据类型。随后，又增加了类和继承的功能。</p>\n<p>Lisp的发展产生了许多很有创新的方法，多重继承、混合式和多重方法等。</p>\n<p>C语言是面向过程的语言，在C语言中追加面向对象的功能，产出了C++。</p>\n<h4 id="-">复杂性</h4>\n<p>虽然计算机的额性能年年在提高，但它的处理能力终究是有限的，而人类的理解力的局限性给软件生产力带来的限制性更大。为了找到迅速开发大规模复杂软件的方法，有时牺牲性能也在所不惜。</p>\n<h4 id="-">结构化编程</h4>\n<p>结构化编程的基本思想是有序地控制流程，即把程序的执行顺序限制为顺序、分支和循环3种，把共通的处理归结为例程。结构化编程引入了例程的概念，也就是把基本上相同的处理抽象成例程，其中不同的部分由外部传递进来的参数来对应。结构化编程的限制和抽象化是人类处理复杂软件的非常有效的方法。结构化编程的顺序、分支和循环可以实现一切算法，虽然降低了程序的复杂性和灵活性，但是程序的实现能力并没有降低。现在几乎所有的编程语言都支持结构化编程，结构化编程也成为了编程的基本常识。</p>\n<h4 id="-">数据的抽象化</h4>\n<p>结构化编程降低了程序流程的复杂性，但却不能解决数据的复杂性，面向对象就是为此而出现的。数据抽象是数据和处理方法的结合。对数据内容的处理和操作，必须通过事先定义好的方法来进行。数据和处理方法结合起来成为了黑盒子。</p>\n<h4 id="-">继承</h4>\n<p>继承就是在保持既有类的性质的基础上而生成新类的方法。原有的类称为父类，新生成的类称为子类。子类继承父类所有的方法，如果需要可以增加新的方法，也可以重写从父类继承的方法。</p>\n<ul>\n<li>单一继承</li>\n<li>多重继承（一个对象有多个父类，如一个公司员工可能同时是一个父亲、儿子）</li>\n</ul>\n<p>单一继承——单一继承关系是单纯的树结构，类之间的关系单纯就不会发生混乱，实现起来也比较简单。\n多重继承——继承多个类，程序代码共享。单一继承可以实现的功能，多重继承都可以实现，但是类之间的关系会变得复杂，哪个类的功能继承自哪个类就变得难以理解。</p>\n<p>多重继承导致的问题：</p>\n<ul>\n<li>结构复杂化</li>\n<li>优先顺序模糊</li>\n<li>功能冲突</li>\n</ul>\n<p>ruby中多重继承的实现——&quot;Mix-in类&quot;，Mix-in类是具有以下特征的抽象类：</p>\n<ul>\n<li>不能单独生成实例</li>\n<li>不能继承普通类</li>\n</ul>\n<p>实现功能共享的方法是把共享的功能放在Mix-in类里面，然后把Mix-in类插入到继承树里面。</p>\n<h3 id="duck-typing">Duck Typing</h3>\n<blockquote>\n<p>If it walks like a duck and quacks like a duck,it must be a duck(走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子)</p>\n</blockquote>\n<p>动态类型的缺点：</p>\n<ul>\n<li>执行时才能发现错误</li>\n<li>程序阅读可能不好理解</li>\n<li>运行速度会比静态类型慢</li>\n</ul>\n<h4 id="-">元编程</h4>\n<p>在ruby中可以方便的动态给类增加方法。静态类型的语言中这是很难做到的。</p>\n<h4 id="-">反射</h4>\n<p>指在程序执行时取出程序的信息或者改变程序信息，实现对程序的动态操作。</p>\n<h3 id="-">元编程和小编程语言</h3>\n<p>DSL是针对特定领域的语言，小编程语言一般会具备如下功能：</p>\n<ul>\n<li>类型</li>\n<li>字面量</li>\n<li>表达式</li>\n<li>运算符</li>\n<li>语句</li>\n<li>控制结构</li>\n<li>声明</li>\n<li>上下文相关</li>\n<li>单位</li>\n<li>词汇</li>\n<li>层级数据</li>\n</ul>\n<h2 id="-">程序块</h2>\n<p>程序块是ruby语言的特色之一，在方法调用时可以追加代码块。</p>\n<pre><code class="lang-ruby">ary.each { |x| puts x}\n</code></pre>\n<h3 id="-">高阶函数</h3>\n<p>ruby程序块功能的原理和高阶函数是一样的。高阶函数是指以函数作为参数的函数。为了实现高阶函数，编程语言中必须把函数和方法作为数据来处理。</p>\n<h2 id="-">四、设计模式</h2>\n<p>设计模式指设计上经常反复使用的模式。在软件中，重用一般是通过库，各种软件共享处理过程、数据结构以及类等。但是只有库还不能达到充分地的共享，软件设计中除了库还有共通的部分即模式。</p>\n<p>23种常用设计模式</p>\n<p><img data-src="/img/matz/patterns.png" alt="设计模式"></p>\n<h3 id="prototype-">prototype模式</h3>\n<p>Prototype(原型)模式&quot;明确一个实例作为要生成对象的种类原型&quot;，通过复制该实例来生成新的对象。\n相对于类模式的编程，原型模式的编程的构成元素比较少，具有简单实现面向对象功能设计的倾向。</p>\n<h2 id="-ajax">五、Ajax</h2>\n<p>Ajax的最大特点是进行异步操作。异步意味着，Web浏览器的通信和页面更新是相互独立的。</p>\n<p>老式的浏览器通信方式：\n每当用户进行操作之后，需要更新页面，在得到服务器的响应之后，下一个页面才能显示出来。\nAjax的通信方式：\nAjax技术中，对于用户进行的操作，基本是由Javascript在Web浏览器中进行响应。仅在数据必须从服务器获取的情况下，才在后台进行异步通信。</p>\n<p><img data-src="/img/matz/http.png" alt="http"></p>\n<p>支撑Ajax的3个主要技术：</p>\n<ul>\n<li>Javascript</li>\n<li>XML</li>\n<li>DHTML</li>\n</ul>\n<p>Javascript进行异步通信的对象的名字是XMLHttpRequest.</p>\n<p>DHTML:动态的HTML,可以动态地对HTML进行引用、修改和更新。它是利用装载在网页中的Javascript，使用DOM(文档对象模型)对网页数据进行操作。</p>\n<p>Ajax网站特点：</p>\n<ul>\n<li>没有Web页面跳转</li>\n<li>通过异步通信实现快速反应</li>\n</ul>\n<h2 id="-ruby-on-rails">第六章 Ruby on rails</h2>\n<p>Web应用的基本是HTTP，一次HTTP处理经过如下的过程：</p>\n<ul>\n<li>Web浏览器对应于用户的操作，像Web服务器发出HTTP请求</li>\n<li>web服务器根据请求，准备好发送到Web浏览器的数据</li>\n<li>Web服务器把数据以HTTP响应的形式送还Web浏览器</li>\n</ul>\n<p>MVC模式对应上面的各个部分如下：</p>\n<ul>\n<li>Web浏览器发送来的HTTP请求通过Web服务器传给控制部分。Web应用框架的分配器(路由)把请求传递给合适的控制部分。</li>\n<li>控制部分操作的模型和请求的信息相对应，同时指定显示使用的视图。视图从模型启动，一边引用模型一边准备发送给Web浏览器的数据。</li>\n<li>Web服务器把数据以HTTP响应的形式送还Web浏览器。</li>\n</ul>\n<p><img data-src="/img/matz/mvc.png" alt="web应用中的MVC"></p>\n<p>MVC的具体实现可能会有细微的差别，如rails的MVC与传统的MVC就有一些不同。</p>\n<h2 id="-">第七章 文字编码</h2>\n<p>计算机能够处理图像、动画及各种应用程序固有的、多种多样的数据。但从CPU的层次来看，计算机所处理的各种数据都是用比特所表现的二进制数字。为了让计算机能够处理文字，就必须将文字变换为相应的数字。这种对应于文字的数值就称为文字编码。文字的集合称为字符集；在字符集中，每个字符都分配一个编码，这称为字符编码。计算机上仅仅用整数值来表示文字编码的方式称为文字编码方式。计算机不能处理文字本身，就要让文字与编码对应。与文字相对应的编码就称为文字编码。这样计算机只能处理分配了编码的文字，分配了编码的文字集合就称为文字集。</p>\n<h3 id="-">为什么会发生乱码？</h3>\n<p>文字乱码最大原因是把程序的字符编码方式搞错了。把一种字符编码方式的数据按另一种字符编码方式来表示，结果就会完全不同。为了在计算机画面上表示文字，还需要文字编码及文字编码以外的东西。与某种文字编码相对应的文字应具备何种字形的信息由计算机掌握，根据需要，必须将字形在画面上表示出来。这样的字形数据称为字体。如果没有对应的字体信息，就会出现乱码。</p>\n<h2 id="-">第八章 正则表达式</h2>\n<p>正则表达式主要用来处理字符串，是一种描述字符串模式的微语言。</p>\n<h2 id="-">第九章 整数和浮点小数</h2>\n<p>作为高级程序员，应该有更高的目标。如果计算机中能够自然计算的整数有上限，就要想办法引入多倍长以超越界限；为了能除尽，就引入有理数等。如何权衡计算效率以达到最大限度的平衡技巧。</p>\n<h2 id="-">第十章 高速执行和并行处理</h2>\n<p>两个法则：</p>\n<ul>\n<li>帕累托法则：80：20法则</li>\n<li>摩尔法则：即大规模集成电路中的晶体管数每18个月翻一番。</li>\n</ul>\n<h2 id="-">第十一章 程序安全性</h2>\n<p>4种软件漏洞：</p>\n<ul>\n<li>DOS攻击</li>\n<li>信息泄露</li>\n<li>权限夺取</li>\n<li>权限升格</li>\n</ul>\n<p>DOS攻击：也称拒绝服务攻击，是指妨碍软件正常运行的网络攻击手段。能够引起软件异常终止的程序错误，可以说全部都是引发DOS攻击的安全性程序错误。\n信息泄漏：指不愿公开的信息被公开了，比如用户名被公开或密码暴露。</p>\n<p>有代表性的攻击手段：</p>\n<ul>\n<li>缓冲区溢出</li>\n<li>整数溢出</li>\n<li>跨站脚本攻击(XSS)</li>\n<li>SQL注入</li>\n<li>跨站点伪造请求(CSRF)</li>\n</ul>\n',summary:'<hr>\n<p>第一次读这本书，是我还在读书的时候，那时的我正为C++这样的语言而苦恼，就这样接触了ruby，ruby是一门动态类型的语言，语法优雅，非常灵活，也因为它我开始开发web程序。这本书并不是一本ruby程序指南，而是一本描述程序世界的书籍，虽然讲得不那么深入，却很广泛。</p>\n<p><img data-src="/img/matz/matz.jpg" alt="matz"></p>\n'},{meta:{title:"booker.js,一个web-book 生成工具",date:"2015-12-20T15:36:51.000Z",tags:["nodeJS","开源项目"],id:"12",createTime:"2015-12-20",url:"2015-12-20-booker.js,一个web-book 生成工具",strTag:"nodeJS、开源项目"},content:'<hr>\n<div style="padding:100px 0;font-size:48px;color:#A21518;border-bottom: 2px dot #222;background:#fff;text-align:center;">booker.js——a simple book framework</div>\n\n<p>最近一直在用markdown来写文章，有时候会写小文集，那么博客这样的平台不太适合，于是将博客生成工具的部分功能提取出来，做了一个小的书籍生成工具，写博客和写书是的差别还是很大的，所以之后也会单独更新该项目。</p>\n<h2 id="-">功能：</h2>\n<ul>\n<li>markdown生成html格式书籍 </li>\n<li>命令行操作</li>\n<li>可定制主题</li>\n<li>示例</li>\n</ul>\n<h2 id="npm-">npm安装</h2>\n<p>目前代码已以npm包的形式发布，可通过npm安装</p>\n<h2 id="docs">docs</h2>\n<ul>\n<li><a href="http://yangxiaofu.com/booker/docs/dest/">document</a></li>\n<li><a href="https://github.com/xiaofuzi/booker">github</a></li>\n</ul>\n',summary:'<hr>\n<div style="padding:100px 0;font-size:48px;color:#A21518;border-bottom: 2px dot #222;background:#fff;text-align:center;">booker.js——a simple book framework</div>\n\n<p>最近一直在用markdown来写文章，有时候会写小文集，那么博客这样的平台不太适合，于是将博客生成工具的部分功能提取出来，做了一个小的书籍生成工具，写博客和写书</p>\n'},{meta:{title:"CommonJS模块加载工具实现",date:"2016-01-02T15:36:51.000Z",tags:["nodeJS","开源项目"],id:"13",createTime:"2016-01-02",url:"2016-01-02-CommonJS模块加载工具实现",strTag:"nodeJS、开源项目"},content:'<hr>\n<p>module.exports 和 exports 有时会让人迷惑，深入了解才发现是如此的简单。模块加载现在已经渐渐成为js开发中的一个必不可少的功能，所以在这里简单的实现一个遵循commonJS规范的模块加载工具，下面是核心代码。\n注：浏览器端因为同步加载方式可能会阻塞，所以一般使用的是AMD规范，如requireJS.</p>\n<pre><code class="lang-js">var fs = require(&#39;fs&#39;),\n    vm = require(&#39;./sandbox&#39;),\n    pathFormat = require(&#39;./helper/formatPath&#39;);\n\n/*\n * global variable myrequire\n */\nmodule.exports = global.myrequire = myrequire;\n\n/*\n * params {modName} required mod name\n * return {exports} exports mod \n */\n\n\nfunction myrequire(modname) {\n    modname = pathFormat(modname);\n    /*\n     * cache\n     */\n    if (modname in myrequire.cache) {\n        return myrequire.cache[modname];\n    }\n\n\n    var modScript = fs.readFileSync(modname, &#39;utf8&#39;);\n    var myexports = vm.run(modScript);\n    myrequire.cache[modname] = myexports;\n\n    return myexports;\n};\n\n/*\n * cache required modules\n */\nmyrequire.cache = Object.create(null);\n</code></pre>\n<h2 id="sandbox-implements">sandbox implements</h2>\n<ul>\n<li>initila commit 使用的是 new Function 来实现</li>\n<li>现使用nodeJS的vm模块</li>\n</ul>\n<h2 id="node-">node原生模块兼容</h2>\n<ul>\n<li>支持require和module.exports/exports</li>\n<li>如需要更多全局变量支持可直接挂载在global下</li>\n</ul>\n<h2 id="guide">guide</h2>\n<ul>\n<li>myrequire()-导入</li>\n<li>mymodule()-导出</li>\n<li>使用绝对路径</li>\n</ul>\n<p>github: <a href="https://github.com/xiaofuzi/commonJS">https://github.com/xiaofuzi/commonJS</a></p>\n',summary:"<hr>\n<p>module.exports 和 exports 有时会让人迷惑，深入了解才发现是如此的简单。模块加载现在已经渐渐成为js开发中的一个必不可少的功能，所以在这里简单的实现一个遵循commonJS规范的模块加载工具，下面是核心代码。\n注：浏览器端因为同步加载方式可能会阻塞，所以一般使用的是AMD规范，如requireJS.</p>\n<p>```js\nvar fs = require(&#39;fs&#39;),\n    vm = require(&#39;./sandbox&#39;),\n    pathFormat = req</p>\n"},{meta:{title:"基于NodeJS实现的一个css预处理器",date:"2015-12-14T15:36:51.000Z",tags:["nodeJS","开源项目"],id:"14",createTime:"2015-12-14",url:"2015-12-14-基于NodeJS实现的一个css预处理器",strTag:"nodeJS、开源项目"},content:'<hr>\n<div class="header-preview" style=""><h2>json_script,基于nodeJS实现的css预处理器</h2><p>just for fun?</p></div>\n\n<p>一时兴起，想用json格式来编写css，然后就出现了json_script.json是一种十分简洁的数据格式，学过javascript的人都会用，现在已作为web中传递数据的一种主要的数据格式，所以也有很多时候需要将json格式的数据转换成css、html。既然如此，为什么不能直接将json转为web页面呢？web页面基本上是由css/html/javascript组成的，所以可以用json或是javascript来直接生成一张web页面那不是很方便？</p>\n<h2 id="just-for-fun-">just for fun?</h2>\n<p>虽然只是因为有趣，但我还是发现有人已经做出了这样的东西，而且还很不错。但依然不影响我去做这样一个东西的兴趣，这也是在web组件化上探索的一步。</p>\n<div><a href="https://github.com/xiaofuzi/json_script" target="_blank"><img style="position: fixed; top: -7px; right: 0; border: 0;z-index: 999;" src="https://i.alipayobjects.com/e/201211/1dbSqT9ykm.png" width="149" height="149" alt="Fork me on GitHub"></a></div>\n\n<h2 id="-">原理？</h2>\n<p>这里得益于json这种数据格式非常简洁，已经不再需要正则这种进行数据提取。因为它已经自带了很好的结构化的信息。</p>\n<ul>\n<li>传入json格式数据</li>\n<li>转换为中间数据格式(css是不支持嵌套的，转换成不嵌套的格式)</li>\n<li>生成css格式数据</li>\n</ul>\n<h3 id="json">json</h3>\n<pre><code class="lang-javascript">{\n    &#39;.wrap&#39;: {\n        &#39;margin-top&#39;: &#39;20px&#39;,\n        &#39;padding&#39;: &#39;20px&#39;,\n        &#39;color&#39;: &#39;#444&#39;,\n        p: {\n            &#39;padding-top&#39;: &#39;20px&#39;,\n            &#39;font-size&#39;: &#39;28px&#39;\n        }\n    }\n}\n</code></pre>\n<h3 id="-json_css">中间格式-json_css</h3>\n<pre><code class="lang-javascript">{\n    &#39;.wrap&#39;: {\n        &#39;margin-top&#39;: &#39;20px&#39;,\n        &#39;padding&#39;: &#39;20px&#39;,\n        &#39;color&#39;: &#39;#444&#39;,\n        p: false\n    }\n    &#39;.wrap p&#39;: {\n            &#39;padding-top&#39;: &#39;20px&#39;,\n            &#39;font-size&#39;: &#39;28px&#39;\n        }\n}\n</code></pre>\n<h3 id="css-">css格式</h3>\n<pre><code class="lang-javascript">.wrap {\n  margin-top: 20px;\n  padding: 20px;\n  color: #444;\n}\n.wrap p {\n  padding-top: 20px;\n  font-size: 28px;\n}\n</code></pre>\n<h2 id="-">如何安装</h2>\n<pre><code class="lang-git">npm install --save json_script\n</code></pre>\n<p>全局安装</p>\n<pre><code class="lang-git">npm install json_script -g\n</code></pre>\n<p>项目介绍: <a href="http://yangxiaofu.com/json_script/readme.html">http://yangxiaofu.com/json_script/readme.html</a>\ngithub: <a href="https://github.com/xiaofuzi/json_script">https://github.com/xiaofuzi/json_script</a></p>\n',summary:'<hr>\n<div class="header-preview" style=""><h2>json_script,基于nodeJS实现的css预处理器</h2><p>just for fun?</p></div>\n\n<p>一时兴起，想用json格式来编写css，然后就出现了json_script.json是一种十分简洁的数据格式，学过javascript的人都会用，现在已作为web中传递数据的一种主要的数据格式，所以也有很多时候需要将json格式的数据转换成css、html。既然如此，为什么不能直接将json转为web页面呢？web页面基本上是由css/html/javascript组成的，所以可以用json或是javascript来直接生成一张web页面那不是很方便？</p>\n<h2 id="just-for-fun-">just for fun?</h2>\n<p>虽然只是因为有趣，但我还是发现有人已经做出了这样的东西，而且还很不错。但依然不影响我去做这样一个东西的兴趣，这也是在web组件化上探索的一步。</p>\n'},{meta:{title:"轮播图，So easy",date:"2015-11-25T15:36:51.000Z",archives:"pl",tags:["css","js","jquery","插件"],id:"15",createTime:"2015-11-25",url:"2015-11-25-轮播图，So easy",strTag:"css、js、jquery、插件"},content:'<hr>\n<h2 id="-">轮播效果预览</h2>\n<p><style>iframe{width: 100%;min-height: 400px;}</style></p>\n<iframe src="/compents/galler/index.html" frameborder="0"></iframe>\n\n\n\n\n\n<h3 id="-">结构布局</h3>\n<p>三层布局：</p>\n<p>——page-wrapp\n—— ——item-wrap[轮播效果是通过这一层的滚动实现的]\n—— —— ——sub-item</p>\n<p>说明：</p>\n<ul>\n<li>page-wrapp作为轮播盒子框架，即限定可见区域</li>\n<li>item-wrap作为轮播外层的盒子</li>\n<li>sub-item作为每一个轮播图的盒子</li>\n</ul>\n<p>1 .page-wrapp的宽高等于sub-item的宽高,page-wrapp的overflow属性设为hidden,这样超出page-wrap范围的将是不可见的\n2 .item-wrap的宽度等于sub-item的总宽度，,多个sub-item并排[可以用浮动的方式实现],高度等于sub-item的高度.\n3 .这样虽然item-wrap的宽度大于page-wrapp的宽度，但因为page-wrapp设置了overflow:hidden,所以也只能显示一张图片的大小。\n4 .为了得到轮播的效果这时可以使用动画将item-wrap在水平方向平移，也就得到了轮播的效果</p>\n<pre><code class="lang-html">&lt;div class=&quot;page-wrapp&quot;&gt;\n    &lt;div class=&quot;item-wrap&quot;&gt;\n        &lt;div class=&quot;sub-item&quot;&gt;\n            &lt;img src=&quot;/img/compents/background01.jpg&quot; alt=&quot;&quot; class=&quot;img-item&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;sub-item&quot;&gt;\n            &lt;img src=&quot;/img/compents/cat-cartoon.jpg&quot; alt=&quot;&quot; class=&quot;img-item&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;sub-item&quot;&gt;\n            &lt;img src=&quot;/img/compents/cup.jpg&quot; alt=&quot;&quot; class=&quot;img-item&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;sub-item&quot;&gt;\n            &lt;img src=&quot;/img/compents/leaf.jpg&quot; alt=&quot;&quot; class=&quot;img-item&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;sub-item&quot;&gt;\n            &lt;img src=&quot;/img/compents/nature01.jpg&quot; alt=&quot;&quot; class=&quot;img-item&quot;&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>css样式</p>\n<pre><code class="lang-css">/*这里的样式是针对全屏设置的，最外层的轮播框架宽高在此设为浏览器窗口的大小*/\n.page-wrapper,\n    .page-wrapper .item-wrap,\n    .page-wrapper .sub-item,\n    .page-wrapper .sub-item .img-item {\n        position: relative;\n        height: 100%;\n    }\n\n    .page-wrapper {\n        min-width: 720px;\n        min-height: 500px;\n        overflow: hidden;\n        zoom: 1;\n    }\n\n    .page-wrapper .item-wrap {\n        /*因为有5个子元素，所以宽度是5个子元素之和[子元素和父级的宽度是相等的],所以总宽度为父级的5倍*/\n        width: 500%;\n        overflow: hidden;\n        zoom: 1;\n    }\n\n    .page-wrapper .sub-item {\n        float: left;\n        width: 20%;\n    }\n\n    .page-wrapper .sub-item .img-item {\n        width: 100%;\n    }\n</code></pre>\n<h3 id="-">轮播动画实现</h3>\n<p>添加轮播按钮，点击时触发轮播事件</p>\n<pre><code class="lang-html">&lt;!-- 轮播按钮 --&gt;\n&lt;div class=&quot;left-btn-wrap&quot;&gt;\n    &lt;span class=&quot;silder-left-btn&quot; id=&quot;leftBtn&quot;&gt;&lt;/span&gt;\n&lt;/div&gt;\n&lt;div class=&quot;right-btn-wrap&quot;&gt;\n    &lt;span class=&quot;silder-right-btn&quot; id=&quot;rightBtn&quot;&gt;&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>\n<p>这里可以使用jQuery的animate动效实现轮播效果</p>\n<pre><code class="lang-javascript">/*左滚动\n参数说明：\n$itemWrap=$(&#39;.item-wrap&#39;); 轮播外层盒子\n*/\n$leftBtn.on(&#39;click&#39;, function(){\n    $itemWrap.animate({\n        &#39;margin-left&#39;: 0 - $imgItems.width()\n    }, 1000, function(){\n        /*轮播一次就动态的将第一个图片元素移到最后，变成最后一张图片，这样可以实现无限循环的效果*/\n        $itemWrap.append($(&#39;.item-wrap .sub-item&#39;).first());\n        $itemWrap.css(&quot;margin-left&quot;,0);\n    })\n}）\n\n/*右滚动*/\n$rightBtn.on(&#39;click&#39;, function(){\n    $itemWrap.prepend($(&#39;#itemWrap .sub-item&#39;).last());\n        $itemWrap.css(&quot;margin-left&quot;,0 - $imgItems.width());\n    $itemWrap.animate({\n        &#39;margin-left&#39;: 0\n    }, 1000)\n}）\n</code></pre>\n<p>这样就可以实现一个简单的轮播图的效果，上面给出的事例还带有轮播导航条[右下角],这可以通过增加一个data-index属性来记录轮播索引位置。</p>\n<p>注：这中做法每旋转一次就需要动态的修改DOM结构，另一种思路是将第一屏copy到最后的方式来实现无缝衔接</p>\n<p><a href="/compents/galler/index.html">查看完整demo</a></p>\n<p>github:<a href="https://github.com/xiaofuzi/gallery">https://github.com/xiaofuzi/gallery</a></p>\n',
summary:'<hr>\n<h2 id="-">轮播效果预览</h2>\n<p><style>iframe{width: 100%;min-height: 400px;}</style></p>\n<iframe src="/compents/galler/index.html" frameborder="0"></iframe>\n\n'},{meta:{title:"图片延迟加载简单实现",date:"2015-11-20T16:21:55.000Z",tags:"js",archives:"pl",id:"16",createTime:"2015-11-21",url:"2015-11-21-图片延迟加载简单实现",strTag:"js"},content:'<hr>\n<style>img {opacity: 1;transition: opacity 0.2s;max-width: 100%;}img[data-src] {opacity: 0;}</style>\n\n<p>图片往往是造成网页加载缓慢的原因，通过延迟图片的加载可以提高用户体验，优先加载重要的内容。</p>\n<p><img data-src="/img/tree.png" alt="tree"></p>\n<p><img data-src="/img/christina.jpg" alt="christina"></p>\n<h2 id="1-data-src-img-src-">1.使用data-src属性代替img的src属性</h2>\n<pre><code class="lang-html">&lt;div class=&quot;wrapper&quot;&gt;\n        &lt;img data-src=&quot;./img/lazy.jpg&quot; alt=&quot;lazy.jpg&quot;&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-css">/*先将待加载图片隐藏，加载完成后显示*/\nimg {\n        opacity: 1;\n        transition: opacity 0.2s;\n    }\n\n    img[data-src] {\n        opacity: 0;\n    }\n</code></pre>\n<p>说明：img标签并不会将图片嵌入到网页中，而是提供一个占位符即给图片提供一个显示的空间。图片的显示需要浏览器根据src属性来加载。所以上述方式并不会加载图片。</p>\n<h2 id="2-html-js-img-data-src-src-">2.当html文档加载完成后通过js将img的data-src属性转换为src,从而加载图片</h2>\n<pre><code class="lang-javascript">/*原生js实现*/\n[].forEach.call(document.querySelectorAll(&#39;img[data-src]&#39;), function(img) {\n        img.setAttribute(&#39;src&#39;, img.getAttribute(&#39;data-src&#39;));\n        img.onload = function() {\n            /*图片加载完成后data-src属性就可以去掉了*/\n            img.removeAttribute(&#39;data-src&#39;);\n        };\n    });\n/*jQuery实现*/\n$(&#39;img[data-src]&#39;).each(function(){\n    var $img = $(this);\n    $img.attr(&#39;src&#39;, $img.attr(&#39;data-src&#39;));\n    $img.load(function(){\n        $img.removeAttr(&#39;data-src&#39;);\n    })\n});\n</code></pre>\n<p>说明：遍历所有包含data-src属性的img元素然后将data-src属性转换为src属性</p>\n<script>\n    [].forEach.call(document.querySelectorAll(\'img[data-src]\'), function(img) {\n        img.setAttribute(\'src\', img.getAttribute(\'data-src\'));\n        img.onload = function() {\n            /*图片加载完成后data-src属性就可以去掉了*/\n            img.removeAttribute(\'data-src\');\n        };\n    });\n<\/script>\n',summary:'<hr>\n<style>img {opacity: 1;transition: opacity 0.2s;max-width: 100%;}img[data-src] {opacity: 0;}</style>\n\n<p>图片往往是造成网页加载缓慢的原因，通过延迟图片的加载可以提高用户体验，优先加载重要的内容。</p>\n<p><img data-src="/img/tree.png" alt="tree"></p>\n'},{meta:{title:"jQuery is not must for us——事件",date:"2015-11-25T12:40:32.000Z",tags:"jquery",archives:"pl",id:"17",createTime:"2015-11-25",url:"2015-11-25-jQuery is not must for us——事件",strTag:"jquery"},content:'<hr>\n<p>在这里我们将对比Web提供的事件API与jQuery 事件函数间的差别。jQuery给我们提供了非常好的事件API,但理解好底层是如何实现的可以帮助我们更好的使用jQuery,同时遇到错误也能修复。</p>\n<ul>\n<li>发送DOM事件</li>\n<li>发送自定义事件</li>\n<li>监听事件</li>\n<li>移除事件句柄</li>\n<li>修改事件</li>\n<li>事件预测</li>\n<li>键盘事件</li>\n<li>鼠标事件</li>\n<li>浏览器加载事件</li>\n<li>老式浏览器的支持</li>\n</ul>\n<h2 id="dom-">DOM事件发送</h2>\n<p>以点击事件为例：\nfocus/blur/submit语法相同</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(a).click();\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">a.click();\n</code></pre>\n<h2 id="-">自定义事件</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">/*触发一个事件(custom-event)*/\n$(&#39;element&#39;).trigger(&#39;custom-event&#39;);\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">var event = document.createEvent(&#39;Event&#39;);\nevent.initEvent(&#39;custom-event&#39;, true, true); /*第二和第三参数说明属于冒泡事件并可取消默认事件*/\nsomeElement.dispatchEvent(event);    /*发起事件*/\n\n/*ie not support*/\nvar event = new CustomEvent(&#39;custom-event&#39;, {bubbles: true, cancelable: true});\nsomeElement.dispatchEvent(event);\n</code></pre>\n<h2 id="-">事件监听</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(&#39;element&#39;).on(&#39;click&#39;, function(){\n    /*当点击的时候做点什么*、\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">/*ie 9*/\nelement.addEventLister(&#39;click&#39;, function(){\n    /*当点击的时候做点什么*、\n})\n</code></pre>\n<h2 id="-">移除事件</h2>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">/*jquery还提供了一个移除某元素上所有事件的api*/\n$(&#39;element&#39;).off(&#39;click&#39;, myEventHander);\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">elment.removeEventLister(&#39;click&#39;, myEventHander);\n</code></pre>\n<h2 id="-">事件修改</h2>\n<p>阻止事件冒泡</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(element).on(&#39;event&#39;, function(event){\n    event.stopPropagation();\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">element.addEventListener(&#39;event&#39;, function(event){\n    event.stopPropagation();\n})\n</code></pre>\n<p>阻止其它事件对当前元素的影响</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(element).on(&#39;event&#39;, function(event){\n    event.stopImmediatePropagation();\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">element.addEventListener(&#39;event&#39;, function(event){\n    event.stopImmediatePropagation();\n})\n</code></pre>\n<p>阻止浏览器默认事件，比如一个a标签的跳转事件</p>\n<h3 id="jquery">jQuery</h3>\n<pre><code class="lang-javascript">$(Aelement).on(&#39;click&#39;, function(event){\n    event.stopPropagation();\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">Aelement.addEventListener(&#39;click&#39;, function(event){\n    event.preventDefault();\n})\n</code></pre>\n<h2 id="-">预测事件</h2>\n<pre><code class="lang-html">&lt;ul id=&quot;my-list&quot;&gt;\n    &lt;li&gt;foo &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n    &lt;li&gt;bar &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n    &lt;li&gt;abc &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n    &lt;li&gt;123 &lt;button&gt;x&lt;/button&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>点击按钮的时候删除其li标签</p>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(&#39;#my-list&#39;).on(&#39;click&#39;, &#39;BUTTON&#39;, function() {\n    $(this).parent().remove();\n});\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">document.getElementById(&#39;my-list&#39;).addEventListener(&#39;click&#39;, function(event) {\n    var clickedEl = event.target;\n    if(clickedEl.tagName === &#39;BUTTON&#39;) {\n       var listItem = clickedEl.parentNode;\n       listItem.parentNode.removeChild(listItem);\n    }\n});\n</code></pre>\n<h2 id="-">键盘事件</h2>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(document).keydown(function(event){\n    if(event.ctrlkey &amp;&amp; event.which === 72){\n        /*ctrl+H*/\n    }\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">document.addEventListener(&#39;keydown&#39;, function(event) {\n    if (event.ctrlKey &amp;&amp; event.which === 72) {\n        /*ctrl+H*/\n    }\n});\n</code></pre>\n<h2 id="-">鼠标事件</h2>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(&#39;element&#39;).hover(function hoverIn(){\n\n},\nfunction hoverOut(){\n\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">someEl.addEventListener(&#39;mouseover&#39;, function() {\n});\n\nsomeEl.addEventListener(&#39;mouseout&#39;, function() {\n});\n</code></pre>\n<h2 id="-">浏览器加载事件</h2>\n<ul>\n<li>文档加载</li>\n<li>样式加载</li>\n<li>图片加载</li>\n<li>iframes加载</li>\n</ul>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(window).load(function(){\n    /*页面加载并渲染完毕*/\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">window.addEventListener(&#39;load&#39;, function(){\n    /*页面加载并渲染完毕*/\n})\n</code></pre>\n<p>文档加载完毕但未渲染</p>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">$(document).ready(function(){\n    /*文档加载完毕*/\n})\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">document.addEventListener(&#39;DOMContentLoaded&#39;,function(){\n\n})\n</code></pre>\n<h3 id="jquery">jquery</h3>\n<pre><code class="lang-javascript">\n</code></pre>\n<h3 id="dom-api">DOM API</h3>\n<pre><code class="lang-javascript">\n</code></pre>\n',summary:"<hr>\n<p>在这里我们将对比Web提供的事件API与jQuery 事件函数间的差别。jQuery给我们提供了非常好的事件API,但理解好底层是如何实现的可以帮助我们更好的使用jQuery,同时遇到错误也能修复。</p>\n<ul>\n<li>发送DOM事件</li>\n<li>发送自定义事件</li>\n<li>监听事件</li>\n<li>移除事件句柄</li>\n<li>修改事件</li>\n<li>事件预测</li>\n<li>键盘事件</li>\n<li>鼠标事件</li>\n<li>浏览器加载事件</li>\n<li>老式浏览器的支持</li>\n</ul>\n"},{meta:{title:"简单的dom库和轻量级mvvm框架的尝试",date:"2016-02-21T19:07:19.000Z",tags:["js"],id:"18",createTime:"2016-02-22",url:"2016-02-22-简单的dom库和轻量级mvvm框架的尝试",strTag:"js"},content:'<hr>\n<p>很早之前就有去jquery化的打算，但一直在犹豫，直到最近用原生的写的越来越多，所以将jquery的功能抽取出来，封装了一个简单的 dom 库。jquery是一个非常好的库，使用非常方便，但随着浏览器兼容性越来越好，jquery也显得并不是那么必要。除此之外，现在热门的前端框架大多不依赖于jquery,而是使用原生的js或是自己封装一个小的库，原生的js能带来一定速度上的提升，同时编码量也并不比使用jquery多多少，所以个人觉得去jquery也将成为一个趋势。</p>\n<p>mvvm最近特别火，仿佛不熟悉某一款框架都不好出去见人了，自己也用了许多，一直没有特别顺手的。一直也想写一个组件式的库或框架，在筹备的过程中一直没有好的思路，所以索性先模仿其它框架来写，再从中体会。本次参考angularJS写了一个微型的框架，从中也做了不少改进，本着轻框架的原则，将更多的逻辑交由用户去做，即只在常规的css+html+js的基础上做些改进.虽然如此离实际使用还是有距离，不过再写的过程中却发现不少问题，所以说造轮子其实也是很有意义的。</p>\n<h3 id="tiny-js-a-simple-dom-libary-">tiny.js(a simple dom libary)</h3>\n<p>暂且就这么命名好了，功能上还是参考了jquery的很多特性，同时也做了不少的改进。</p>\n<h3 id="-">特性</h3>\n<ul>\n<li>链式调用</li>\n<li>获取单一 dom 元素</li>\n<li>拟人化的api</li>\n<li>函数式编程</li>\n</ul>\n<h2 id="api-doc-">api doc:</h2>\n<h3 id="core">core</h3>\n<ul>\n<li>DOM</li>\n<li>all</li>\n<li>each</li>\n<li>map</li>\n</ul>\n<h3 id="dom">dom</h3>\n<ul>\n<li>val</li>\n<li>clone</li>\n<li>append</li>\n<li>prepend</li>\n<li>after</li>\n<li>before</li>\n<li>remove</li>\n<li>prev</li>\n<li>next</li>\n<li>siblings</li>\n<li>addClass</li>\n<li>removeClass</li>\n<li>toggleClass</li>\n<li>hasClass</li>\n<li>attr</li>\n<li>removeAttr</li>\n<li>text</li>\n<li>html</li>\n<li>replaceWith</li>\n</ul>\n<h3 id="css">css</h3>\n<ul>\n<li>css</li>\n<li>height</li>\n<li>width</li>\n<li>innerHeight</li>\n<li>innerWidth</li>\n<li>outHeight</li>\n<li>outWidth</li>\n<li>position</li>\n<li>viewportPostion</li>\n<li>scrollTop</li>\n<li>scrollLeft</li>\n</ul>\n<h3 id="event">event</h3>\n<ul>\n<li>on</li>\n<li>off</li>\n<li>trigger</li>\n<li>triggerCustom</li>\n</ul>\n<h3 id="ajax">ajax</h3>\n<ul>\n<li>getJSON</li>\n<li>post</li>\n<li>get</li>\n</ul>\n<h3 id="animation">animation</h3>\n<ul>\n<li>fadeIn</li>\n<li>fadeOut</li>\n<li>hide</li>\n<li>show</li>\n</ul>\n<p>待完善\ngithub: <a href="https://github.com/xiaofuzi/tiny.js">https://github.com/xiaofuzi/tiny.js</a></p>\n<h2 id="con-js">con.js</h2>\n<p>核心思想： 给声明式的html增添逻辑编程的能力。</p>\n<p>大多数情况下的web页面使用html+css+js就可以，不需要过多的库和框架，这三者的结合其实能满足大部分的需求，但富web应用还是显得有些不足，需要手动的不断的反复的更新dom,但如果只是因为一张页面上需要几个功能比较复杂的组件就去引入框架又显得有些没有必要，所以说大多数情况下需要的是轻量化的框架。</p>\n<h3 id="-">特性</h3>\n<ul>\n<li>通过指令，给html增加上下文的概念(如同函数的上下文)</li>\n<li>双向数据绑定</li>\n<li>angular式的脏检查更新数据</li>\n<li>模板语法</li>\n<li>静态数据类型</li>\n</ul>\n<p>more and more.....</p>\n<p>github: <a href="https://github.com/xiaofuzi/con.js">https://github.com/xiaofuzi/con.js</a></p>\n',summary:"<hr>\n<p>很早之前就有去jquery化的打算，但一直在犹豫，直到最近用原生的写的越来越多，所以将jquery的功能抽取出来，封装了一个简单的 dom 库。jquery是一个非常好的库，使用非常方便，但随着浏览器兼容性越来越好，jquery也显得并不是那么必要。除此之外，现在热门的前端框架大多不依赖于jquery,而是使用原生的js或是自己封装一个小的库，原生的js能带来一定速度上的提升，同时编码量也并不比使用jquery多多少，所以个人觉得去jquery也将成为一个趋势。</p>\n<p>mvvm最近特别火</p>\n"},{meta:{title:"帽子还是蛇，黑匣子真是我们需要的吗？",tags:"随笔",date:"2015-11-29T20:38:41.000Z",id:"19",createTime:"2015-11-30",url:"2015-11-30-帽子还是蛇，黑匣子真是我们需要的吗？",strTag:"随笔"},content:'<hr>\n<p><style>blockquote p{background:#fefbec;padding: 5px 10px;}</style></p>\n<h2 id="-">小王子与飞行员</h2>\n<p><img src="/img/little-price/prince02.jpg" alt="prince"></p>\n<blockquote>\n<p>《小王子》是法国作家安东尼·德·圣.埃克苏佩里于1942年写成的著名儿童文学短篇小说。本书的主人公是来自外星球的小王子。书中以一位飞行员作为故事叙述者，讲述了小王子从自己星球出发前往地球的过程中，所经历的各种历险。作者以小王子的孩子式的眼光，透视出成人的空虚、盲目，愚妄和死板教条，用浅显天真的语言写出了人类的孤独寂寞、没有根基随风流浪的命运。</p>\n</blockquote>\n<h2 id="-">帽子还是蛇</h2>\n<p>飞行员小的时候[那时他想成为一名画家]对丛林中的奇遇想得很多，于是，于是他也用彩色铅笔画出了第一 副图画。第一号作品。它是这样的：</p>\n<p><img src="/img/little-price/hat.jpg" alt="蛇吞象"></p>\n<p>当他把这副杰作拿给大人看时，大人们的反应都是：&quot;这是一顶帽子&quot;</p>\n<blockquote>\n<p>为了让大人们能看懂这幅画，于是我又把巨蟒肚子里的情况画了出来，以便让大人们能够看懂。这些大人总是需要解释。我的第二号作品是这样的：</p>\n</blockquote>\n<p><img src="/img/little-price/sneak.jpg" alt="蛇吞象"></p>\n<p>但这对大人们来说并不是什么值得关心的事。</p>\n<blockquote>\n<p>就这样，在六岁的那年，我就放弃了 当画家这一美好的职业。我的第一号、第二号作品的不成功，使我泄了气。这些 大人们，靠他们自己什么也弄不懂，还得老是不断地给他们作解释。</p>\n</blockquote>\n<p>你是不是第一眼看到那幅画，你就在心里告知自己，那不过是一顶帽子而已。Can we find something else?</p>\n<p>编程是一种艺术，如同画家、音乐家一样，我们的作品需要想象力的支持。</p>\n<h2 id="-">黑匣子真是我们需要的吗？</h2>\n<p>飞行员因为飞机出了故障，被迫降落在远离人烟的撒哈拉沙漠上，这时一位迷人而神秘的小男孩出现了，执拗地请“我”给他画一只小绵羊。他就是小王子，纯洁、忧郁、爱提问。</p>\n<p>于是飞行员给他画了第一只羊：</p>\n<p><img src="/img/little-price/sheep01.jpg" alt="病重的羊"></p>\n<p>小王子专心地看着，随后又说：</p>\n<blockquote>\n<p>“我不要，这只羊已经病得很重了。给我重新画一只。”</p>\n</blockquote>\n<p>于是飞行员又画了一只：</p>\n<p><img src="/img/little-price/sheet02.jpg" alt="公羊"></p>\n<blockquote>\n<p>我的这位朋友天真可爱地笑了，并且客气地拒绝道：“你看，你画的不是小羊，是头公羊，还有犄角呢。</p>\n</blockquote>\n<p>于是我又重新画了一张。\n<img src="/img/little-price/sheet03.jpg" alt="老羊"></p>\n<p>这副画同前几副一样又被拒绝了。</p>\n<blockquote>\n<p>“这一只太老了。我想要一只能活得长的羊。”</p>\n</blockquote>\n<p>我不耐烦了。因为我急于要检修发动机，于是就草草画了这张画，并且匆匆 地对他说道：</p>\n<p><img src="/img/little-price/sheeet-04.jpg" alt="箱子"></p>\n<blockquote>\n<p>“这是一只箱子，你要的羊就在里面。”</p>\n</blockquote>\n<p>这时我十分惊奇地看到我的这位小评判员喜笑颜开。他说：</p>\n<blockquote>\n<p>“这正是我想要的，……你说这只羊需要很多草吗？”\n“为什么问这个呢？”\n“因为我那里地方非常小……”\n“我给你画的是一只很小的小羊，地方小也够喂养它的。”\n他把脑袋靠近这张画。\n“并不象你说的那么小……瞧！它睡着了……”</p>\n</blockquote>\n<p>作为一名程序员，我们拥有许多的黑箱，而且我们使用的不亦乐乎。但是我们是否考虑过，当黑箱无法正常工作的时候，我们该怎么办？</p>\n',summary:'<hr>\n<p><style>blockquote p{background:#fefbec;padding: 5px 10px;}</style></p>\n<h2 id="-">小王子与飞行员</h2>\n<p><img src="/img/little-price/prince02.jpg" alt="prince"></p>\n<blockquote>\n<p>《小王子》是法国作家安东尼·德·圣.埃克苏佩里于1942年写成的著名儿童文学短篇小说。本书的主人公是来自外星球的小王子。书中以一位飞行员作为故事叙述者，讲述了小王子从自己星球出发前往地球的过程中，所经历的各种历险。作者以小王子的孩子式的眼光，透视出成人的空虚、盲目，愚妄和死板教条，用浅显天真的语言写出了人类的孤独寂寞、没有根基随风流浪的命运。</p>\n</blockquote>\n'},{meta:{title:"jQuery is not must for us",date:"2015-11-24T11:40:32.000Z",tags:"jquery",archives:"pl",id:"20",createTime:"2015-11-24",url:"2015-11-24-jQuery is not must for us",strTag:"jquery"},content:'<hr>\n<p class="text-center"><a href="https://brendaneich.com/2015/06/from-asm-js-to-webassembly/"><img src="/img/compents/jquery/yunhbc.png" alt="yu no have byte code"></a></p>\n\n<h2 id="javascript-https-brendaneich-com-">javascript之父:<a href="https://brendaneich.com/">https://brendaneich.com/</a></h2>\n<p class="text-center"><a href="https://en.wikipedia.org/wiki/Brendan_Eich"><img src="/img/compents/jquery/Brendan.jpg" alt="javascript之父"></a></p>\n\n<p>许多刚开始学习js的开发者将jquery当做javascript本身，这其实是一个很大的误解。</p>\n<p>在我们学习javascript的时候应该区分开这三者的区别：</p>\n<ul>\n<li>javascript</li>\n<li>Web API</li>\n<li>jQuery(或者是其它的框架)</li>\n</ul>\n<p>注意jQuery只是一个库，它并不是javascript本身。这里我们从下面几个方面来对比web API与jquery在使用上的差别。</p>\n<h2 id="-">目录</h2>\n<ul>\n<li><a href="/2015/11/28/jquery-is-not-must/DOM-selector/">选择器</a></li>\n<li><a href="/2015/11/24/jquery-is-not-must/DOM-manipulation/">DOM操作</a></li>\n<li><a href="/2015/11/24/jquery-is-not-must/ajax-request/">Ajax调用</a></li>\n<li><a href="/2015/11/25/jquery-is-not-must/DOM-Event/">事件</a></li>\n<li>辅助函数</li>\n</ul>\n',summary:'<hr>\n<p class="text-center"><a href="https://brendaneich.com/2015/06/from-asm-js-to-webassembly/"><img src="/img/compents/jquery/yunhbc.png" alt="yu no have byte code"></a></p>\n\n<h2 id="javascript-https-brendaneich-com-">javascript之父:<a href="https://brendaneich.com/">https://brendaneich.com/</a></h2>\n<p><p class="text-center">&lt;a href</p>\n'},{meta:{title:"js lexer and highlighting",date:"2016-01-09T11:10:53.000Z",tags:["js","parser"],id:"21",createTime:"2016-01-09",url:"2016-01-09-js lexer and highlighting",strTag:"js、parser"},content:'<hr>\n<h2 id="js-">js代码分词以及高亮简单实现</h2>\n<h3 id="lexer">lexer</h3>\n<ul>\n<li>递归</li>\n<li>正则</li>\n</ul>\n<h3 id="highlighter">highlighter</h3>\n<p>highlighter作为lexer的一个中间件对lexer处理所得的token做进一步的处理，得到如下的形式代码：</p>\n<p>源码：</p>\n<pre><code class="lang-js">/**\n* some helper functions\n*/\nvar utils = module.exports = {};\n</code></pre>\n<p>高亮处理后：</p>\n<pre><code class="lang-html">&lt;span class=&quot;js-comment&quot;&gt;/**&lt;br /&gt;*&amp;nbsp;some&amp;nbsp;helper&amp;nbsp;\nfunctions&lt;br /&gt;*/&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;js-keyword&quot;&gt;var&lt;/span&gt;\n&amp;nbsp;&lt;span class=&quot;js-identifier&quot;&gt;utils&lt;/span&gt;&amp;nbsp;&lt;span class=&quot;\njs-punctuation&quot;&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class=&quot;js-identifier&quot;&gt;module\n&lt;/span&gt;&lt;span class=&quot;js-punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;js-\nidentifier&quot;&gt;exports&lt;/span&gt;&amp;nbsp;&lt;span class=&quot;js-punctuation&quot;&gt;=&lt;/\nspan&gt;&amp;nbsp;&lt;span class=&quot;js-punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;js-\npunctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;js-punctuation&quot;&gt;;&lt;/span&gt;\n</code></pre>\n<p>这里将js按如下进行划分：</p>\n<ul>\n<li>keyword</li>\n<li>identifier</li>\n<li>number</li>\n<li>punctuation</li>\n<li>string</li>\n<li>regexp</li>\n<li>function</li>\n<li>params</li>\n<li>comment</li>\n</ul>\n<p>给每一个类分别添加样式即得到高亮的效果。</p>\n<p><a href="/compents/high-lighter/js-highlighter.html">highlighter demo</a> \ngithub: <a href="https://github.com/xiaofuzi/parserJS">https://github.com/xiaofuzi/parserJS</a></p>\n',summary:'<hr>\n<h2 id="js-">js代码分词以及高亮简单实现</h2>\n<h3 id="lexer">lexer</h3>\n<ul>\n<li>递归</li>\n<li>正则</li>\n</ul>\n<h3 id="highlighter">highlighter</h3>\n<p>highlighter作为lexer的一个中间件对lexer处理所得的token做进一步的处理，得到如下的形式代码：</p>\n<p>源码：</p>\n<pre><code class="lang-js">/**\n* some helper functions\n*/\nvar utils = module.exports = {};\n</code></pre>\n<p>高亮处理后：\n```html\n<span class="js-comment">/**&lt;br /</p>\n'},{meta:{title:"不要再说正则表达式学不会，其实很简单",date:"2016-02-26T18:18:47.000Z",tags:["js"],id:"22",createTime:"2016-02-27",url:"2016-02-27-不要再说正则表达式学不会，其实很简单",strTag:"js"},content:'<hr>\n<p><img src="/img/regex.png" alt="regex expression"></p>\n<p>正则表达式在编程的过程中使用率非常的高，但很多人在学习的过程中往往侧重于语法的记忆而不去了解其实质，这让许多人对正则表达式感到畏惧，之前的我也是这样，但经过对正则表达式进一步的了解，其实它非常的简单，只不过为了描述字符串这样的无数据结构信息的数据它的语法不得不变得过于复杂，但如果理解了其原理，你反而会觉得其语法设计良好。</p>\n<ul>\n<li>并,记作 X|Y,表示的语言是正则表达式X与Y的并集，{a, b}。</li>\n<li>与:记作XY，表示的语言是将X的语言中的每个字符串后面连接上Y语言中的每一种字符串，再把所有这种连接的结果组成一种新的语言。</li>\n<li>克林闭包，记作X<em>,表示分别将零个，一个两个...无穷个X与自己连接，然后再求并，即 X</em> = ε|X|XX|XXX|....。</li>\n</ul>\n<p>优先级：\n克林闭包 &gt; 连接运算 &gt; 并运算;</p>\n<h2 id="-">正则表达式的扩展运算：</h2>\n<ul>\n<li>方括号表示括号内的字符并运算。[abc]就等于a|b|c</li>\n<li>方括号中以^字符开头，表示字符集中，排除方括号中的所有字符之后，所剩字符的并运算。[^ab]就表示除了ab以外所有字符求并。</li>\n<li>圆.点表示字符集内所有字符的并。因此 .* 这个表达式就能表示这种字符集所能组成的一切字符串。</li>\n<li>X?表示 X|ε 。表示X与空字符串之间可选。</li>\n<li>X+表示XX*。这等于限制了X至少要重复1次。</li>\n</ul>\n',summary:'<hr>\n<p><img src="/img/regex.png" alt="regex expression"></p>\n<p>正则表达式在编程的过程中使用率非常的高，但很多人在学习的过程中往往侧重于语法的记忆而不去了解其实质，这让许多人对正则表达式感到畏惧，之前的我也是这样，但经过对正则表达式进一步的了解，其实它非常的简单，只不过为了描述字符串这样的无数据结构信息的数据它的语法不得不变得过于复杂，但如果理解了其原理，你反而会觉得其语法设计良好。</p>\n<ul>\n<li>并,记作 X|Y,表示的语言是正则表达式X与Y的并集，</li>\n</ul>\n'},{meta:{title:"前端代码规范",date:"2015-11-03T09:58:55.000Z",archives:"pl",tags:["web","tool"],id:"23",createTime:"2015-11-03",url:"2015-11-03-前端代码规范",strTag:"web、tool"},content:'<hr>\n<h1 id="-">目录</h1>\n<ul>\n<li><a href="#HTML编码规范">HTML编码规范</a></li>\n<li><a href="#CSS编码规范">CSS编码规范</a></li>\n<li><a href="#javascript编码规范">javascript编码规范</a></li>\n</ul>\n<hr />\n\n<h1 id="html-">HTML编码规范</h1>\n<h2 id="-">语法</h2>\n<ul>\n<li>用4个空格来代替制表符（tab）</li>\n<li>嵌套元素应当缩进一次（即4个空格）。</li>\n<li>对于属性的定义，确保全部使用双引号，不要使用单引号。</li>\n<li>H5页面不需要在自闭合（self-closing）元素的尾部添加斜线(注：xhtml 1.0所有标签尾部都要添加斜线)。</li>\n<li>不要省略可选的结束标签（closing tag）</li>\n</ul>\n<pre><code>/*自闭合标签*/\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n        &lt;head&gt;\n        &lt;title&gt;Page title&lt;/title&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n        &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot;&gt;\n        &lt;!-- xhtml:1.0 img标签尾部需添加斜线\n        &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot;/&gt;\n        --&gt;\n        &lt;h1 class=&quot;hello-world&quot;&gt;Hello, world!&lt;/h1&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n</code></pre><pre><code class="lang-html">/*可选闭合标签,这里的&lt;/li&gt;省略了*/\n&lt;ul&gt;\n    &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;\n    &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;\n&lt;/ul&gt;\n/*完整的代码*/\n&lt;ul&gt;\n    &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h2 id="-">文档类型声明</h2>\n<p>&lt;!DOCTYPE&gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。声明之后可以确保浏览器正确的解析我们编写额web页面。</p>\n<p>HTML5只需要按如下的方式声明文档类型</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html&gt;\n</code></pre>\n<p>HTML 4.01有三种dtd</p>\n<p>HTML 4.01 Strict\n该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;\n</code></pre>\n<p>HTML 4.01 Transitional\n该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; \n&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\n</code></pre>\n<p>HTML 4.01 Frameset\n该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; \n&quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;\n</code></pre>\n<p>XHTML 1.0 Strict\n该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; \n&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;\n</code></pre>\n<p>XHTML 1.0 Transitional\n该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。必须以格式正确的 XML 来编写标记。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;\nhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n</code></pre>\n<p>XHTML 1.0 Frameset\n该 DTD 等同于 XHTML 1.0 Transitional，但允许框架集内容。</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; \n&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;\n</code></pre>\n<p>从上可以看到H5只有一种声明类型，html 4.01和xhtml 1.0都有三种什么类型，一般情况下我们只需要什么H5 doctype头部即可，如果需要考虑兼容低版本浏览器（ie6/7/8)可使用过渡类型的头部。</p>\n<p><a href="http://www.w3school.com.cn/tags/html_ref_dtd.asp">过渡类型、严格模式、框架集的差别</a></p>\n<pre><code class="lang-html">&lt;!--HTML5--&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<pre><code class="lang-html">&lt;!--过渡类型--&gt;\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;\n&lt;head&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id="-">字符编码</h2>\n<p>通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。这样做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与文档编码一致（一般采用 UTF-8 编码）。</p>\n<pre><code class="lang-html">&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;/head&gt;\n</code></pre>\n<h2 id="-">使用正确的标签，避免标签冗余</h2>\n<ul>\n<li>尽量遵循 HTML 标准和语义，但是不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度。（尤其勿滥用div标签）</li>\n<li>避免标签冗余</li>\n</ul>\n<pre><code class="lang-html">    &lt;!-- 不规范的写法 --&gt;\n    &lt;span class=&quot;avatar&quot;&gt;\n            &lt;img src=&quot;...&quot;&gt;\n    &lt;/span&gt;\n    &lt;!-- 规范的写法 --&gt;\n    &lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt;\n</code></pre>\n<h2 id="-">标签属性书写顺序</h2>\n<p>HTML 属性应当按照以下给出的顺序依次排列，确保代码的易读性。</p>\n<ul>\n<li>class</li>\n<li>id, name</li>\n<li>data-*</li>\n<li>src, for, type, href</li>\n<li>title, alt</li>\n<li>aria-*, role</li>\n</ul>\n<p>class 用于标识高度可复用组件，因此应该排在首位。id 用于标识具体组件，一般提供给JS使用。        </p>\n<hr />        \n\n<h1 id="css-">CSS编码规范</h1>\n<h2 id="-">语法</h2>\n<ul>\n<li>用四个空格来代替制表符（tab）</li>\n<li>为选择器分组时，将单独的选择器单独放在一行。</li>\n<li>为了代码的易读性，在每个声明块的左花括号前添加一个空格。</li>\n<li>声明块的右花括号应当单独成行。</li>\n<li>每条声明语句的 : 后应该插入一个空格。</li>\n<li>每条声明都应该独占一行。</li>\n<li>所有声明语句都应当以分号结尾。</li>\n<li>空格的使用<ul>\n<li>选择器与 { 之前要有空格</li>\n<li>属性名的 : 后要有空格</li>\n<li>属性名的 : 前不加空格 </li>\n</ul>\n</li>\n<li>十六进制值应该全部小写，例如，#fff。在扫描文档时，小写字符易于分辨，因为他们的形式更易于区分。</li>\n<li>尽量使用简写形式的十六进制值，例如，用 #fff 代替 #ffffff。</li>\n<li>为选择器中的属性添加双引号，例如，input[type=&quot;text&quot;]。只有在某些情况下是可选的，但是，为了代码的一致性，建议都加上双引号。</li>\n<li>避免为 0 值指定单位，例如，用 margin: 0; 代替 margin: 0px;。</li>\n</ul>\n<pre><code class="lang-css">/* 不规范 CSS */\n.selector, .selector-second, .selector[type=text] {\n    padding:15px;\n    margin:0px 0px 15px;\n    background-color:rgba(0, 0, 0, 0.5);\n    box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF;\n}\n\n/* 规范 CSS */\n.selector,\n.selector-second,\n.selector[type=&quot;text&quot;] {\n    padding: 15px;\n    margin-bottom: 15px;\n    background-color: rgba(0, 0, 0, 0.5);\n    box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;\n}\n</code></pre>\n<h2 id="-">属性书写顺序</h2>\n<ul>\n<li>Position</li>\n<li>Box model</li>\n<li>Typographic</li>\n<li>Visual</li>\n</ul>\n<pre><code class="lang-css">.declaration-order {\n    /* 定位相关 */\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    z-index: 100;\n\n    /* 盒模型相关 */\n    display: block;\n    width: 100px;\n    height: 100px;\n\n    /* 文本属性、排版相关 */\n    font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;\n    line-height: 1.5;\n    color: #333;\n    text-align: center;\n\n    /* Visual */\n    background-color: #f5f5f5;\n    border: 1px solid #e5e5e5;\n    border-radius: 3px;\n}\n</code></pre>\n<h2 id="class-id-">class和id的命名</h2>\n<ul>\n<li>class名称中只能出现小写字符和破折号（不是下划线，也不是驼峰命名法）。破折号应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。</li>\n<li>id的命名使用驼峰命名法（例如：#newUserName）</li>\n<li>避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。</li>\n<li>class和id的名称应当尽可能短，并且意义明确。</li>\n<li>使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（例如左右等位置信息，left-bar、right-bar）的名称。</li>\n<li>基于最近的父class或基本class作为新class的前缀。</li>\n</ul>\n<pre><code class="lang-css">    /* 不规范的写法 */\n    .m { ... }\n    .red { ... }\n    .header { ... }\n\n    /* 规范的写法 */\n    .menu { ... }\n    .important { ... }\n    .menu-header { ... }\n</code></pre>\n<h2 id="-">选择器</h2>\n<ul>\n<li>对于通用元素使用class这样利于渲染性能的优化。</li>\n<li>对于经常出现的组件，避免使用属性选择器（例如，[class^=&quot;...&quot;]）。浏览器的性能会受到这些因素的影响。</li>\n<li>选择器层级建议不多余3层。</li>\n<li>只有在必要的时候才将class限制在最近的父元素内（也就是后代选择器）（例如，不使用带前缀的class时 -- 前缀类似于命名空间）。</li>\n</ul>\n<h2 id="icon">icon</h2>\n<ul>\n<li>使用雪碧图</li>\n<li>使用自定义字体</li>\n</ul>\n<h1 id="-">编辑器配置</h1>\n<ul>\n<li>用四个空格代替制表符（soft-tab 即用空格代表 tab 符）。</li>\n<li>设置文件编码为 UTF-8。</li>\n</ul>\n<hr />\n\n<h1 id="javascript-">javascript编码规范</h1>\n<h2 id="-">命名规范</h2>\n<h3 id="-">变量命名</h3>\n<p>变量命名使用有意义的单词和驼峰式命名。\n临时变量简写：str,num,bol,fun,arr。\n循环变量简写：i , j , k。</p>\n<h3 id="-">全局变量及常量规范</h3>\n<p>全局变量使用g作为前缀，如gUserName , gLoginTime。\n常量全部字母都大写，如： PI , COPYRIGHT。注:常量可存在于函数中，也可存在于全局。</p>\n<h3 id="-">函数命名规范</h3>\n<ol>\n<li>统一使用动词或动词加名词的形式。如getVersion() , submitForm()。</li>\n<li>涉及返回逻辑值的函数可以使用is , has 等表示逻辑的词语代替动词。 内部函数前加上 ‘_‘前缀。</li>\n<li>可选参数以 ‘opt’ 开头.</li>\n</ol>\n<h3 id="-">类的命名</h3>\n<ul>\n<li>类名首字母大写。</li>\n<li>属性名为具有一定意义的名词。私有属性加 “_“。</li>\n<li>方法名为有意义的动词[+名词]，首字母小写。私有方法加 ‘_”.</li>\n</ul>\n<h3 id="-">其它</h3>\n<ul>\n<li>命名无特殊情况，请使用英语表示。切勿用汉语拼音。</li>\n<li>变量名应该明确必要，避免容易混淆的缩写。</li>\n<li>应该避免双重否定意义的变量，例如：bIsNotError, bIsNotFound，不可取。</li>\n<li>变量的生命周期保持可用范围最小。</li>\n<li>循环变量在循环中定义。</li>\n<li>避免在条件中执行语句。</li>\n<li>重复使用的具有相同意义的数字，用变量代替。</li>\n</ul>\n<p>注：window对象中只可以定义全局变量，常量，类。</p>\n<h2 id="-">命名空间</h2>\n<p>为避免全局命名的冲突,在全局作用域上使用一个与项目或文件相关的名字来划分作用域空间.</p>\n<pre><code class="lang-javascript">    var calcultor = {};\n    calcultor.add = function() {\n    ...\n    };\n    calcultor.sub = function() {\n    ...\n    };\n</code></pre>\n<h2 id="-">类型</h2>\n<ul>\n<li>原始值：按值传递 string/number/boolean/null/undefined 注:null和undefine是不同的.</li>\n<li>复杂类型：按引用传递 object/array/function</li>\n</ul>\n<h2 id="-">对象</h2>\n<p>使用字面值创建对象</p>\n<pre><code class="lang-javascript">/*bad*/\nvar item = new Object();\n/*good*/\nvar item = {};\n</code></pre>\n<p>不要使用保留字作为键</p>\n<pre><code class="lang-javascript">    /*bad*/\n    var superman = {\n        class:&#39;superhero&#39;,\n        default:{ clark:&#39;kent&#39; },\n        private: true\n    }\n    /*good*/\n    var superman = {\n        klass: &#39;superhero&#39;,\n        defaults:{ clark: &#39;kent&#39; },\n        hidden: true\n    };\n</code></pre>\n<h2 id="-">数组</h2>\n<p>使用字面量创建数组</p>\n<pre><code class="lang-javascript">    /*bad*/\n    var items = new Array();\n    /*good*/\n    var items = [];\n</code></pre>\n<p>数组长度不知时，使用push添加元素</p>\n<pre><code class="lang-javascript">    var someStack = [];\n    /*bad*/\n    someStack[someStack.length] = &#39;abcdefg&#39;;\n    /*good*/\n    someStack.push(&#39;abcdefg&#39;);\n    /*使用slice拷贝数组*/\n    var len = items.length,\n      itemsCopy = [],\n      i;\n    /*bad*/\n    for(i = 0; i &lt; len; i++){\n        itemsCopy[i] = items[i];\n    }\n    /*good*/\n    itemsCopy = items.slice();\n</code></pre>\n<h2 id="-">函数</h2>\n<p>不要在一个非函数块里面声明一个函数，应该把那个函数赋给一个变 量。浏览器让你这么做，但是解析的情况是不同的。</p>\n<pre><code class="lang-javascript">    /*bad*/\n    if(currentUser){\n        function test(){\n            console.log(&#39;Nope.&#39;);\n        }\n    }\n    /*good*/\n    if(currentUser){\n        var test = function test(){\n            console.log(&#39;Yup.&#39;);\n        };\n    }\n</code></pre>\n<p>请勿把参数命名为 arguments,这会对函数内的 arguments对象产生影响。</p>\n<pre><code class="lang-javascript">    /*bad*/\n    function nope(name, options, arguments){\n\n    }\n    /*good*/\n    function yup(name, options, args){\n\n    }\n</code></pre>\n<h2 id="-">属性</h2>\n<p>当使用变量访问属性时使用中括号。</p>\n<pre><code class="lang-javascript">    var luke = {\n        jedi: true,\n        age: 28\n    };\n    function getProp(prop){\n        return luke[prop];\n    }\n    var isJedi = getProp(&#39;jedi&#39;);\n</code></pre>\n<h2 id="-">条件表达式和等号</h2>\n<p>适当使用===和！==以及==和！=。</p>\n<p>条件表达式的强类型转换规则：</p>\n<ul>\n<li>对象被计算为true</li>\n<li>Undefined被计算为false</li>\n<li>Null被计算为false</li>\n<li>布尔值被计算为布尔的值</li>\n<li>数字如果是+0, -0,NaN被计算为false</li>\n<li>字符如果是空字符串，则被计算为false，否则为true</li>\n<li>字符串如果是空字符串，则被计算为false，否则为true</li>\n</ul>\n<h2 id="-">事件</h2>\n<p>当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据 里而不用找出并更新那个事件的事件处理器。</p>\n<pre><code class="lang-javascript">    /*bad*/\n    $(this).trigger(&#39;listingUpdated&#39;, listing.id);\n    $(this).on(&#39;listingUpdated&#39;, function(e,listingId){\n        /*do something with listingId*/\n    });\n    /*good*/\n    $(this).trigger(&#39;listingUpdated&#39;, {listingId: listing.id});\n    $(this).on(&#39;listingUpdated&#39;, function(e, data){\n    /*do something with data.listingId*/\n    });\n</code></pre>\n',summary:'<hr>\n<h1 id="-">目录</h1>\n<ul>\n<li><a href="#HTML编码规范">HTML编码规范</a></li>\n<li><a href="#CSS编码规范">CSS编码规范</a></li>\n<li><a href="#javascript编码规范">javascript编码规范</a></li>\n</ul>\n<hr />\n\n<h1 id="html-">HTML编码规范</h1>\n<h2 id="-">语法</h2>\n<ul>\n<li>用4个空格来代替制表符（tab）</li>\n<li>嵌套元素应当缩进一次（即4个空格）。</li>\n<li>对于属性的定义，确保全部使用双引号，不要使用单引号。</li>\n<li>H5页面不需要在自闭合（self-closing）元素的尾部添加斜线(注：xhtml 1.0所有标签尾部都要添加斜线)。</li>\n<li>不要省略可选的结束标签（closing tag）</li>\n</ul>\n'},{meta:{title:"The Little Schemer——read again",date:"2015-11-18T22:51:15.000Z",tags:["lisp","pl"],archives:"pl",id:"24",createTime:"2015-11-19",url:"2015-11-19-The Little Schemer——read again",strTag:"lisp、pl"},content:'<hr>\n<style>img{max-width:100%;}</style>\n\n<p><a class="text-center" href="http://www.ccs.neu.edu/home/matthias/BTLS/"><img data-src="/img/the-lillte-scheme.jpg" alt="the-little-scheme"></a>\nthe little scheme 是一本小人书，却很精妙。阅读它可以让你对编程语言有更好的认识，也能增加你对算法的理解(你真的会用递归了吗？)。\n说明：该书籍使用scheme来作为讲解的语言，scheme是lisp的一门方言，语法上比较特别的是S表达式。看到S表达式是不是感觉和语法树一般，一开始估计不是很习惯S表达式，但静下心来就会发现其实是一种很好理解也很简洁的语法。Good Luck!</p>\n<p><img class="text-center" data-src="/img/learn-programm.png" alt="oh,man.I just want to learn programm video game!">\noh,man.I just want to learn programm video game!</p>\n<h2 id="the-law-of-car">The Law of Car</h2>\n<blockquote>\n<p>The primitive car is defined only for non-empty lists.</p>\n</blockquote>\n<pre><code class="lang-scheme">Q:\nWhat is the car of l\nwhere\n    l is (((hotdogs))(and)(pickle) relish)\n\nA:\n((hotdogs)),\n    read as:\n    &quot;The list of the list of hotdogs.&quot;\n    ((hotdogs)) is the first S-expression of l.\n</code></pre>\n<p>[&quot;S表达式&quot;, &quot;列表&quot;]</p>\n<p><hr></p>\n<pre><code class="lang-scheme">Q:\nWhat is (car l)\nwhere\n    l is (((hotdogs)) (and) (pickle) relish)\n\nA:\n((hotdogs)),\nbecause (car l) is another way to ask for &quot;the car of the \nlist l.&quot;\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is (car (car l))\nwhere\n    l is (((hotdogs)) (and))\nA:\n(hotdogs).\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is the cdr of l\nwhere\n    l is (a b c)\nA:\n(b c)\n    because (b c) is the list l without (car l).\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is the cdr of l\nwhere\n    l is ((a b c) x y z)\nA:\n(x y z)\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is the cdr of l\nwhere\n    l is (hamburger)\nA:\n()\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is (cdr a)\nwhere \na is hotdogs\nA:\nNo answer\n    You cannot ask for the cdr of an atom.\n</code></pre>\n<h2 id="the-law-of-cdr">The Law of Cdr</h2>\n<blockquote>\n<p>The primitive cdr is defined only for non-empty lists.\nThe cdr of any non-empty list is always another list.</p>\n<hr>\n\n</blockquote>\n<pre><code class="lang-scheme">Q:\nwhat is (car (cdr l))\nwhere\nl is ((b)(x y)((c)))\nA:\n(x y),\nbecause((x y)((c))) is (cdr l), and (x y) is the car of\n(cdr l).\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is (cdr (cdr l))\nwhere\n    l is ((b)(x y)((c)))\nA:\n(((c))),\nbecause(x y)((c)) is (cdr l), and (((c))) is the cdr of (cdr l).\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nwhat does car take as an argument?\nA:\nit takes any non-empty list.\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat does cdr take as an argument?\nA:\nIt takes any non-empty list.\n</code></pre>\n<hr>\n\n<pre><code class="lang-scheme">Q:\nWhat is the cons of the atom a and the list l\nWhere a is peanut\nand\n    l is (butter and jelly)\nThis can also be written &quot;(cons a l)&quot;.\n    Read: &quot;cons the atom a onto the list l.&quot;\nA:\n(peanut butter and jelly),\n    because cons adds an atom to the front of a list.\n</code></pre>\n<pre><code class="lang-scheme">Q:\nWhat is (cons s l)\nwhere\n    s is ((help) this)\nand\n    l is (is very ((hard) to learn))\nA:\n(((help) this) is very ((hard) to learn)).\n</code></pre>\n<pre><code class="lang-scheme">Q:\nWhat does cons take as its arguments?\nA:\ncons takes two arguments:\n    the first one is any S-expression;\n    the second one is any list.\n</code></pre>\n<h2 id="the-law-of-cons">The Law of Cons</h2>\n<blockquote>\n<p>The primitive cons takes two arguments.\nThe second argument to cons must be a list.\nThe result is a list.</p>\n</blockquote>\n',
summary:'<hr>\n<style>img{max-width:100%;}</style>\n\n<p><a class="text-center" href="http://www.ccs.neu.edu/home/matthias/BTLS/"><img data-src="/img/the-lillte-scheme.jpg" alt="the-little-scheme"></a>\nthe little scheme 是一本小人书，却很精妙。阅读它可以让你对编程语言有更好的认识，也能增加你对算法的理解(你真的会用递归了吗？)。\n说明：该书籍使用scheme来作为讲解的语言，scheme是lisp的一门方言，语法上比较特别的是S表达式。看到S表达式是不是感觉和语法树一般，一开始估计不是很习惯S表达式，但静下心来就会发现其实是一种很好理解也很简洁的语法。Good Luck!</p>\n<p><img class="text-center" data-src="/img/learn-programm.png" alt="oh,man.I just want to learn programm video game!">\noh,man.I just want to learn programm video game!</p>\n<h2 id="the-law-of-car">The Law of Car</h2>\n<blockquote>\n<p>The primitive car is defined only for non-empty lists.</p>\n</blockquote>\n'},{meta:{title:"css特殊图形绘制",date:"2015-11-18T15:15:02.000Z",tags:"css",archives:"pl",id:"25",createTime:"2015-11-18",url:"2015-11-18-css特殊图形绘制",strTag:"css"},content:'<hr>\n<p><style>#line1{width: 300px;height: 0;border: 2px solid red;} #line2{width: 300px;height: 4px;background: blue;} #square1{width: 100px;height: 100px;background: #35b558;} #square2{width: 0;height:0;border:50px solid yellow;} #circle1{width: 100px;height: 100px;border-radius: 50%; background: #35b558;} #circle2{width: 0;height:0;border:50px solid yellow;border-radius: 50%;}#circle-box{width: 100px;height: 100px;border:50px solid #35b558; border-radius: 50%;} #circle2-box{width: 100px;height: 50px;border:20px solid red; border-radius: 100px 50px 100px 0px / 50px 20px 50px 0px} #trangle div{display: inline-block;} #trangle .trangle1{width: 0;height: 0;border-left:50px solid transparent;border-right:50px solid transparent;border-bottom:100px solid red;}#trangle .trangle2{width: 0;height: 0;border-left:50px solid transparent;border-right:50px solid transparent;border-top:100px solid #35b558;}#trangle .trangle3{width: 0;height: 0;border-left:100px solid blue;border-top:50px solid transparent;border-bottom:50px solid transparent;}#trangle .trangle4{width: 0;height: 0;border-right:100px solid yellow;border-top:50px solid transparent;border-bottom:50px solid transparent;} \n</style>\n<img src="/img/batteries_included.png" alt="batteries_included" style="max-width:100%;">\nOK... this one looked funnier in my head at 3 in the morning.</p>\n<p>直线</p>\n<div id="line1"></div>\n<div id="line2"></div>\n\n\n\n\n<pre><code class="lang-css">/*使用边框的方式需要注意添加了几个方向的边框，默认border会添加四个方向的边框*/\n#line1{\n    width: 100px;\n    height: 0;\n    border: 2px solid red;\n} \n\n#line2{\n    width: 100px;\n    height: 4px;\n    background: blue;\n}\n</code></pre>\n<p><hr>\n正方形</p>\n<div id="square1">#square1</div>\n<div id="square2">#square2</div>\n\n<pre><code class="lang-css">#square1{\n    width: 100px;\n    height: 100px;\n    background: #35b558;\n} \n\n/*注意文本区*/\n#square2{\n    width: 0;\n    height:0;\n    border:50px solid yellow;\n}\n</code></pre>\n<hr>\n\n\n<p>圆形</p>\n<div id="circle1">#circle1</div>\n<div id="circle2">#circle2</div>\n\n<pre><code class="lang-css">#circle1{\n    width: 100px;\n    height: 100px;\n    border-radius: 50%;\n    background: #35b558;\n} \n\n/*注意文本区*/\n#circle2{\n    width: 0;\n    height:0;\n    border-radius: 50%;\n    border:50px solid yellow;\n}\n</code></pre>\n<h2 id="border-radius-">border-radius参数说明</h2>\n<p>语法</p>\n<pre><code class="lang-css">/*完整的圆角可以设置8个参数，左上角水平圆角半径大小 右上角水平圆角半径大小 右下角水平圆角半径大小 左下角水平圆角半径大小/左上角垂直圆角半径大小 右上角垂直圆角半径大小 右下角垂直圆角半径大小 左下角垂直圆角半径大小*/\nborder-radius: 1-4 length|% / 1-4 length|%;\n\nborder-radius: 10px;\n/*等同于*/\nborder-top-left-radius: 10px;\nborder-top-right-radius: 10px;\nborder-bottom-right-radius: 10px;\nborder-bottom-left-radius: 10px;\n\n/*注意对角补全,斜杠前为水平半径、后为垂直半径*/\nborder-radius: 2px 1px 4px / 0.5px 3px;\n\nborder-top-left-radius: 2px 0.5px;\nborder-top-right-radius: 1px 3px;\nborder-bottom-right-radius: 4px 0.5px;\nborder-bottom-left-radius: 1px 3px;\n</code></pre>\n<p>圆环</p>\n<div id="circle-box"></div>\n<div id="circle2-box"></div>\n\n<pre><code class="lang-css">#circle-box{\n    width: 100px;\n    height: 100px;\n    border:50px solid #35b558; \n    border-radius: 50%;\n}\n\n/*调整单个参数可以得到更为复杂的图形*/\n#circle2-box{\n    width: 100px;\n    height: 50px;\n    border:20px solid red; \n    border-radius: 100px 50px 100px 0px / 50px 20px 50px 0px}\n</code></pre>\n<p>三角形</p>\n<div id="trangle"><div class="trangle1"></div><div class="trangle2"></div><div class="trangle3"></div><div class="trangle4"></div></div>\n\n<pre><code class="lang-css">#trangle .trangle1 {\n        width: 0;\n        height: 0;\n        border-left: 50px solid transparent;\n        border-right: 50px solid transparent;\n        border-bottom: 100px solid red;\n    }\n\n    #trangle .trangle2 {\n        width: 0;\n        height: 0;\n        border-left: 50px solid transparent;\n        border-right: 50px solid transparent;\n        border-top: 100px solid #35b558;\n    }\n\n    #trangle .trangle3 {\n        width: 0;\n        height: 0;\n        border-left: 100px solid blue;\n        border-top: 50px solid transparent;\n        border-bottom: 50px solid transparent;\n    }\n\n    #trangle .trangle4 {\n        width: 0;\n        height: 0;\n        border-right: 100px solid yellow;\n        border-top: 50px solid transparent;\n        border-bottom: 50px solid transparent;\n    }\n</code></pre>\n<p>爱心</p>\n<div id="heart"></div>\n\n<p>八卦</p>\n<p><div id="baguai-wrap"><div class="b1-circle"></div></div></p>\n<p><div id="baguai-wrap"><div class="b2-circle"></div></div></p>\n<p><div id="baguai-wrap"><div class="b-circle"></div></div></p>\n<pre><code class="lang-css">/*八卦*/\n#baguai-wrap{\n    padding-top: 30px;\n    height: 150px;\n    background-color: gray;\n}\n\n#baguai-wrap .b-circle{\n    position: relative;\n    width: 100px;\n    height: 0;\n    border-top: 50px solid #ffffff;\n    border-bottom: 50px solid #000000;\n    border-radius: 50%;\n    margin: 0 auto;\n    overflow: visible;\n}\n\n#baguai-wrap .b-circle:before{\n    position: absolute;\n    content: &#39;&#39;;\n    left: 0;\n    top: -25px;\n    width: 10px;\n    height: 10px;\n    border: 20px solid #000000;\n    background: #ffffff;\n    border-radius: 50%;\n}\n\n#baguai-wrap .b-circle:after{\n    position: absolute;\n    content: &#39;&#39;;\n    left: 50px;\n    top: -25px;\n    width: 10px;\n    height: 10px;\n    border: 20px solid #ffffff;\n    background-color: #000000;\n    border-radius: 50%;\n}\n</code></pre>\n',summary:'<hr>\n<p><style>#line1{width: 300px;height: 0;border: 2px solid red;} #line2{width: 300px;height: 4px;background: blue;} #square1{width: 100px;height: 100px;background: #35b558;} #square2{width: 0;height:0;border:50px solid yellow;} #circle1{width: 100px;height: 100px;border-radius: 50%; background: #35b558;} #circle2{width: 0;height:0;border:50px solid yellow;border-radius: 50%;}#circle-box{width: 100px;height: 100px;border:50px solid #35b558; border-radius: 50%;} #circle2-box{width: 100px;height: 50px;border:20px solid red; border-radius: 100px 50px 100px 0px / 50px 20px 50px 0px} #trangle div{display: inline-block;} #trangle .trangle1{width: 0;height: 0;border-left:50px solid transparent;border-right:50px solid transparent;border-bottom:100px solid red;}#trangle .trangle2{width: 0;height: 0;border-left:50px solid transparent;border-right:50px solid transparent;border-top:100px solid #35b558;}#trangle .trangle3{width: 0;height: 0;border-left:100px solid blue;border-top:50px solid transparent;border-bottom:50px solid transparent;}#trangle .trangle4{width: 0;height: 0;border-right:100px solid yellow;border-top:50px solid transparent;border-bottom:50px solid transparent;} \n</style>\n<img src="/img/batteries_included.png" alt="batteries_included" style="max-width:100%;">\nOK... this one looked funnier in my head at 3 in the morning.</p>\n<p>直线</p>\n<div id="line1"></div>\n<div id="line2"></div>\n\n'},{meta:{title:"html不能这么写，你知道吗？",date:"2015-11-17T16:51:15.000Z",tags:"html",archives:"pl",topper:!0,id:"26",createTime:"2015-11-18",url:"2015-11-18-html不能这么写，你知道吗？",strTag:"html"},content:'<hr>\n<ul>\n<li>a标签不可以嵌套交互式元素</li>\n<li>块级元素可以包含内联元素和某些块级元素，内联元素不能包含块级元素，只能包含内联元素</li>\n<li>p标签不能包含块级元素</li>\n<li>这些标签不可包含块级元素</li>\n<li>li标签可以包含div以及ul，ul的子元素应该只有li</li>\n<li>元素并排（块级和块级并列，内联和内联并列)</li>\n</ul>\n<h2 id="-">标签错误嵌套</h2>\n<h3 id="-">语法错误</h3>\n<ul>\n<li>a标签不可以嵌套交互式元素[a， audio（如果设置了controls属性）， button， details， embed， iframe， img（如果设置了usemap属性）， input（如果type属性不为hidden状态）， keygen， label， menu（如果type属性为toolbar状态），object（如果设置了usemap属性）， select， textarea， video（如果设置了controls属性）]</li>\n</ul>\n<pre><code class="lang-css">/*下面这些写法浏览器是不能够正常解析的*/\n&lt;a href=&quot;&quot;&gt;\n    &lt;a href=&quot;&quot;&gt;click&lt;/a&gt;\n&lt;/a&gt;\n&lt;a href=&quot;&quot;&gt;\n    &lt;button&gt;click&lt;/button&gt;\n&lt;/a&gt;\n&lt;a href=&quot;&quot;&gt;\n    &lt;input type=&quot;text&quot;&gt;\n&lt;/a&gt;\n&lt;a href=&quot;&quot;&gt;\n    &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;10&quot; rows=&quot;5&quot;&gt;&lt;/textarea&gt;\n&lt;/a&gt;\n</code></pre>\n<p><a href=""><a href="">click</a></a><a href=""><button>click</button></a><a href=""><input type="text"></a><a href=""><textarea name="" id="" cols="30" rows="10"></textarea></a></p>\n<p>有的虽然解析正常，但却达不到预想的目的</p>\n<h3 id="-">语义错误</h3>\n<p>页面可能正常解析，但不符合语义。这是因为浏览器自带容错机制，对于不规范的写法也能够正确的解析，各浏览器的容错机制不同，所以尽量按规范来写。</p>\n<ul>\n<li>块级元素可以包含内联元素和某些块级元素，内联元素不能包含块级元素，只能包含内联元素</li>\n</ul>\n<pre><code class="lang-css">/*规范的写法*/\n&lt;div&gt;\n    &lt;h2&gt;jikexueyuan&lt;/h2&gt;\n    &lt;p&gt;IT education&lt;/p&gt;\n&lt;/div&gt;\n/*不规范的写法*/\n&lt;span&gt;\n    &lt;div&gt;wrong&lt;/div&gt;\n&lt;/span&gt;\n</code></pre>\n<ul>\n<li>p标签不能包含块级元素</li>\n</ul>\n<pre><code class="lang-css">/*不规范的写法*/\n&lt;p&gt;\n    &lt;h1&gt;&lt;/h1&gt;\n&lt;/p&gt;\n&lt;p&gt;\n    &lt;div&gt;&lt;/div&gt;\n&lt;/p&gt;\n</code></pre>\n<ul>\n<li>如下的标签不可包含块级元素</li>\n</ul>\n<pre><code class="lang-css">h1、h2、h3、h4、h5、h6、p\n\n/*不规范的写法*/\n&lt;h1&gt;\n    &lt;h2&gt;&lt;/h2&gt;\n&lt;/h1&gt;\n&lt;h2&gt;\n    &lt;p&gt;&lt;/p&gt;\n&lt;/h2&gt;\n</code></pre>\n<ul>\n<li>li标签可以包含div以及ul(这个是不是很牛，可以包含父级元素)</li>\n</ul>\n<pre><code class="lang-css">/*规范的写法*/\n&lt;li&gt;\n    &lt;ul&gt;\n        &lt;li&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;div&gt;&lt;/div&gt;\n&lt;/li&gt;\n/*不规范的写法*/\n&lt;ul&gt;\n    &lt;a href=&quot;&quot;&gt;迷路的a标签&lt;/a&gt;\n    &lt;li&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<ul>\n<li>元素并排（块级和块级并列，内联和内联并列)</li>\n</ul>\n<pre><code class="lang-css">/*规范的写法*/\n&lt;div&gt;\n    &lt;h2&gt;&lt;/h2&gt;\n    &lt;p&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;div&gt;\n    &lt;img src=&quot;&quot; alt=&quot;&quot;&gt;\n    &lt;a href=&quot;&quot;&gt;&lt;/a&gt;\n    &lt;span&gt;&lt;/span&gt;\n&lt;/div&gt;\n\n/*不规范的写法*/\n&lt;div&gt;\n    &lt;span&gt;我是内联元素&lt;/span&gt;\n    &lt;p&gt;我是块级元素&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>\n<p>如有错误，请指出，欢迎补充其它一些错误情况。</p>\n',summary:"<hr>\n<ul>\n<li>a标签不可以嵌套交互式元素</li>\n<li>块级元素可以包含内联元素和某些块级元素，内联元素不能包含块级元素，只能包含内联元素</li>\n<li>p标签不能包含块级元素</li>\n<li>这些标签不可包含块级元素</li>\n<li>li标签可以包含div以及ul，ul的子元素应该只有li</li>\n<li>元素并排（块级和块级并列，内联和内联并列)</li>\n</ul>\n"},{meta:{title:"静态服务器搭建",date:"2015-11-17T14:01:16.000Z",tags:["php","tool"],archives:"pl",id:"27",createTime:"2015-11-17",url:"2015-11-17-静态服务器搭建",strTag:"php、tool"},content:'<hr>\n<style>\n    img{\n        width: 50%;\n    }\n</style>\n\n<ol>\n<li><a href="#1-xampp搭建静态服务器">1.xampp搭建静态服务器</a></li>\n<li><a href="#2-SublimeServer">2.sublime插件-SublimeServer</a></li>\n</ol>\n<h2 id="1-xampp-">1.xampp搭建静态服务器</h2>\n<p>XAMPP是完全免费且易于安装的Apache发行版，其中包含MariaDB、PHP和Perl。我们可以使用它来作为一个简单的静态服务器。</p>\n<p>官网地址：<a href="https://www.apachefriends.org/zh_cn/index.html">https://www.apachefriends.org/zh_cn/index.html</a></p>\n<p>到官网下载对应的版本安装即可</p>\n<p>使用方式：</p>\n<p>1.启动界面</p>\n<p><img src="/img/xampp/xampp01.png" alt="启动界面"></p>\n<p>2.启动服务器</p>\n<p><img src="/img/xampp/xampp02.png" alt="启动服务器"></p>\n<p>3.启动状态</p>\n<p><img src="/img/xampp/xampp03.png" alt="已启动服务器"></p>\n<p>4.静态文件目录</p>\n<p><img src="/img/xampp/xampp04.png" alt="静态文件目录"></p>\n<p><img src="/img/xampp/xampp05.png" alt="静态文件目录"></p>\n<p>将我们写好的静态页面放到htdocs文件夹下就可以通过如下的方式打开我们的页面</p>\n<p>格式：</p>\n<p><a href="http://localhost/">http://localhost/</a> + 静态文件路径(路径以htdocs为根目录，如htdocs下有一个jikexueyuan.html文件，那么可以通过<a href="http://localhost/jikexueyuan.html访问">http://localhost/jikexueyuan.html访问</a>)\n<a href="http://localhost/applications.html">http://localhost/applications.html</a></p>\n<p>如果上述方式无法打开，可通过ip访问</p>\n<p>mac: 在命令行输入 ifconfig\nwindow: 在命令行输入 ipconfig</p>\n<p><img src="/img/xampp/xampp06.png" alt="ip"></p>\n<p><a href="http://你的ip地址/">http://你的ip地址/</a> + 静态文件路径\nhttp:192.168.1.103/jike/jikexueyuan.html</p>\n<h2 id="2-sublimeserver">2.SublimeServer</h2>\n<p>----<a href="http://learningcn.com/SublimeServer/">官网地址</a></p>\n<ul>\n<li>package control安装</li>\n<li>手动安装，将SublimeServer文件下到sublime package文件夹即可</li>\n</ul>\n<p>如何使用：</p>\n<ul>\n<li>安装插件</li>\n<li>Tools-&gt;SublimeServer-&gt;Start SublimeServer</li>\n<li><a href="http://localhost:8080/+文件路径(在sublime">http://localhost:8080/+文件路径(在sublime</a> folder中打开的项目，8080为默认端口，如有改动则更改为相应的端口)</li>\n</ul>\n<p>补充说明：</p>\n<p>Hbuilder、webstorm自带有服务器设置</p>\n',summary:'<hr>\n<style>\n    img{\n        width: 50%;\n    }\n</style>\n\n<ol>\n<li><a href="#1-xampp搭建静态服务器">1.xampp搭建静态服务器</a></li>\n<li><a href="#2-SublimeServer">2.sublime插件-SublimeServer</a></li>\n</ol>\n<h2 id="1-xampp-">1.xampp搭建静态服务器</h2>\n<p>XAMPP是完全免费且易于安装的Apache发行版，其中包含MariaDB、PHP和Perl。我们可以使用它来作为一个简单的静态服务器。</p>\n<p>官网地址：<a href="https://www.apachefriends.org/zh_cn/index.html">https://www.apachefriends.org/zh_cn/index.html</a></p>\n<p>到官网下载对应的版本安装即可</p>\n<p>使用方式：</p>\n<p>1.启动界面</p>\n<p><img src="/img/xampp/xampp01.png" alt="启动界面"></p>\n'},{meta:{title:"简单cssHack了解，让ie支持H5、css3",date:"2015-11-13T15:08:09.000Z",archives:"pl",tags:"css",id:"28",createTime:"2015-11-13",url:"2015-11-13-简单cssHack了解，让ie支持H5、css3",strTag:"css"},content:'<hr>\n<h2 id="-css-hack-">为什么需要css Hack?</h2>\n<p>由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，由此带来的的结果是同样的页面在不同的浏览器中显示效果不一样，甚至会出现布局错乱的情况，为了保证各浏览器呈现的效果一致，有时会需要对各个浏览器做单独的处理。（Hack只是进行修补工作，不要当做一个主要的功能。个人觉得参照优雅降级的方式做兼容会比较好，先兼容主流的、版本高的浏览器。然后针对低版本不能兼容的点做相应的处理。)</p>\n<p>[&quot;优雅降级&quot;, &quot;渐进增强&quot;]</p>\n<p>PS: 个人觉得给css3属性增加前缀也是hack的一种</p>\n<p>常用的hack方式</p>\n<ul>\n<li>条件注释方式</li>\n<li>属性前缀方式</li>\n</ul>\n<h2 id="ie-hack-">ie Hack解决方案</h2>\n<h3 id="1-">1.条件注释法</h3>\n<p>类型于编程语言里的条件语句</p>\n<pre><code class="lang-javascript">if(条件满足){\n    显示相应的内容\n}\n</code></pre>\n<pre><code>只在IE下生效\n</code></pre><pre><code class="lang-html">    &lt;!--[if IE]&gt;\n    这段文字只在IE浏览器显示\n    &lt;![endif]--&gt;\n</code></pre>\n<pre><code>只在IE6下生效\n</code></pre><pre><code class="lang-html">    &lt;!--[if IE 6]&gt;\n    这段文字只在IE6浏览器显示\n    &lt;![endif]--&gt;\n</code></pre>\n<pre><code>只在IE6以上版本生效\n</code></pre><pre><code class="lang-html">    &lt;!--[if gte IE 6]&gt;\n    这段文字只在IE6以上(包括)版本IE浏览器显示\n    &lt;![endif]--&gt;\n</code></pre>\n<pre><code>只在IE8上不生效\n</code></pre><pre><code class="lang-html">    &lt;!--[if ! IE 8]&gt;\n    这段文字在非IE8浏览器显示\n    &lt;![endif]--&gt;\n</code></pre>\n<pre><code>非IE浏览器生效\n</code></pre><pre><code class="lang-html">    &lt;!--[if !IE]&gt;\n    这段文字只在非IE浏览器显示\n    &lt;![endif]--&gt;\n</code></pre>\n<h3 id="2-hack-">2.属性前缀法(以下hack在标准模式下使用)</h3>\n<p>ie6-hack</p>\n<p>&quot;_&quot;: 只有ie6能够识别的前缀</p>\n<pre><code class="lang-css">height: 100px;\nwidth: 100px;\n_height: 150px;/*在ie6下得到的宽高为150px，其余浏览器为100px*/\n_width: 150px;\n</code></pre>\n<p>ie7-hack</p>\n<p>&quot;+&quot;: 只有ie7能够识别的前缀</p>\n<pre><code class="lang-css">height: 100px;\nwidth: 100px;\n+height: 150px;/*在ie7下得到的宽高为150px，其余浏览器为100px*/\n+width: 150px;\n</code></pre>\n<p>ie6、7-hack</p>\n<p>&quot;*&quot;: 只有ie6、7能够识别的前缀</p>\n<pre><code class="lang-css">height: 100px;\nwidth: 100px;\n*height: 150px;/*在ie6/7下得到的宽高为150px，其余浏览器为100px*/\n*width: 150px;\n</code></pre>\n<h3 id="-">属性后加数字声明的方式</h3>\n<p>“\\9″     IE6/IE7/IE8/IE9/IE10都生效\n“\\0″     IE8/IE9/IE10都生效，是IE8/9/10的hack\n“\\9\\0″     只对IE9/IE10生效，是IE9/10的hack</p>\n<p>在处理ie的hack时，一般会需要对ie6/7/8做单独的处理，6/7有单独的前缀，8并没有。下面说明如何对8做单独的处理</p>\n<pre><code class="lang-css">height: 100px;\nwidth: 100px;\nheight: 150px\\0;    /*在ie8/9/10可以识别*/\nwidth: 100px\\9\\0;    /*在ie9/10可以识别*/\n</code></pre>\n<p>按如上的设置方式，就对ie8做了单独的处理。</p>\n<h2 id="-ie-h5-ie6-">如何让ie支持H5(包括ie6)</h2>\n<p>下载地址1：<a href="https://github.com/afarkas/html5shiv">https://github.com/afarkas/html5shiv</a>\n下载地址2：<a href="/js/html5shiv.min.js">html5shiv.min.js</a>\n使用方式，在页面头部添加如下代码：</p>\n<pre><code class="lang-html">&lt;!–[if IE]&gt;  \n&lt;script src=”[html5.js]”&gt;&lt;/script&gt;  \n&lt;![endif]–&gt;\n</code></pre>\n<p>这里的src引入的是我们下载的htmlshiv.js文件。</p>\n<h2 id="-ie-css3-">如何让ie支持CSS3属性</h2>\n<p>借助于ie-css3.htc,<a href="/css/ie-css3.htc">点我下载</a></p>\n<p>语法：</p>\n<pre><code class="lang-css">/*给body添加后，body下的子元素都可以使用*/\nbody{\n    behavior: url(ie-css3.htc);\n}\n</code></pre>\n',summary:'<hr>\n<h2 id="-css-hack-">为什么需要css Hack?</h2>\n<p>由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，由此带来的的结果是同样的页面在不同的浏览器中显示效果不一样，甚至会出现布局错乱的情况，为了保证各浏览器呈现的效果一致，有时会需要对各个浏览器做单独的处理。（Hack只是进行修补工作，不要当做一个主要的功能。个人觉得参照优雅降级的方式做兼容会比较好，先兼容主流的、版本高的浏览器。然后针对低版本不能兼容的点做相应的处理。)</p>\n<p>[&quot;优雅降级&quot;, &quot;渐进增强&quot;]</p>\n<p>PS: 个人觉得给css3属性增加前缀也是hack的一种</p>\n<p>常用的hack方式</p>\n<ul>\n<li>条件注释方式</li>\n<li>属性前缀方式</li>\n</ul>\n'},{meta:{title:"css3简易魔方绘制",date:"2015-11-11T14:08:10.000Z",tags:"css",archives:"pl",id:"29",createTime:"2015-11-11",url:"2015-11-11-css3简易魔方绘制",strTag:"css"},content:'<hr>\n<p>简易魔方效果：<a href="/other/3dCube/index.html">点击查看</a>\n在线编辑实例：<a href="/liveCoding/demo/index.html">点我开始制作</a></p>\n<h2 id="-">立方体绘制</h2>\n<p>3D变化的坐标如下所示：</p>\n<p><img src="/img/3d_axes.png" alt="css3D坐标系"></p>\n<p>网格所在的面代表我们的设备屏幕（大多情况下为电脑屏幕）</p>\n<h3 id="transform">transform</h3>\n<p>浏览器支持情况:\nInternet Explorer 10、Firefox 以及 Opera 支持 transform 属性。\nChrome 和 Safari 需要前缀 -webkit-。\n注释：Internet Explorer 9 需要前缀 -ms-。</p>\n<p>旋转测试：</p>\n<p>正常情况</p>\n<div class="margin-auto" style="height: 80px;">\n    <div style="position:absolute;background: brown;height: 50px;width: 50px;"></div>\n</div>\n\n<p>transform: rotateX(Xdeg);[以X为轴进行旋转]</p>\n<div class="rotateX-wrapper">\n    <div class="box"></div>\n</div>\n\n<p>transform: rotateY(Xdeg);[以Y为轴进行旋转]</p>\n<div class="rotateY-wrapper">\n    <div class="box"></div>\n</div>\n\n\n<p>transform: rotateZ(Xdeg);[以Z为轴进行旋转]</p>\n<div class="rotateZ-wrapper">\n    <div class="box"></div>\n</div>\n\n<p><hr>\n偏移测试：</p>\n<div class="translateX-wrapper">\n    <div class="box">translateX</div>\n</div>\n\n<div class="translateY-wrapper">\n    <div class="box">translateY</div>\n</div>\n<hr>\n\n\n\n注：这里将父容器宽高设为与子容器一样（若有边框需要考虑边框的大小）\n\n<div class="margin-auto" style="height: 150px;">\n    <div class="square-wrapper"><div class="front"></div><div class="behind"></div><div class="left"></div><div class="right"></div><div class="top"></div><div class="bottom"></div>\n    </div>\n</div>\n\n<p>注：示例并未做兼容处理\n1 前后两个面经Z轴偏移，前为正（向屏幕外，用户的方向偏移），后为负得到\n2 左右两个面经旋转偏移得到</p>\n<p>同时设置旋转和偏移时，属性的顺序会影响最终的效果</p>\n<div class="margin-auto" style="height: 150px;">\n    <div class="square-wrap"><div class="front"></div><div class="behind"></div><div class="left"></div><div class="right"></div><div class="top"></div><div class="bottom"></div>\n    </div>\n</div>\n\n<p>立方体效果（添加了旋转动画）</p>\n<pre><code class="lang-html">&lt;div class=&quot;square-wrapper&quot;&gt;\n    &lt;div class=&quot;front&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;behind&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class="lang-css">.square-wrapper,\n.square-wrapper &gt; div{\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n\n/*立体实现*/\n.square-wrapper{\n    margin-top: 20px;\n    transform-style: preserve-3d;\n    animation: square-animation 5s infinite;\n}\n\n@keyframes square-animation{\n    0% {transform: rotateX(0deg) rotateY(0deg);}\n    45% {transform: rotateX(90deg)}\n    75% {transform: rotateY(90deg);}\n    90% {transform: rotateX(45deg) rotateY(45deg);}\n    100% {transform: rotateX(0deg) rotateY(0deg);}\n}\n\n.square-wrap .top{\n    background-color: red;\n    transform: translateY(-50px) rotateX(90deg);\n}\n\n.square-wrap .bottom {\n    background-color: brown;\n    transform: translateY(50px) rotateX(-90deg);\n}\n\n.square-wrap .left{\n    background-color: green;\n    transform:translateX(-50px) rotateY(90deg);\n}\n\n.square-wrap .right{\n    background-color: blue;\n    transform: translateX(50px) rotateY(-90deg);\n}\n\n.square-wrap .front{\n    background-color: #ddd;\n    transform: translateZ(50px);\n}\n\n.square-wrap .behind{\n    background-color: #000000;\n    transform: translateZ(-50px);\n}\n</code></pre>\n',summary:'<hr>\n<p>简易魔方效果：<a href="/other/3dCube/index.html">点击查看</a>\n在线编辑实例：<a href="/liveCoding/demo/index.html">点我开始制作</a></p>\n<h2 id="-">立方体绘制</h2>\n<p>3D变化的坐标如下所示：</p>\n<p><img src="/img/3d_axes.png" alt="css3D坐标系"></p>\n<p>网格所在的面代表我们的设备屏幕（大多情况下为电脑屏幕）</p>\n<h3 id="transform">transform</h3>\n<p>浏览器支持情况:\nInternet Explorer 10、Firefox 以及 Opera 支持 transform 属性。\nChrome 和 Safari 需要前缀 -webkit-。\n注释：Internet Explorer 9 需要前缀 -ms-。</p>\n'},{meta:{title:"使用inline-block与浮动前需要了解这些",date:"2015-11-06T15:06:36.000Z",archives:"pl",tags:"css",id:"30",createTime:"2015-11-06",url:"2015-11-06-使用inline-block与浮动前需要了解这些",strTag:"css"},content:'<hr>\n<p>HTML标签分为块级元素和行内元素，块级元素会独占一行。</p>\n<p>常见的块级元素：</p>\n<pre><code class="lang-css">h1,h2,h3,h4,h5,\ndiv,p,form,hr,menu,ul,dl,ol,pre,table,address,blockquote\n</code></pre>\n<p>常见的内联元素</p>\n<pre><code class="lang-css">a,abbr,acronym,br,cite,code,em,i,\nimg,input,label,select,small,span,sub,sup,textarea\n</code></pre>\n<p>块级元素：块级元素独占一行，可以设定元素的宽（width）、高（height）和内外边距，块级元素一般是其他元素的容器，可容纳块级元素和行内元素。常见的块级元素有div, p ,h1~h6等。</p>\n<p>行内元素：行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的高度一般由元素内部的字体大小决定，宽度由内容的长度控制。常见的行内元素有a, em ,strong等。（img标签虽然是行内元素，但自带宽高属性，即可以设置宽高)</p>\n<p>给行内元素和块级元素加上display:inline-block;后会将元素转换为行内块元素，即不独占一行而且可以按盒子模型进行布局。</p>\n<h2 id="-inline-">行内元素（inline)</h2>\n<div class="margin-auto">\n    <span style="background:red;">行内元素</span>  <span style="background:green;">行内元素</span>  <span style="background:blue;">行内元素</span>\n    <hr>\n</div>\n\n<h2 id="-inline-block-">行内块元素（inline-block)</h2>\n<div class="margin-auto">\n    <span style="background:red;display:inline-block;">行内元素</span>  <span style="background:green;display:inline-block;">行内元素</span>  <span style="background:blue;display:inline-block;">行内元素</span>\n    <hr>\n</div>\n\n<p>从上面可以看到内联元素之间都会产生空格，该空格的大小受设置字体大小的影响(注：当html标签间有空格或换行的情况,如果没有则不会产生空格的)</p>\n<h2 id="-inline-block-">行内块元素（inline-block)并排空格解决方式</h2>\n<ul>\n<li>margin负值</li>\n<li>font-size: 0;</li>\n<li>浮动替代方式</li>\n</ul>\n<pre><code class="lang-css">margin-left: -5px;\n</code></pre>\n<div class="margin-auto">\n    <span style="background:red;display:inline-block;">行内元素</span>  <span style="background:green;display:inline-block;margin-left:-5px;">行内元素</span>  <span style="background:blue;display:inline-block;margin-left:-5px;">行内元素</span>\n    <hr>\n</div>\n\n<pre><code class="lang-css">/*这里给父容器设置字体大小为0，有的浏览器不兼容,此时可以给子元素单独设字体大小*/\nfont-size: 0;\n</code></pre>\n<div class="margin-auto" style="font-size: 0;">\n    <span style="background:red;display:inline-block;font-size:14px;">行内元素</span>  <span style="background:green;display:inline-block;font-size:14px;">行内元素</span>  <span style="background:blue;display:inline-block;font-size:14px;">行内元素</span>\n    <hr style="font-size: 14px;">\n</div>\n\n<pre><code class="lang-css">float: left;\n</code></pre>\n<div class="margin-auto" style="float: left;"><div><span style="background:red;display:inline-block;font-size:14px;float: left;">行内元素</span>  <span style="background:green;display:inline-block;font-size:14px;float: left;">行内元素</span>  <span style="background:blue;display:inline-block;font-size:14px;float: left;">行内元素</span></div>\n    <hr>\n</div>\n\n\n<h2 id="-">清除浮动</h2>\n<pre><code class="lang-css">float: left;/*设置浮动*/\nclear: both;/*清除浮动*/\n</code></pre>\n<p>浮动会导致父层塌陷，所以需要清除浮动来将父层撑开。</p>\n<ul>\n<li>父级设置浮动</li>\n<li>带clear属性的空元素</li>\n<li>父级设置overflow: hidden;或overflow: auto;在IE6中还需要触发hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。</li>\n<li>使用css的:after伪元素。给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。</li>\n</ul>\n<pre><code class="lang-css">.clearfix:after{\n  content: &quot;&quot;; \n  display: block; \n  height: 0; \n  clear: both; \n  visibility: hidden;  \n  }\n\n.clearfix {\n  /* 触发 hasLayout ie6/7*/ \n  zoom: 1; \n  }\n</code></pre>\n<p>示例：</p>\n<pre><code class="lang-html">&lt;div class=&quot;content&quot;&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>清除方式一：</p>\n<pre><code class="lang-html">&lt;div class=&quot;content&quot; style=&quot;float:left;&quot;&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>该种方式父容器自身会浮动，所以需要注意父容器浮动所带来的影响</p>\n<p>清除方式二：</p>\n<pre><code class="lang-html">&lt;div class=&quot;content&quot;&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>清除方式三：</p>\n<pre><code class="lang-html">&lt;div class=&quot;content&quot; style=&quot;overflow:hidden;zoom:1;&quot;&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>清除方式四：</p>\n<pre><code class="lang-html">&lt;div class=&quot;content clearfix&quot;&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;sub-cont&quot; style=&quot;float:left;&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n',summary:'<hr>\n<p>HTML标签分为块级元素和行内元素，块级元素会独占一行。</p>\n<p>常见的块级元素：</p>\n<pre><code class="lang-css">h1,h2,h3,h4,h5,\ndiv,p,form,hr,menu,ul,dl,ol,pre,table,address,blockquote\n</code></pre>\n<p>常见的内联元素</p>\n<pre><code class="lang-css">a,abbr,acronym,br,cite,code,em,i,\nimg,input,label,select,small,span,sub,sup,textarea\n</code></pre>\n<p>块级元素：块级元素独占一行，可以设定元素的宽（width）、高（height）和内外边距，块级元素一般是其他元素的容器，可容纳块级元素和行内元素。常见的块级元素有div, p ,h1~h6等。</p>\n'},{meta:{title:"前端开发环境搭建",date:"2015-11-02T17:27:13.000Z",archives:"pl",tags:["web","tool"],id:"31",createTime:"2015-11-03",url:"2015-11-03-前端开发环境搭建",strTag:"web、tool"},content:'<hr>\n<h2 id="sublime-text-">sublime text安装（神级代码编辑器）</h2>\n<h3 id="-http-www-sublimetext-com-"><a href="http://www.sublimetext.com/">官网地址</a></h3>\n<p><img src="/img/sublime-bg.jpg"></p>\n<p>选择与系统对应的版本下载即可，推荐安装sublime text3.</p>\n<h3 id="-sublime-text-3-">以下是sublime text 3下载地址:</h3>\n<ul>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083.dmg">Mac-OS X (10.7 or later is required)</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083%20Setup.exe">Windows</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083%20x64%20Setup.exe">Windows 64 bit</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/sublime-text_build-3083_amd64.deb">Ubuntu 64 bit</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/sublime-text_build-3083_i386.deb">Ubuntu 32 bit</a></li>\n</ul>\n<h2 id="sublime-text-">sublime text插件安装</h2>\n<h3 id="package-control">Package Control</h3>\n<p>通过Package Control ，我们可以管理和安装sublime text其它相应的插件。</p>\n<h3 id="-">安装方式</h3>\n<p>通过 ctrl+` 或是通过 View -&gt; show console的方式打开sublime text编辑器的控制台，然后再控制台中输入对应的python代码，代码如下所示（若出现运行出错的情况请注意标点符号是否为英文的标点符号）。</p>\n<p class="text-important">安装完package control后请重启sublime</p>\n\n<h4 id="1-sublime-text3">1.sublime text3</h4>\n<p style="background:#272822;color:#ffffff;padding:10px;">import urllib.request,os,hashlib; h = &#39;2915d1851351e5ee549c20394736b442&#39; + &#39;8bc59f460fa1548d1514676163dafc88&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;<a href="http://packagecontrol.io/">http://packagecontrol.io/</a>&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)</p>\n\n<p class="text-important">如出现报错，可到package control官网拷贝对应安装代码：<a href="https://packagecontrol.io/installation#st3">https://packagecontrol.io/installation#st3</a></p>\n\n<h4 id="2-sublime-text2">2.sublime text2</h4>\n<p style="background:#272822;color:#ffffff;padding:10px;">import urllib2,os,hashlib; h = &#39;2915d1851351e5ee549c20394736b442&#39; + &#39;8bc59f460fa1548d1514676163dafc88&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &#39;<a href="http://packagecontrol.io/">http://packagecontrol.io/</a>&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &#39;wb&#39; ).write(by) if dh == h else None; print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h) if dh != h else &#39;Please restart Sublime Text to finish installation&#39;)</p>\n\n<h2 id="-">手动安装</h2>\n<ul>\n<li>1.点击Preferences &gt; Browse Packages</li>\n<li>2.上面的步骤会打开一个文件夹，在其中我们找到Installed Packages文件夹（如果没有，则在父级目录中查找）</li>\n<li>3.下载Control.sublime-package（<a href="https://packagecontrol.io/Package%20Control.sublime-package">下载地址</a>）包然后拷贝到 Installed Packages文件夹</li>\n</ul>\n<p>通过上述方式安装好package control插件好重启sublime package control就可以使用了。</p>\n<h3 id="emment-">Emment安装</h3>\n<p>Emment的功能包括代码补全、代码初始化以及快速编码等功能。</p>\n<ul>\n<li>使用快捷键ctrl + shift + p(mac:command + shift + p)</li>\n<li><a href="http://jingyan.baidu.com/article/ca00d56c76d0fae99eebcfdf.html">安装教程：sb2/sb3一样</a></li>\n</ul>\n<p>测试安装是否成功：</p>\n<p>新建一个html文件，输入 html:5,然后按下tab键，这是我们就会得到如下的html结构：</p>\n<pre><code class="lang-html">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;·\n&lt;body&gt;\n\n&lt;/body&gt;    \n&lt;/html&gt;\n</code></pre>\n<p class="text-important">如果不成功查看一下文件是否保存，如未保存请先保存。(注：如我新建一个jikexueyuan的html文件，那么应该保存为: jikexueyuan.html文件)</p>\n\n<p>检查插件是否已安装</p>\n<p><img src="/img/package-control.png" alt="package control安装列表">\n最后一级菜单中显示的即已安装的插件列表。(如果没有说明安装不成功，比如我这里第一行是Emment,说明我的Emment插件安装好了，如果你的没有说明没装好)</p>\n<p>这样就代表插件安装成功了,开启极客之旅吧。</p>\n<p>想体验更多插件可到<a href="https://packagecontrol.io/寻找">https://packagecontrol.io/寻找</a></p>\n<h2 id="sublime-">sublime 破解序列号</h2>\n<p>----- BEGIN LICENSE ----- \nAndrew Weber \nSingle User License \nEA7E-855605 \n813A03DD 5E4AD9E6 6C0EEB94 BC99798F \n942194A6 02396E98 E62C9979 4BB979FE \n91424C9D A45400BF F6747D88 2FB88078 \n90F5CC94 1CDC92DC 8457107A F151657B \n1D22E383 A997F016 42397640 33F41CFC \nE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D \n5CDB7036 E56DE1C0 EFCC0840 650CD3A6 \nB98FC99C 8FAC73EE D2B95564 DF450523 \n------ END LICENSE ------ </p>\n<h2 id="node-">node安装</h2>\n<p>官网下载地址：</p>\n<p>英文：<a href="https://nodejs.org/">https://nodejs.org/</a>\n中文：<a href="http://nodejs.cn/">http://nodejs.cn/</a></p>\n<p>建议安装v4.2.2版本</p>\n<h2 id="sublime-node-html-css-js-prettify-">Sublime美化插件需node支持(html/css/js prettify)</h2>\n<p>1 .打开node_path设置路径(set node path)</p>\n<p><img src="/img/xampp/node_path.jpg" alt="node_path设置路径"></p>\n<p>2 .node安装路径(以你自己的安装路径为准，这里我的安装路径是E:\\Nodejs\\,注意斜杠的方向)</p>\n<p><img src="/img/xampp/node_path02.png" alt="node安装路径"></p>\n<p>3 .路径替换(如果是其它版本的系统请更改相应的路径)</p>\n<p>默认路径\n<img src="/img/xampp/node_path01.jpg" alt="路径替换"></p>\n<p>替换为(windows版)\n<img src="/img/xampp/node_03.jpg" alt="路径替换"></p>\n<p>这样的话美化插件就可以用了,鼠标右键html/css/js prettify——&gt;prettify code或者使用快捷键Ctrl+h即触发美化功能。</p>\n',
summary:'<hr>\n<h2 id="sublime-text-">sublime text安装（神级代码编辑器）</h2>\n<h3 id="-http-www-sublimetext-com-"><a href="http://www.sublimetext.com/">官网地址</a></h3>\n<p><img src="/img/sublime-bg.jpg"></p>\n<p>选择与系统对应的版本下载即可，推荐安装sublime text3.</p>\n<h3 id="-sublime-text-3-">以下是sublime text 3下载地址:</h3>\n<ul>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083.dmg">Mac-OS X (10.7 or later is required)</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083%20Setup.exe">Windows</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083%20x64%20Setup.exe">Windows 64 bit</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/sublime-text_build-3083_amd64.deb">Ubuntu 64 bit</a></li>\n<li><a href="http://c758482.r82.cf2.rackcdn.com/sublime-text_build-3083_i386.deb">Ubuntu 32 bit</a></li>\n</ul>\n'},{meta:{title:"what's is yeoman",date:"2014-12-25T11:10:44.000Z",tags:"tool",id:"32",createTime:"2014-12-25",url:"2014-12-25-what's is yeoman",strTag:"tool"},content:'<hr>\n<h2 id="yeoman-">Yeoman-前端工程化</h2>\n<p>yeoman——现代webapp构建工具，适合于复杂的web应用，yeoman又包括三个组成部分。在我们选择它或者使用它之前我们一定要知道它能做什么？适合做什么？</p>\n<ul>\n<li>Yo</li>\n<li>Grunt/gulp</li>\n<li>Bower/npm</li>\n</ul>\n<h3 id="yo">Yo</h3>\n<p>Yo提供了许多的生成器帮助我们快速的开始一个项目。因为在大多数时候我们的工作是重复的，比如要建立好目录文件结构，下载jquery/bootstrap等这些，然后将它们引入到页面中。Yo的作用就是将这些部分抽取出来并提供给我们，让我们无需从零开始，加快开发的进度。</p>\n<h3 id="grunt-gulp">Grunt/gulp</h3>\n<p>自动化流程构建，文件压缩、编译、项目预览、测试等。</p>\n<h3 id="bower-npm">Bower/npm</h3>\n<p>包管理工具，同时解决包的依赖关系。举个栗子，如果我们的项目中需要bootstrap，那么我们可能会需要去bootstrao的官网下载源码，同时bootstrap又回依赖于jquery，所以我们又去jquery的官网下载jquery,但是使用包管理工具，我们就可以使用一条命令就解决了。</p>\n<pre><code class="lang-node">bower install boostrap\n</code></pre>\n<h2 id="yeoman-">yeoman安装使用</h2>\n<ul>\n<li>安装</li>\n</ul>\n<pre><code class="lang-node">npm install -g yo bower grunt-cli gulp\n</code></pre>\n<p>这里将以全局的方式安装yo/bower/grunt-cli/gulp。\n说明：grunt和gulp我们可以任选其一，bower和npm也可以任选其一，因为他们做的事是一样的。</p>\n<ul>\n<li>Yo生成器</li>\n</ul>\n<p>Yo提供了webapp这样的生成器，提供了一个默认的模板项目，包括HTML5 Boilerplate/jQuery/Modernizr/Bootstrap这些，即我们使用&#39;yo webapp&#39;的形式就会帮助我们构建一个webapp项目，这个项目包括了上述的这些东西，当然在安装时我们可以选择性的选择是否需要。</p>\n<p>在使用之前先安装一个app generator</p>\n<pre><code class="lang-node">npm install -g webapp\n</code></pre>\n<p>之后就可以通过</p>\n<pre><code class="lang-node">yo webapp\n</code></pre>\n<p>来使用一个生成器。</p>\n<ul>\n<li>bower配合yo使用</li>\n</ul>\n<pre><code class="lang-node">grunt bower\ngrunt wiredep\n</code></pre>\n<p>将bower下载的包加载到项目文件中</p>\n<ul>\n<li>Grunt/gulp</li>\n</ul>\n<p>gulp流程：</p>\n<pre><code class="lang-node">yo webapp\ngulp serve\ngulp test\ngulp\n</code></pre>\n<p>grunt流程：</p>\n<pre><code>yo webapp\ngrunt serve\ngrunt test\ngrunt\n</code></pre><h2 id="gruntfile-js">Gruntfile.js</h2>\n<p>Gruntfile.js由以下几部分组成：</p>\n<ul>\n<li>&quot;wrapper&quot;函数</li>\n<li>项目与任务配置</li>\n<li>加载grunt插件和任务</li>\n<li>自定义任务</li>\n</ul>\n<p>示例：</p>\n<pre><code class="lang-node">/*wrapper函数*/\nmodule.exports = function(grunt) {\n\n  // 项目配置\n  grunt.initConfig({\n    pkg: grunt.file.readJSON(&#39;package.json&#39;),\n    uglify: {\n      /*指定了一个banner选项(用于在文件顶部生成一个注释)*/\n      options: {\n        banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&#39;\n      },\n      build: {\n        src: &#39;src/&lt;%= pkg.name %&gt;.js&#39;,\n        dest: &#39;build/&lt;%= pkg.name %&gt;.min.js&#39;\n      }\n    }\n  });\n\n  // 加载包含 &quot;uglify&quot; 任务的插件。\n  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);\n\n  // 默认被执行的任务列表。\n  grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);\n\n};\n</code></pre>\n<p>常用插件：</p>\n<ul>\n<li>contrib-jshint: js代码规范性验证</li>\n<li>contrib-watch: 文件变化监视</li>\n<li>contrib-clean: 目录清空</li>\n<li>contrib-uglify: js压缩</li>\n<li>contrib-copy: 文件合并</li>\n<li>contrib-connect: 开启connect服务器</li>\n<li>contrib-cssmin: css压缩</li>\n<li>contrib-less: less编译成css</li>\n<li>contrib-sass: sass编译成css</li>\n<li>autoprefixer: css前缀添加</li>\n<li>contrib-imagemin: 图片压缩</li>\n<li>usemin: 静态资源路径更换</li>\n<li>contrib-hmtlmin: html压缩</li>\n<li>bower: copy bower组件到生成目录</li>\n<li>wiredep: 将bower组件引入到html文件中</li>\n</ul>\n',summary:'<hr>\n<h2 id="yeoman-">Yeoman-前端工程化</h2>\n<p>yeoman——现代webapp构建工具，适合于复杂的web应用，yeoman又包括三个组成部分。在我们选择它或者使用它之前我们一定要知道它能做什么？适合做什么？</p>\n<ul>\n<li>Yo</li>\n<li>Grunt/gulp</li>\n<li>Bower/npm</li>\n</ul>\n<h3 id="yo">Yo</h3>\n<p>Yo提供了许多的生成器帮助我们快速的开始一个项目。因为在大多数时候我们的工作是重复的，比如要建立好目录文件结构，下载jquery/bootstrap等这些，然后将它们引入到页面中。Yo的作用就是将这些部分抽取出</p>\n'},{meta:{title:"CSS3布局",date:"2014-12-09T17:39:26.000Z",tags:"css,web",id:"33",createTime:"2014-12-10",url:"2014-12-10-CSS3布局",strTag:"css,web"},content:'<hr>\n<h2 id="-">目录</h2>\n<ul>\n<li>伸缩盒(Flexible Box)(新)</li>\n</ul>\n<h2 id="-flexible-box-">伸缩盒(Flexible Box)(新)</h2>\n<ul>\n<li>flex<ul>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n</ul>\n</li>\n<li>flex-flow<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n</ul>\n</li>\n<li>align-content</li>\n<li>align-items</li>\n<li>align-self</li>\n<li>justify-content</li>\n<li>order</li>\n</ul>\n<h3 id="flex">flex</h3>\n<p>flex帮助我们设置剩余空间如何进行分配(这里要注意是剩余空间，剩余空间等于父容器的宽度减轻子元素的宽度之和)，水平方向的分配。</p>\n<pre><code class="lang-css">/*下面书写方式意义一样*/\nflex: none;\nflex: 0 0 auto;\n</code></pre>\n<p>flex-grow:用来指定扩展比率，即剩余空间为正值时该子元素所分配到的空间比例。\nflex-shrink: 指定收缩比例，剩余空间为负值时才有意义。\nflex-basis:用来指定伸缩基准值，即子元素的宽度基值</p>\n<h3 id="flex-flow">flex-flow</h3>\n<p>控制子元素的排列方向、单行或多行。</p>\n<p>flex-direction：row | row-reverse | column | column-reverse</p>\n<ul>\n<li>row：即横向从左到右排列（左对齐）。</li>\n<li>row-reverse：对齐方式与row相反。</li>\n<li>column：即纵向从上往下排列（顶对齐）。</li>\n<li>column-reverse：对齐方式与column相反。</li>\n</ul>\n<h3 id="flex-wrap">flex-wrap</h3>\n<p>控制flex容器是单行还是多行</p>\n<p>flex-wrap：nowrap | wrap | wrap-reverse</p>\n<ul>\n<li>nowrap：flex容器为单行。该情况下flex子项可能会溢出容器</li>\n<li>wrap：flex容器为多行。该情况下flex子项溢出的部分会被放置到新行，子项内部会发生断行</li>\n<li>wrap-reverse：反转 wrap 排列。</li>\n</ul>\n<h3 id="align-content">align-content</h3>\n<p>当伸缩容器的侧轴还有多余空间时，本属性可以用来调准「伸缩行」在伸缩容器里的对齐方式，这与调准伸缩项目在主轴上对齐方式的 &lt;&#39; justify-content &#39;&gt; 属性类似。请注意本属性在只有一行的伸缩容器上没有效果。</p>\n<p>注：水平排列时，水平方向为主轴，纵向为侧轴</p>\n',summary:'<hr>\n<h2 id="-">目录</h2>\n<ul>\n<li>伸缩盒(Flexible Box)(新)</li>\n</ul>\n<h2 id="-flexible-box-">伸缩盒(Flexible Box)(新)</h2>\n<ul>\n<li>flex<ul>\n<li>flex-grow</li>\n<li>flex-shrink</li>\n<li>flex-basis</li>\n</ul>\n</li>\n<li>flex-flow<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n</ul>\n</li>\n<li>align-content</li>\n<li>align-items</li>\n<li>align-self</li>\n<li>justify-content</li>\n<li>order</li>\n</ul>\n<h3 id="flex">flex</h3>\n<p>flex帮助我们设置剩余空间如</p>\n'}],total:34}}],error:null,serverRendered:!0}</script><script defer src="/ssr-web/_nuxt/vendor.bundle.js"></script><script defer src="/ssr-web/_nuxt/nuxt.bundle.js"></script>