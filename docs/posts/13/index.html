<!DOCTYPE html><html n-head=""n-head-ssr><meta n-head="true"charset="utf-8"><meta n-head="true"content="width=device-width,initial-scale=1"name="viewport"><meta n-head="true"content="ffe blog"name="description"hid="description"><title n-head="true">post list</title><link href="/favicon.ico"rel="icon"n-head="true"type="image/x-icon"><link href="http://cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"rel="stylesheet"n-head="true"><link href="/_nuxt/style.css"rel="stylesheet"><body n-head=""><div id="__nuxt"server-rendered="true"><div class="progress"data-v-739c3fb7 style="width:0;height:2px;background-color:#000;opacity:0"></div><div class="wrapper"><nav class="main-menu navbar navbar-default"><div class="container"><div class="logo"><a href="/index"><h2>ffe</h2></a></div><div class="nav-item"><ul class="nav navbar-nav navbar-right"><li><a href="/"class="nuxt-link-active">Home</a><li><a href="/page/1">Posts</a><li><a href="/about">About</a></ul></div></div></nav><div class="container post-wrapper"><div><hr><p>&lt;style>img{max-width:100%;}&lt;/style><p>&lt;a class="text-center" href="http://www.ccs.neu.edu/home/matthias/BTLS/">&lt;img data-src="/img/the-lillte-scheme.jpg" alt="the-little-scheme">&lt;/a> the little scheme 是一本小人书，却很精妙。阅读它可以让你对编程语言有更好的认识，也能增加你对算法的理解(你真的会用递归了吗？)。 说明：该书籍使用scheme来作为讲解的语言，scheme是lisp的一门方言，语法上比较特别的是S表达式。看到S表达式是不是感觉和语法树一般，一开始估计不是很习惯S表达式，但静下心来就会发现其实是一种很好理解也很简洁的语法。Good Luck!<p>&lt;img class="text-center" data-src="/img/learn-programm.png" alt="oh,man.I just want to learn programm video game!"> oh,man.I just want to learn programm video game!<h2 id="the-law-of-car">The Law of Car</h2><blockquote><p>The primitive car is defined only for non-empty lists.</blockquote><pre><code class="lang-scheme">Q:
What is the car of l
where
    l is (((hotdogs))(and)(pickle) relish)

A:
((hotdogs)),
    read as:
    "The list of the list of hotdogs."
    ((hotdogs)) is the first S-expression of l.
</code></pre><p>["S表达式", "列表"]<p>&lt;hr><pre><code class="lang-scheme">Q:
What is (car l)
where
    l is (((hotdogs)) (and) (pickle) relish)

A:
((hotdogs)),
because (car l) is another way to ask for "the car of the 
list l."
</code></pre><p>&lt;hr><pre><code class="lang-scheme">Q:
What is (car (car l))
where
    l is (((hotdogs)) (and))
A:
(hotdogs).
</code></pre><p>&lt;hr><pre><code class="lang-scheme">Q:
What is the cdr of l
where
    l is (a b c)
A:
(b c)
    because (b c) is the list l without (car l).
</code></pre><p>&lt;hr><pre><code class="lang-scheme">Q:
What is the cdr of l
where
    l is ((a b c) x y z)
A:
(x y z)
</code></pre><p>&lt;hr><pre><code class="lang-scheme">Q:
What is the cdr of l
where
    l is (hamburger)
A:
()
</code></pre><p>&lt;hr><pre><code class="lang-scheme">Q:
What is (cdr a)
where 
a is hotdogs
A:
No answer
    You cannot ask for the cdr of an atom.
</code></pre><h2 id="the-law-of-cdr">The Law of Cdr</h2><blockquote><p>The primitive cdr is defined only for non-empty lists. The cdr of any non-empty list is always another list.<p>&lt;hr></blockquote><pre><code class="lang-scheme">Q:
what is (car (cdr l))
where
l is ((b)(x y)((c)))
A:
(x y),
because((x y)((c))) is (cdr l), and (x y) is the car of
(cdr l).
</code></pre><p>&lt;hr><pre><code class="lang-scheme">Q:
What is (cdr (cdr l))
where
    l is ((b)(x y)((c)))
A:
(((c))),
because(x y)((c)) is (cdr l), and (((c))) is the cdr of (cdr l).
</code></pre><p>&lt;hr><pre><code class="lang-scheme">Q:
what does car take as an argument?
A:
it takes any non-empty list.
</code></pre><p>&lt;hr><pre><code class="lang-scheme">Q:
What does cdr take as an argument?
A:
It takes any non-empty list.
</code></pre><p>&lt;hr><pre><code class="lang-scheme">Q:
What is the cons of the atom a and the list l
Where a is peanut
and
    l is (butter and jelly)
This can also be written "(cons a l)".
    Read: "cons the atom a onto the list l."
A:
(peanut butter and jelly),
    because cons adds an atom to the front of a list.
</code></pre><pre><code class="lang-scheme">Q:
What is (cons s l)
where
    s is ((help) this)
and
    l is (is very ((hard) to learn))
A:
(((help) this) is very ((hard) to learn)).
</code></pre><pre><code class="lang-scheme">Q:
What does cons take as its arguments?
A:
cons takes two arguments:
    the first one is any S-expression;
    the second one is any list.
</code></pre><h2 id="the-law-of-cons">The Law of Cons</h2><blockquote><p>The primitive cons takes two arguments. The second argument to cons must be a list. The result is a list.</blockquote></div></div><footer class="footer">Visit our website for more documentation : <a href="https://nuxtjs.org"target="_blank">nuxtjs.org</a></footer></div></div><script defer>window.__NUXT__={data:[{post:{meta:{title:"The Little Schemer——read again",date:"2015-11-18T22:51:15.000Z",tags:["lisp","pl"],archives:"pl",id:"25",createTime:"2015-11-19",url:"2015-11-19-The Little Schemer——read again",strTag:"lisp、pl"},content:'<hr>\n<p>&lt;style&gt;img{max-width:100%;}&lt;/style&gt;\n\n</p>\n<p>&lt;a class=&quot;text-center&quot; href=&quot;http://www.ccs.neu.edu/home/matthias/BTLS/&quot;&gt;&lt;img data-src=&quot;/img/the-lillte-scheme.jpg&quot; alt=&quot;the-little-scheme&quot;&gt;&lt;/a&gt;\nthe little scheme 是一本小人书，却很精妙。阅读它可以让你对编程语言有更好的认识，也能增加你对算法的理解(你真的会用递归了吗？)。\n说明：该书籍使用scheme来作为讲解的语言，scheme是lisp的一门方言，语法上比较特别的是S表达式。看到S表达式是不是感觉和语法树一般，一开始估计不是很习惯S表达式，但静下心来就会发现其实是一种很好理解也很简洁的语法。Good Luck!</p>\n<p>&lt;img class=&quot;text-center&quot; data-src=&quot;/img/learn-programm.png&quot; alt=&quot;oh,man.I just want to learn programm video game!&quot;&gt;\noh,man.I just want to learn programm video game!</p>\n<h2 id="the-law-of-car">The Law of Car</h2>\n<blockquote>\n<p>The primitive car is defined only for non-empty lists.</p>\n</blockquote>\n<pre><code class="lang-scheme">Q:\nWhat is the car of l\nwhere\n    l is (((hotdogs))(and)(pickle) relish)\n\nA:\n((hotdogs)),\n    read as:\n    &quot;The list of the list of hotdogs.&quot;\n    ((hotdogs)) is the first S-expression of l.\n</code></pre>\n<p>[&quot;S表达式&quot;, &quot;列表&quot;]</p>\n<p>&lt;hr&gt;</p>\n<pre><code class="lang-scheme">Q:\nWhat is (car l)\nwhere\n    l is (((hotdogs)) (and) (pickle) relish)\n\nA:\n((hotdogs)),\nbecause (car l) is another way to ask for &quot;the car of the \nlist l.&quot;\n</code></pre>\n<p>&lt;hr&gt;\n\n</p>\n<pre><code class="lang-scheme">Q:\nWhat is (car (car l))\nwhere\n    l is (((hotdogs)) (and))\nA:\n(hotdogs).\n</code></pre>\n<p>&lt;hr&gt;\n\n</p>\n<pre><code class="lang-scheme">Q:\nWhat is the cdr of l\nwhere\n    l is (a b c)\nA:\n(b c)\n    because (b c) is the list l without (car l).\n</code></pre>\n<p>&lt;hr&gt;\n\n</p>\n<pre><code class="lang-scheme">Q:\nWhat is the cdr of l\nwhere\n    l is ((a b c) x y z)\nA:\n(x y z)\n</code></pre>\n<p>&lt;hr&gt;\n\n</p>\n<pre><code class="lang-scheme">Q:\nWhat is the cdr of l\nwhere\n    l is (hamburger)\nA:\n()\n</code></pre>\n<p>&lt;hr&gt;\n\n</p>\n<pre><code class="lang-scheme">Q:\nWhat is (cdr a)\nwhere \na is hotdogs\nA:\nNo answer\n    You cannot ask for the cdr of an atom.\n</code></pre>\n<h2 id="the-law-of-cdr">The Law of Cdr</h2>\n<blockquote>\n<p>The primitive cdr is defined only for non-empty lists.\nThe cdr of any non-empty list is always another list.</p>\n<p>&lt;hr&gt;\n\n</p>\n</blockquote>\n<pre><code class="lang-scheme">Q:\nwhat is (car (cdr l))\nwhere\nl is ((b)(x y)((c)))\nA:\n(x y),\nbecause((x y)((c))) is (cdr l), and (x y) is the car of\n(cdr l).\n</code></pre>\n<p>&lt;hr&gt;\n\n</p>\n<pre><code class="lang-scheme">Q:\nWhat is (cdr (cdr l))\nwhere\n    l is ((b)(x y)((c)))\nA:\n(((c))),\nbecause(x y)((c)) is (cdr l), and (((c))) is the cdr of (cdr l).\n</code></pre>\n<p>&lt;hr&gt;\n\n</p>\n<pre><code class="lang-scheme">Q:\nwhat does car take as an argument?\nA:\nit takes any non-empty list.\n</code></pre>\n<p>&lt;hr&gt;\n\n</p>\n<pre><code class="lang-scheme">Q:\nWhat does cdr take as an argument?\nA:\nIt takes any non-empty list.\n</code></pre>\n<p>&lt;hr&gt;\n\n</p>\n<pre><code class="lang-scheme">Q:\nWhat is the cons of the atom a and the list l\nWhere a is peanut\nand\n    l is (butter and jelly)\nThis can also be written &quot;(cons a l)&quot;.\n    Read: &quot;cons the atom a onto the list l.&quot;\nA:\n(peanut butter and jelly),\n    because cons adds an atom to the front of a list.\n</code></pre>\n<pre><code class="lang-scheme">Q:\nWhat is (cons s l)\nwhere\n    s is ((help) this)\nand\n    l is (is very ((hard) to learn))\nA:\n(((help) this) is very ((hard) to learn)).\n</code></pre>\n<pre><code class="lang-scheme">Q:\nWhat does cons take as its arguments?\nA:\ncons takes two arguments:\n    the first one is any S-expression;\n    the second one is any list.\n</code></pre>\n<h2 id="the-law-of-cons">The Law of Cons</h2>\n<blockquote>\n<p>The primitive cons takes two arguments.\nThe second argument to cons must be a list.\nThe result is a list.</p>\n</blockquote>\n',summary:'<hr>\n<p>&lt;style&gt;img{max-width:100%;}&lt;/style&gt;\n\n</p>\n<p>&lt;a class=&quot;text-center&quot; href=&quot;http://www.ccs.neu.edu/home/matthias/BTLS/&quot;&gt;&lt;img data-src=&quot;/img/the-lillte-scheme.jpg&quot; alt=&quot;the-little-scheme&quot;&gt;&lt;/a&gt;\nthe little scheme 是一本小人书，却很精妙。阅读它可以让你对编程语言有更好的认识，也能增加你对算法的理解(你真的会用递归了吗？)。\n说明：该书籍使用scheme来作为讲解的语言，scheme是lisp的一门方言，语法上比较特别的是S表达式。看到S表达式是不是感觉和语法树一般，一开始估计不是很习惯S表达式，但静下心来就会发现其实是一种很好理解也很简洁的语法。Good Luck!</p>\n<p>&lt;img class=&quot;text-center&quot; data-src=&quot;/img/learn-programm.png&quot; alt=&quot;oh,man.I just want to learn programm video game!&quot;&gt;\noh,man.I just want to learn programm video game!</p>\n<h2 id="the-law-of-car">The Law of Car</h2>\n<blockquote>\n<p>The primitive car is defined only for non-empty lists.</p>\n</blockquote>\n'}}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/vendor.bundle.js"></script><script defer src="/_nuxt/nuxt.bundle.js"></script>