<!DOCTYPE html><html n-head=""n-head-ssr><meta n-head="true"charset="utf-8"><meta n-head="true"content="width=device-width,initial-scale=1"name="viewport"><meta n-head="true"content="ffe blog"name="description"hid="description"><title n-head="true">post list</title><link href="/favicon.ico"rel="icon"n-head="true"type="image/x-icon"><link href="http://cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"rel="stylesheet"n-head="true"><base href="/ssr-web/"><link href="/ssr-web/_nuxt/style.css"rel="stylesheet"><body n-head=""><div id="__nuxt"server-rendered="true"><div class="progress"data-v-1ef32859 style="width:0;height:2px;background-color:#000;opacity:0"></div><div class="wrapper"><nav class="main-menu navbar navbar-default"><div class="container"><div class="logo"><a href="/ssr-web/"class="nuxt-link-active"><h2>ffe</h2></a></div><div class="nav-item"><ul class="nav navbar-nav navbar-right"><li><a href="/ssr-web/"class="nuxt-link-active">Home</a><li><a href="/ssr-web/page/1">Posts</a><li><a href="/ssr-web/about">About</a></ul></div></div></nav><div class="container post-wrapper"><div><a href="/ssr-web/posts/30"class="nuxt-link-active"><h2>javascript 闭包、this</h2></a></div><div class="post-meta"><span>js、pl</span><span>2016-01-25</span></div><div><div><hr><blockquote><p>闭包其实很好理解，但是由于经常把this和闭包绑在一起，从而加大了理解的难度，如果将他们分开考虑，那就清晰多了。</blockquote><h2 id="-">闭包</h2><p>闭包并不是js首创，在许多语言中都支持闭包，如schemer、ruby等。如果没有闭包，像js这样的支持高阶函数特性的语言将是一个噩梦。<ul><li>静态作用域<li>动态作用域</ul><pre><code class="lang-js">var name = "xiaofu";
var person = function(lastname){
    var name = 'yang';

    function personName(){
        return name + lastname;
    }
    return personName;
}
var pName = person();
pName("xiaoming");
</code></pre><p>js是函数作用域的，即一个function就是一个作用域，所以personName在person这个函数的作用域里面。但是调用的是在这个作用域的外面，那么当personName执行的时候，它里面的name取的是person这个作用域还是最外层的作用域呢？<p>如果是静态作用域则调用的是person里面的 name, 如果是动态作用域则调用的是外层的name("xiaofu");而不是"yang"。<p>而闭包就是用来实现静态作用域的一种方式，即通过闭包将函数和它声明时的作用域保存下来，这样在调用的时候取到的就是声明时所在的作用域而不是调用时的作用域。<h2 id="this">this</h2><p>this则与变量有点不同，即this采用的是类似于动态作用域的情况。js里面一切都是对象，所以函数也都是某个对象的方法，如果没有显示指定则是全局对象。<pre><code class="lang-js">var person = {
    fullname: function{
        console.log(this);
    },
    printAge: function(){
        console.log(this);
    }
}
person.fullname();        //this指向person
var age = person.printAge;
age();                    //this指向window(浏览器中)
</code></pre><p>将person.printAge赋值给age之后，再执行age(),此时age没有显示指定调用对象则默认是window(浏览器环境)。所以this并不是声明所在的环境。<h2 id="-es6-">箭头函数（es6)</h2><p>es6中新增了箭头函数，箭头函数与通过function声明的函数不同，它的this是使用的声明时上下文中的this.并且不可通过apply, call等改变。</div></div></div><footer class="footer">Visit our website for more documentation : <a href="https://nuxtjs.org"target="_blank">nuxtjs.org</a></footer></div></div><script defer>window.__NUXT__={data:[{post:{meta:{title:"javascript 闭包、this",date:"2016-01-25T15:06:36.000Z",tags:["js","pl"],id:"30",createTime:"2016-01-25",url:"2016-01-25-javascript 闭包、this",strTag:"js、pl"},content:'<hr>\n<blockquote>\n<p>闭包其实很好理解，但是由于经常把this和闭包绑在一起，从而加大了理解的难度，如果将他们分开考虑，那就清晰多了。</p>\n</blockquote>\n<h2 id="-">闭包</h2>\n<p>闭包并不是js首创，在许多语言中都支持闭包，如schemer、ruby等。如果没有闭包，像js这样的支持高阶函数特性的语言将是一个噩梦。</p>\n<ul>\n<li>静态作用域</li>\n<li>动态作用域</li>\n</ul>\n<pre><code class="lang-js">var name = &quot;xiaofu&quot;;\nvar person = function(lastname){\n    var name = &#39;yang&#39;;\n\n    function personName(){\n        return name + lastname;\n    }\n    return personName;\n}\nvar pName = person();\npName(&quot;xiaoming&quot;);\n</code></pre>\n<p>js是函数作用域的，即一个function就是一个作用域，所以personName在person这个函数的作用域里面。但是调用的是在这个作用域的外面，那么当personName执行的时候，它里面的name取的是person这个作用域还是最外层的作用域呢？</p>\n<p>如果是静态作用域则调用的是person里面的 name, 如果是动态作用域则调用的是外层的name(&quot;xiaofu&quot;);而不是&quot;yang&quot;。</p>\n<p>而闭包就是用来实现静态作用域的一种方式，即通过闭包将函数和它声明时的作用域保存下来，这样在调用的时候取到的就是声明时所在的作用域而不是调用时的作用域。</p>\n<h2 id="this">this</h2>\n<p>this则与变量有点不同，即this采用的是类似于动态作用域的情况。js里面一切都是对象，所以函数也都是某个对象的方法，如果没有显示指定则是全局对象。</p>\n<pre><code class="lang-js">var person = {\n    fullname: function{\n        console.log(this);\n    },\n    printAge: function(){\n        console.log(this);\n    }\n}\nperson.fullname();        //this指向person\nvar age = person.printAge;\nage();                    //this指向window(浏览器中)\n</code></pre>\n<p>将person.printAge赋值给age之后，再执行age(),此时age没有显示指定调用对象则默认是window(浏览器环境)。所以this并不是声明所在的环境。</p>\n<h2 id="-es6-">箭头函数（es6)</h2>\n<p>es6中新增了箭头函数，箭头函数与通过function声明的函数不同，它的this是使用的声明时上下文中的this.并且不可通过apply, call等改变。</p>\n',summary:'<hr>\n<blockquote>\n<p>闭包其实很好理解，但是由于经常把this和闭包绑在一起，从而加大了理解的难度，如果将他们分开考虑，那就清晰多了。</p>\n</blockquote>\n<h2 id="-">闭包</h2>\n<p>闭包并不是js首创，在许多语言中都支持闭包，如schemer、ruby等。如果没有闭包，像js这样的支持高阶函数特性的语言将是一个噩梦。</p>\n<ul>\n<li>静态作用域</li>\n<li>动态作用域</li>\n</ul>\n<pre><code class="lang-js">var name = &quot;xiaofu&quot;;\nvar person = function(lastname){\n    var name = &#39;yang&#39;;\n\n    function personName(){\n        return name + lastname;\n    }\n    return personName;\n}\nvar pName = person();\npName(&quot;xiaoming&quot;);\n</code></pre>\n<p>js是函数作用域的，即一个function就是一个作用域，所以personName在person这个函数的作用域里面。但是调用的是在这个作用域的外面，那么当personName执行的时候，它里面的name取的是person这个作用域还是最外层的作用域呢？</p>\n<p>如果是静态作用域则调用的是person里面的 name, 如果是动态作用域则调用的是外层的name(&quot;xiaofu&quot;);而不是&quot;yang&quot;。</p>\n<p>而闭包就是用来实现静态作用域的一种方式，即通过闭包将函数和它声明时的作用域保存下来，这样在调用的时候取到的就是声明时所在的作用域而不是调用时的作用域。</p>\n'}}],error:null,serverRendered:!0}</script><script defer src="/ssr-web/_nuxt/vendor.bundle.js"></script><script defer src="/ssr-web/_nuxt/nuxt.bundle.js"></script>