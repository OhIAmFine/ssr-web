<!DOCTYPE html><html n-head=""n-head-ssr><meta n-head="true"charset="utf-8"><meta n-head="true"content="width=device-width,initial-scale=1"name="viewport"><meta n-head="true"content="ffe blog"name="description"hid="description"><title n-head="true">post list</title><link href="/favicon.ico"rel="icon"n-head="true"type="image/x-icon"><link href="http://cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"rel="stylesheet"n-head="true"><base href="/nuxt-blog/"><link href="/nuxt-blog/_nuxt/style.css"rel="stylesheet"><body n-head=""><div id="__nuxt"server-rendered="true"><div class="progress"data-v-739c3fb7 style="width:0;height:2px;background-color:#000;opacity:0"></div><div class="wrapper"><nav class="main-menu navbar navbar-default"><div class="container"><div class="logo"><a href="/nuxt-blog/"><h2>ffe</h2></a></div><div class="nav-item"><ul class="nav navbar-nav navbar-right"><li><a href="/nuxt-blog/">Home</a><li><a href="/nuxt-blog/page/1">Posts</a><li><a href="/nuxt-blog/about">About</a></ul></div></div></nav><div class="container post-wrapper"><div><a href="/nuxt-blog/posts/26"><h2>prototype、__proto__、constructor、this——不懂别说会JS</h2></a></div><div class="post-meta"><span>jquery、js</span><span>2015-11-28</span></div><div><div><hr><p>&lt;img data-src="/img/prototype/so_many_questions.png" alt="so_many_questions"> 刚开始接触js的时候，我的疑问就像上面密密麻麻的问题。。。<h2 id="js-">JS对象</h2><ul><li>每一个Javascript对象(null除外)都和另一个对象相关联，即原型，每一个对象都从原型继承属性。<li>所有通过对象直接量创建的对象都具有同一个原型对象，通过Object.prototype可以获得对原型对象的引用。<li>通过new关键字和构造函数创建的对象的原型就是构造函数的prototype属性的值<li>普通的原型对象属于普通对象，普通对象都具有原型(Object.prototype比较特殊，不继承任何属性)<li>所有的内置构造函数以及大部分自定义构造函数都具有一个继承自Object.prototype的原型<li>构造函数的原型中存在预先定义好的constructor属性，对象继承的constructor均指代他们的构造函数。构造函数是类的标识，因此这个constructor属性为对象提供了类</ul><pre><code class="lang-javascript">var o = new F();
o.constructor === F    /*true,指代类本身*/
</code></pre><h2 id="javascript-class-">Javascript中class的写法</h2><p>注：为和普通函数区别开，类的命名首字母一般是大写<p>下面定义了Cat、cat类<pre><code class="lang-javascript">/*写法一：*/
var Cat = function(){
    this.animal = "Cat:大写的猫";
};

var cat = function(){
    this.animal = "cat:小写的猫";
};
</code></pre><pre><code class="lang-javascript">/*写法二：*/
function Cat(){
    this.animal = "Cat:大写的猫";
}

function cat(){
    this.animal = "Cat:小写的猫";
}
</code></pre><p>这里输出的结果是相同的，即类的命名首字母大写并不是强制的<h3 id="-">对象生成</h3><pre><code class="lang-javascript">var objCat = new Cat; /*大写的猫对象*/
var objcat = new cat; /*小写的猫对象*/

/*输出*/
console.log(objCat, objcat);
</code></pre><p>&lt;img src="/img/prototype/cat-01.png" alt="类的命名首字母大写并不是强制的"><p>从上面我们可以看到:对象objCat——><strong>proto</strong>[Cat类]——><strong>proto</strong>[Object对象],这就是所谓的继承链.<h2 id="prototype-vs-__proto__-">prototype VS <strong>proto</strong> 对象</h2><h3 id="-prototype-">添加prototype对象</h3><p>这里给Cat添加prototype对象,cat不做改动<pre><code class="lang-javascript">/*写法一：*/
var Cat = function(){
    this.animal = "Cat:大写的猫";
};

var cat = function(){
    this.animal = "cat:小写的猫";
};

Cat.prototype.eat = function(){
    return "I like fish!";
}
</code></pre><p>说明：同一个类生成的所有对象会共用类的prototype对象上挂载的方法和属性<pre><code class="lang-javascript">redCat = new Cat;
greenCat = new Cat;

console.log(redCat.eat(), greenCat.eat());
</code></pre><p>redCat和greenCat调用的是同一个方法即Cat.prototype.eat,所以都会输出"I like fish!".<pre><code class="lang-javascript">Cat.prototype.eat = function(){
    return "I like fish!";
}
</code></pre><p>/<em>同样输出两个生成的对象</em>/<pre><code class="lang-javascript">console.log(objCat, objcat);
</code></pre><p>&lt;img src="/img/prototype/cat-02.png" alt="这里给Cat添加prototype对象,cat不做改动"><p>从上图可以发现大写的猫对象多输出了两行,这里出现了一个"<strong>proto</strong>"属性,那么它代表什么呢？因为这是我们的Cat类设置了prototype后Cat对象才出现的属性，所以我们可以猜测这两者之间有某种密切的关系，为了验证我们的想法，我们可以输出测试一下。<pre><code class="lang-javascript">console.log(objCat.__proto__, Cat.prototype);
</code></pre><p>&lt;img src="/img/prototype/cat-03.png" alt="console.log(objCat.__proto__, Cat.prototype)"><p>我们可以惊奇的发现输出结果一模一样，为了再次证明它们是同一个东西，我们再次进行验证<pre><code class="lang-javascript">/*注意这里是3个等号哦*/
console.log(objCat.__proto__ === Cat.prototype);              /*result:true*/
console.log(objCat.__proto__.eat(), Cat.prototype.eat());    /*I like fish! I like fish!,调用了同一个 eat 方法*/
</code></pre><p>从这里我们可以得一个结论：对象会继承类的prototype对象并存在一个名为"<strong>proto</strong>"的属性中,即对象的"<strong>proto</strong>"属性指向生成它的类的"prototype"对象<p>&lt;p class="text-important">protoype和<strong>proto</strong>统称为原型对象，但前者是在类中，后者是在对象中的表示，实例对象中没有prototype属性的。[js中的类是通过function来模拟的，每一个function都有一个prototype属性&lt;/p><h2 id="constructor-">constructor属性</h2><p>构造函数的原型中存在预先定义好的constructor属性，对象继承的constructor均指代他们的构造函数。构造函数是类的标识，因此这个constructor属性为对象提供了类.<p>这句话怎么来理解呢？<p>1 .构造函数的原型中存在预定义好的constructor属性 2 .constructor指代他们的构造函数 3 .constructor属性为对象提供了类<pre><code class="lang-javascript">var CatConstructor = Cat.prototype.constructor;
console.log("Cat:", Cat, Cat.prototype);
console.log("CatConstructor:", CatConstructor, CatConstructor.prototype);
</code></pre><p>这里为了更清晰的理解上面这几个点，我们将Cat类的原型的constructor属性赋值给CatConstructor,然后分别打印他们本身以及他们的原型对象。<p>&lt;img src="/img/prototype/cat-04.png" alt="Cat.prototype.constructor"><p>从上图我们可以发现两者是完全一样的，即Cat.prototype.constructor等于Cat本身。<p>那么第三点怎么理解呢？既然constructor代表Cat构造函数本身，那么我们是不是可以用它来生成对象——类才具有的功能<pre><code class="lang-javascript">var CatConstructor = Cat.prototype.constructor;
var newObjCat = new CatConstructor;

console.log("objCat:", objCat, "newObjCat", newObjCat);
</code></pre><p>&lt;img src="/img/prototype/cat-05.png" alt=""objCat:", objCat, "newObjCat", newObjCat"><p>如我们所料，上面输出的objCat和newObjCat结果是一样的，所以验证了第三点，类的原型的constructor属性即类本身<h2 id="this-">this——到底指向了谁</h2><pre><code class="lang-javascript">Cat.init = function(){
    console.log("Cat:", this);
    return this;
}

Cat.prototype.init = function(){
    console.log("Cat-prototype:", this);
    return this;
}

Cat.init();                /*this代表Cat类本身*/
Cat.prototype.init();    /*this代表Cat.prototype对象*/

objCat.init();            /*this代表objCat对象本身*/
</code></pre><p>&lt;img src="/img/prototype/cat-06.png" alt="this——到底指向了谁"><p>从上图可以发现，输出为：<p>Cat.init():输出构成函数本身 Cat.prototype.init():输出类的原型对象 objCat.init(): 输出结果都是objCat对象本身且调用的是Cat.prototype.init方法<p>从上面我们可以知道this始终指向调用方法的对象本身<h3 id="-">构造函数中调用原型对象上绑定的方法——指向谁呢</h3><p>注：当我们在说构造函数的时候，其实是将构造函数和类等同起来<pre><code class="lang-javascript">/*jquery构造函数模拟*/
var Cat = function(){
    this.animal = "Cat:大写的猫";
    /*调用原型上绑定的init方法*/
    return new Cat.prototype.init();
};
Cat.prototype = {
    init: function(){
        return this;    /*当做为构造函数时，返回值好像并没有啥用处*/
    }
}
Cat.prototype.init.prototype = Cat.prototype;

Cat();
</code></pre><h3 id="-">稍稍复杂一点的情况</h3><pre><code class="lang-javascript">var Cat = function(params){
    this.animal = "Cat:大写的猫";
    /*调用原型上绑定的init方法*/
    return new Cat.prototype.init(params);
};
Cat.prototype = {
    init: function(params){
        this.animal = params;
        this.type = params;
        this.color = params;
    },
    eat: function(){
        return "I like fish!";
    },
    name: function(){
        return this.animal;
    },
    color: 'yellow'
}
Cat.prototype.init.prototype = Cat.prototype;

var redCat = Cat("redCat");
var greenCat = Cat("greenCat");
console.log(redCat, greenCat);
</code></pre><p>输出结果如下：<p>&lt;img src="/img/prototype/cat-07.png" alt="jquery对象生成方式模拟"><p>&lt;p class="text-important">这里的init方法里的this指向的是Cat.prototype,init方法里的animal和Cat类的animal也没有关系,init这时相当于我们的构造函数，而它自身又是自身的prototype里的一个方法[是不是已已绕晕。。。]&lt;/p><ul><li>this.animal = params;<li>this.type = params;<li>this.color = params;</ul><p>它们是构造函数即类的属性，而init函数外面的color: 'yellow'是挂在原型上的，所以生成的对象在访问color属性的时候是获取构造函数里的值[原型链继承的优先级]<pre><code class="lang-javascript">console.log(redCat.__proto__.color);        /*输出结果是:yelow,说明我的确是挂在类的原型上的*/
</code></pre><p>&lt;p class="text-important">上述的jquery构造函数语法模拟的一个不足就是无法得到Cat类上的属性,如Cat里的animal.[如果你有好的方法获取请告知我]&lt;/p></div></div></div><footer class="footer">Visit our website for more documentation : <a href="https://nuxtjs.org"target="_blank">nuxtjs.org</a></footer></div></div><script defer>window.__NUXT__={data:[{post:{meta:{title:"prototype、__proto__、constructor、this——不懂别说会JS",date:"2015-11-28T01:06:36.000Z",archives:"pl",tags:["jquery","js"],id:"26",createTime:"2015-11-28",url:"2015-11-28-prototype、__proto__、constructor、this——不懂别说会JS",strTag:"jquery、js"},content:'<hr>\n<p>&lt;img data-src=&quot;/img/prototype/so_many_questions.png&quot; alt=&quot;so_many_questions&quot;&gt;\n刚开始接触js的时候，我的疑问就像上面密密麻麻的问题。。。</p>\n<h2 id="js-">JS对象</h2>\n<ul>\n<li>每一个Javascript对象(null除外)都和另一个对象相关联，即原型，每一个对象都从原型继承属性。</li>\n<li>所有通过对象直接量创建的对象都具有同一个原型对象，通过Object.prototype可以获得对原型对象的引用。</li>\n<li>通过new关键字和构造函数创建的对象的原型就是构造函数的prototype属性的值</li>\n<li>普通的原型对象属于普通对象，普通对象都具有原型(Object.prototype比较特殊，不继承任何属性)</li>\n<li>所有的内置构造函数以及大部分自定义构造函数都具有一个继承自Object.prototype的原型</li>\n<li>构造函数的原型中存在预先定义好的constructor属性，对象继承的constructor均指代他们的构造函数。构造函数是类的标识，因此这个constructor属性为对象提供了类</li>\n</ul>\n<pre><code class="lang-javascript">var o = new F();\no.constructor === F    /*true,指代类本身*/\n</code></pre>\n<h2 id="javascript-class-">Javascript中class的写法</h2>\n<p>注：为和普通函数区别开，类的命名首字母一般是大写</p>\n<p>下面定义了Cat、cat类</p>\n<pre><code class="lang-javascript">/*写法一：*/\nvar Cat = function(){\n    this.animal = &quot;Cat:大写的猫&quot;;\n};\n\nvar cat = function(){\n    this.animal = &quot;cat:小写的猫&quot;;\n};\n</code></pre>\n<pre><code class="lang-javascript">/*写法二：*/\nfunction Cat(){\n    this.animal = &quot;Cat:大写的猫&quot;;\n}\n\nfunction cat(){\n    this.animal = &quot;Cat:小写的猫&quot;;\n}\n</code></pre>\n<p>这里输出的结果是相同的，即类的命名首字母大写并不是强制的</p>\n<h3 id="-">对象生成</h3>\n<pre><code class="lang-javascript">var objCat = new Cat; /*大写的猫对象*/\nvar objcat = new cat; /*小写的猫对象*/\n\n/*输出*/\nconsole.log(objCat, objcat);\n</code></pre>\n<p>&lt;img src=&quot;/img/prototype/cat-01.png&quot; alt=&quot;类的命名首字母大写并不是强制的&quot;&gt;</p>\n<p>从上面我们可以看到:对象objCat——&gt;<strong>proto</strong>[Cat类]——&gt;<strong>proto</strong>[Object对象],这就是所谓的继承链.</p>\n<h2 id="prototype-vs-__proto__-">prototype VS <strong>proto</strong> 对象</h2>\n<h3 id="-prototype-">添加prototype对象</h3>\n<p>这里给Cat添加prototype对象,cat不做改动</p>\n<pre><code class="lang-javascript">/*写法一：*/\nvar Cat = function(){\n    this.animal = &quot;Cat:大写的猫&quot;;\n};\n\nvar cat = function(){\n    this.animal = &quot;cat:小写的猫&quot;;\n};\n\nCat.prototype.eat = function(){\n    return &quot;I like fish!&quot;;\n}\n</code></pre>\n<p>说明：同一个类生成的所有对象会共用类的prototype对象上挂载的方法和属性</p>\n<pre><code class="lang-javascript">redCat = new Cat;\ngreenCat = new Cat;\n\nconsole.log(redCat.eat(), greenCat.eat());\n</code></pre>\n<p>redCat和greenCat调用的是同一个方法即Cat.prototype.eat,所以都会输出&quot;I like fish!&quot;.</p>\n<pre><code class="lang-javascript">Cat.prototype.eat = function(){\n    return &quot;I like fish!&quot;;\n}\n</code></pre>\n<p>/<em>同样输出两个生成的对象</em>/</p>\n<pre><code class="lang-javascript">console.log(objCat, objcat);\n</code></pre>\n<p>&lt;img src=&quot;/img/prototype/cat-02.png&quot; alt=&quot;这里给Cat添加prototype对象,cat不做改动&quot;&gt;</p>\n<p>从上图可以发现大写的猫对象多输出了两行,这里出现了一个&quot;<strong>proto</strong>&quot;属性,那么它代表什么呢？因为这是我们的Cat类设置了prototype后Cat对象才出现的属性，所以我们可以猜测这两者之间有某种密切的关系，为了验证我们的想法，我们可以输出测试一下。</p>\n<pre><code class="lang-javascript">console.log(objCat.__proto__, Cat.prototype);\n</code></pre>\n<p>&lt;img src=&quot;/img/prototype/cat-03.png&quot; alt=&quot;console.log(objCat.__proto__, Cat.prototype)&quot;&gt;</p>\n<p>我们可以惊奇的发现输出结果一模一样，为了再次证明它们是同一个东西，我们再次进行验证</p>\n<pre><code class="lang-javascript">/*注意这里是3个等号哦*/\nconsole.log(objCat.__proto__ === Cat.prototype);              /*result:true*/\nconsole.log(objCat.__proto__.eat(), Cat.prototype.eat());    /*I like fish! I like fish!,调用了同一个 eat 方法*/\n</code></pre>\n<p>从这里我们可以得一个结论：对象会继承类的prototype对象并存在一个名为&quot;<strong>proto</strong>&quot;的属性中,即对象的&quot;<strong>proto</strong>&quot;属性指向生成它的类的&quot;prototype&quot;对象</p>\n<p>&lt;p class=&quot;text-important&quot;&gt;protoype和<strong>proto</strong>统称为原型对象，但前者是在类中，后者是在对象中的表示，实例对象中没有prototype属性的。[js中的类是通过function来模拟的，每一个function都有一个prototype属性&lt;/p&gt;\n\n</p>\n<h2 id="constructor-">constructor属性</h2>\n<p>构造函数的原型中存在预先定义好的constructor属性，对象继承的constructor均指代他们的构造函数。构造函数是类的标识，因此这个constructor属性为对象提供了类.</p>\n<p>这句话怎么来理解呢？</p>\n<p>1 .构造函数的原型中存在预定义好的constructor属性\n2 .constructor指代他们的构造函数\n3 .constructor属性为对象提供了类</p>\n<pre><code class="lang-javascript">var CatConstructor = Cat.prototype.constructor;\nconsole.log(&quot;Cat:&quot;, Cat, Cat.prototype);\nconsole.log(&quot;CatConstructor:&quot;, CatConstructor, CatConstructor.prototype);\n</code></pre>\n<p>这里为了更清晰的理解上面这几个点，我们将Cat类的原型的constructor属性赋值给CatConstructor,然后分别打印他们本身以及他们的原型对象。</p>\n<p>&lt;img src=&quot;/img/prototype/cat-04.png&quot; alt=&quot;Cat.prototype.constructor&quot;&gt;</p>\n<p>从上图我们可以发现两者是完全一样的，即Cat.prototype.constructor等于Cat本身。</p>\n<p>那么第三点怎么理解呢？既然constructor代表Cat构造函数本身，那么我们是不是可以用它来生成对象——类才具有的功能</p>\n<pre><code class="lang-javascript">var CatConstructor = Cat.prototype.constructor;\nvar newObjCat = new CatConstructor;\n\nconsole.log(&quot;objCat:&quot;, objCat, &quot;newObjCat&quot;, newObjCat);\n</code></pre>\n<p>&lt;img src=&quot;/img/prototype/cat-05.png&quot; alt=&quot;&quot;objCat:&quot;, objCat, &quot;newObjCat&quot;, newObjCat&quot;&gt;</p>\n<p>如我们所料，上面输出的objCat和newObjCat结果是一样的，所以验证了第三点，类的原型的constructor属性即类本身</p>\n<h2 id="this-">this——到底指向了谁</h2>\n<pre><code class="lang-javascript">Cat.init = function(){\n    console.log(&quot;Cat:&quot;, this);\n    return this;\n}\n\nCat.prototype.init = function(){\n    console.log(&quot;Cat-prototype:&quot;, this);\n    return this;\n}\n\nCat.init();                /*this代表Cat类本身*/\nCat.prototype.init();    /*this代表Cat.prototype对象*/\n\nobjCat.init();            /*this代表objCat对象本身*/\n</code></pre>\n<p>&lt;img src=&quot;/img/prototype/cat-06.png&quot; alt=&quot;this——到底指向了谁&quot;&gt;</p>\n<p>从上图可以发现，输出为：</p>\n<p>Cat.init():输出构成函数本身\nCat.prototype.init():输出类的原型对象\nobjCat.init(): 输出结果都是objCat对象本身且调用的是Cat.prototype.init方法</p>\n<p>从上面我们可以知道this始终指向调用方法的对象本身</p>\n<h3 id="-">构造函数中调用原型对象上绑定的方法——指向谁呢</h3>\n<p>注：当我们在说构造函数的时候，其实是将构造函数和类等同起来</p>\n<pre><code class="lang-javascript">/*jquery构造函数模拟*/\nvar Cat = function(){\n    this.animal = &quot;Cat:大写的猫&quot;;\n    /*调用原型上绑定的init方法*/\n    return new Cat.prototype.init();\n};\nCat.prototype = {\n    init: function(){\n        return this;    /*当做为构造函数时，返回值好像并没有啥用处*/\n    }\n}\nCat.prototype.init.prototype = Cat.prototype;\n\nCat();\n</code></pre>\n<h3 id="-">稍稍复杂一点的情况</h3>\n<pre><code class="lang-javascript">var Cat = function(params){\n    this.animal = &quot;Cat:大写的猫&quot;;\n    /*调用原型上绑定的init方法*/\n    return new Cat.prototype.init(params);\n};\nCat.prototype = {\n    init: function(params){\n        this.animal = params;\n        this.type = params;\n        this.color = params;\n    },\n    eat: function(){\n        return &quot;I like fish!&quot;;\n    },\n    name: function(){\n        return this.animal;\n    },\n    color: &#39;yellow&#39;\n}\nCat.prototype.init.prototype = Cat.prototype;\n\nvar redCat = Cat(&quot;redCat&quot;);\nvar greenCat = Cat(&quot;greenCat&quot;);\nconsole.log(redCat, greenCat);\n</code></pre>\n<p>输出结果如下：</p>\n<p>&lt;img src=&quot;/img/prototype/cat-07.png&quot; alt=&quot;jquery对象生成方式模拟&quot;&gt;</p>\n<p>&lt;p class=&quot;text-important&quot;&gt;这里的init方法里的this指向的是Cat.prototype,init方法里的animal和Cat类的animal也没有关系,init这时相当于我们的构造函数，而它自身又是自身的prototype里的一个方法[是不是已已绕晕。。。]&lt;/p&gt;\n\n</p>\n<ul>\n<li>this.animal = params;</li>\n<li>this.type = params;</li>\n<li>this.color = params;</li>\n</ul>\n<p>它们是构造函数即类的属性，而init函数外面的color: &#39;yellow&#39;是挂在原型上的，所以生成的对象在访问color属性的时候是获取构造函数里的值[原型链继承的优先级]</p>\n<pre><code class="lang-javascript">console.log(redCat.__proto__.color);        /*输出结果是:yelow,说明我的确是挂在类的原型上的*/\n</code></pre>\n<p>&lt;p class=&quot;text-important&quot;&gt;上述的jquery构造函数语法模拟的一个不足就是无法得到Cat类上的属性,如Cat里的animal.[如果你有好的方法获取请告知我]&lt;/p&gt;\n\n\n\n\n\n\n</p>\n',summary:'<hr>\n<p>&lt;img data-src=&quot;/img/prototype/so_many_questions.png&quot; alt=&quot;so_many_questions&quot;&gt;\n刚开始接触js的时候，我的疑问就像上面密密麻麻的问题。。。</p>\n<h2 id="js-">JS对象</h2>\n<ul>\n<li>每一个Javascript对象(null除外)都和另一个对象相关联，即原型，每一个对象都从原型继承属性。</li>\n<li>所有通过对象直接量创建的对象都具有同一个原型对象，通过Object.prototype可以获得对原型对象的引用。</li>\n<li>通过new关键字和构造函数创建的对象的原型就是构造函数的prototype属性的值</li>\n<li>普通的原型对象属于普通对象，普通对象都具有原型(Object.prototype比较特殊，不继承任何属性)</li>\n<li>所有的内置构造函数以及大部分自定义构造函数都具有一个继承自Object.prototype的原型</li>\n<li>构造函数的原型中存在预先定义好的constructor属性，对象继承的constructor均指代他们的构造函数。构造函数是类的标识，因此这个constructor属性为对象提供了类</li>\n</ul>\n<pre><code class="lang-javascript">var o = new F();\no.constructor === F    /*true,指代类本身*/\n</code></pre>\n'}}],error:null,serverRendered:!0}</script><script defer src="/nuxt-blog/_nuxt/vendor.bundle.js"></script><script defer src="/nuxt-blog/_nuxt/nuxt.bundle.js"></script>